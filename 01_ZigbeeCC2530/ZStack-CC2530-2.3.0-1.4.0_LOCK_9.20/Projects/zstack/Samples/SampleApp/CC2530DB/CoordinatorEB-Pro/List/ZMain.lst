###############################################################################
#
# IAR C/C++ Compiler V9.20.1.2476 for 8051                26/May/2017  14:34:56
# Copyright 2004-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\ZMain\TI2530DB\ZMain.c
#    Command line       =  
#        -f
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wCoord.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DZDO_COORDINATOR -DRTR_NWK -DBLINK_LEDS) -f
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg
#        (-DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_POLLED=3000
#        -DNWK_INDIRECT_MSG_TIMEOUT=7 -DMAX_RREQ_ENTRIES=8
#        -DAPSC_MAX_FRAME_RETRIES=3 -DNWK_MAX_DATA_RETRIES=2
#        -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9 -DAPS_MAX_GROUPS=16
#        -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"
#        -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000
#        -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)
#        -DREJOIN_POLL_RATE=440
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\ZMain\TI2530DB\ZMain.c
#        -D ZIGBEEPRO -D ZTOOL_P1 -D xMT_TASK -D xMT_SYS_FUNC -D xMT_ZDO_FUNC
#        -D NV_RESTORE -lC
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\CoordinatorEB-Pro\List\
#        -lA
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\CoordinatorEB-Pro\List\
#        --diag_suppress Pe001,Pa010 -o
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\CoordinatorEB-Pro\Obj\
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 8 -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\SOURCE\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\ZMAIN\TI2530DB\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MT\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\INCLUDE\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\TARGET\CC2530EB\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\MCU\CCSOC\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\INCLUDE\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\AF\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\NWK\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SEC\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SAPI\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SYS\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\ZDO\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\F8W\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES\SADDR\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES\SDATA\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\INCLUDE\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\HIGH_LEVEL\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\SINGLE_CHIP\
#        -Ohz --require_prototypes
#    List file          =  
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\CoordinatorEB-Pro\List\ZMain.lst
#    Object file        =  
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\CoordinatorEB-Pro\Obj\ZMain.r51
#
###############################################################################

D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\ZMain\TI2530DB\ZMain.c
      1          /**************************************************************************************************
      2            Filename:       ZMain.c
      3            Revised:        $Date: 2009-09-17 20:35:33 -0700 (Thu, 17 Sep 2009) $
      4            Revision:       $Revision: 20782 $
      5          
      6            Description:    Startup and shutdown code for ZStack
      7            Notes:          This version targets the Chipcon CC2530
      8          
      9          
     10            Copyright 2005-2009 Texas Instruments Incorporated. All rights reserved.
     11          
     12            IMPORTANT: Your use of this Software is limited to those specific rights
     13            granted under the terms of a software license agreement between the user
     14            who downloaded the software, his/her employer (which must be your employer)
     15            and Texas Instruments Incorporated (the "License").  You may not use this
     16            Software unless you agree to abide by the terms of the License. The License
     17            limits your use, and you acknowledge, that the Software may not be modified,
     18            copied or distributed unless embedded on a Texas Instruments microcontroller
     19            or used solely and exclusively in conjunction with a Texas Instruments radio
     20            frequency transceiver, which is integrated into your product.  Other than for
     21            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     22            works of, modify, distribute, perform, display or sell this Software and/or
     23            its documentation for any purpose.
     24          
     25            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     26            PROVIDED “AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     27            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     28            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     29            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     30            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     31            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     32            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     33            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     34            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     35            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     36          
     37            Should you have any questions regarding your right to use this Software,
     38            contact Texas Instruments Incorporated at www.TI.com.
     39          **************************************************************************************************/
     40          
     41          /*********************************************************************
     42           * INCLUDES
     43           */
     44          
     45          #include "ZComDef.h"
     46          #include "OSAL.h"
     47          #include "OSAL_Nv.h"
     48          #include "OnBoard.h"

   \                                 In  segment SFR_AN, at 0x8f
   \   unsigned char volatile __sfr P0INP
   \                     P0INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x90
   \   union <unnamed> volatile __sfr _A_P1
   \                     _A_P1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9d
   \   unsigned char volatile __sfr SLEEPSTA
   \                     SLEEPSTA:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9e
   \   unsigned char volatile __sfr CLKCONSTA
   \                     CLKCONSTA:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbe
   \   unsigned char volatile __sfr SLEEPCMD
   \                     SLEEPCMD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc6
   \   unsigned char volatile __sfr CLKCONCMD
   \                     CLKCONCMD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfe
   \   unsigned char volatile __sfr P1DIR
   \                     P1DIR:
   \   000000                DS 1
     49          #include "ZMAC.h"
     50          
     51          #ifndef NONWK
     52            #include "AF.h"
     53          #endif
     54          
     55          /* Hal */
     56          #include "hal_lcd.h"
     57          #include "hal_led.h"
     58          #include "hal_adc.h"
     59          #include "hal_drivers.h"
     60          #include "hal_assert.h"
     61          #include "hal_flash.h"
     62          
     63          /*********************************************************************
     64           * MACROS
     65           */
     66          
     67          /*********************************************************************
     68           * CONSTANTS
     69           */
     70          
     71          // Maximun number of Vdd samples checked before go on
     72          #define MAX_VDD_SAMPLES  3
     73          #define ZMAIN_VDD_LIMIT  HAL_ADC_VDD_LIMIT_4
     74          
     75          /*********************************************************************
     76           * TYPEDEFS
     77           */
     78          
     79          /*********************************************************************
     80           * GLOBAL VARIABLES
     81           */
     82          
     83          /*********************************************************************
     84           * EXTERNAL VARIABLES
     85           */
     86          
     87          /*********************************************************************
     88           * EXTERNAL FUNCTIONS
     89           */
     90          
     91          extern bool HalAdcCheckVdd (uint8 limit);
     92          
     93          /*********************************************************************
     94           * LOCAL VARIABLES
     95           */
     96          
     97          /*********************************************************************
     98           * LOCAL FUNCTIONS
     99           */
    100          
    101          static void zmain_dev_info( void );
    102          static void zmain_ext_addr( void );
    103          static void zmain_vdd_check( void );
    104          
    105          #ifdef LCD_SUPPORTED
    106          static void zmain_lcd_init( void );
    107          #endif
    108          
    109          /*********************************************************************
    110           * @fn      main
    111           * @brief   First function called after startup.
    112           * @return  don't care
    113           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    114          int main( void )
   \                     main:
    115          {
   \   000000                ; Auto size: 0
    116            // Turn off interrupts
    117            osal_int_disable( INTS_ALL );     //¹ØËùÓÐÖÐ¶Ï
   \   000000                ; Setup parameters for call to function osal_int_disable
   \   000000   79FF         MOV     R1,#-0x1
   \   000002   12....       LCALL   `??osal_int_disable::?relay`; Banked call to: osal_int_disable
    118          
    119            // Initialization for board related stuff such as LEDs
    120            HAL_BOARD_INIT();     //³õÊ¼»¯°åÔØÍâÉè  
   \   000005   53BEFB       ANL     0xbe,#0xfb
   \                     ??main_0:
   \   000008   E59D         MOV     A,0x9d
   \   00000A   A2E6         MOV     C,0xE0 /* A   */.6
   \   00000C   50FA         JNC     ??main_0
   \   00000E   00           NOP
   \   00000F   78F8         MOV     R0,#-0x8
   \   000011   7901         MOV     R1,#0x1
   \                     ??main_1:
   \   000013   00           NOP
   \   000014   E8           MOV     A,R0
   \   000015   24FF         ADD     A,#-0x1
   \   000017   18           DEC     R0
   \   000018   E9           MOV     A,R1
   \   000019   34FF         ADDC    A,#-0x1
   \   00001B   F9           MOV     R1,A
   \   00001C   E8           MOV     A,R0
   \   00001D   49           ORL     A,R1
   \   00001E   70F3         JNZ     ??main_1
   \   000020   75C600       MOV     0xc6,#0x0
   \                     ??main_2:
   \   000023   E59E         MOV     A,0x9e
   \   000025   70FC         JNZ     ??main_2
   \   000027   43BE04       ORL     0xbe,#0x4
   \   00002A   906270       MOV     DPTR,#0x6270
   \   00002D   7408         MOV     A,#0x8
   \   00002F   F0           MOVX    @DPTR,A
   \   000030   43FE80       ORL     0xfe,#0x80
   \   000033   43FE40       ORL     0xfe,#0x40
   \   000036   43FE10       ORL     0xfe,#0x10
   \   000039   438F01       ORL     0x8f,#0x1
    121          
    122            // Make sure supply voltage is high enough to run
    123            zmain_vdd_check();    //¼ì²éÐ¾Æ¬µçÑ¹ÊÇ·ñÕý³£
   \   00003C                ; Setup parameters for call to function zmain_vdd_check
   \   00003C   12....       LCALL   `??zmain_vdd_check::?relay`; Banked call to: zmain_vdd_check
    124          
    125            // Initialize board I/O
    126            InitBoard( OB_COLD );     //³õÊ¼»¯IO
   \   00003F                ; Setup parameters for call to function InitBoard
   \   00003F   7900         MOV     R1,#0x0
   \   000041   12....       LCALL   `??InitBoard::?relay`; Banked call to: InitBoard
    127          
    128            // Initialze HAL drivers
    129            HalDriverInit();    //³õÊ¼»¯¸÷Ó²¼þÇý¶¯
   \   000044                ; Setup parameters for call to function HalDriverInit
   \   000044   12....       LCALL   `??HalDriverInit::?relay`; Banked call to: HalDriverInit
    130          
    131            // Initialize NV System
    132            osal_nv_init( NULL );     //³õÊ¼»¯Flash´æ´¢Æ÷
   \   000047                ; Setup parameters for call to function osal_nv_init
   \   000047   7A00         MOV     R2,#0x0
   \   000049   7B00         MOV     R3,#0x0
   \   00004B   12....       LCALL   `??osal_nv_init::?relay`; Banked call to: osal_nv_init
    133          
    134            // Initialize the MAC
    135            ZMacInit();   //³õÊ¼»¯MAC ²ã
   \   00004E                ; Setup parameters for call to function ZMacInit
   \   00004E   12....       LCALL   `??ZMacInit::?relay` ; Banked call to: ZMacInit
    136          
    137            // Determine the extended address
    138            zmain_ext_addr();     //È·¶¨IEEE 64Î»µØÖ·
   \   000051                ; Setup parameters for call to function zmain_ext_addr
   \   000051   12....       LCALL   `??zmain_ext_addr::?relay`; Banked call to: zmain_ext_addr
    139          
    140            // Initialize basic NV items
    141            zgInit();     // ³õÊ¼»¯·ÇÒ×Ê§±äÁ¿
   \   000054                ; Setup parameters for call to function zgInit
   \   000054   12....       LCALL   `??zgInit::?relay`   ; Banked call to: zgInit
    142          
    143          #ifndef NONWK
    144            // Since the AF isn't a task, call it's initialization routine
    145            afInit();
   \   000057                ; Setup parameters for call to function afInit
   \   000057   12....       LCALL   `??afInit::?relay`   ; Banked call to: afInit
    146          #endif
    147          
    148            // Initialize the operating system
    149            osal_init_system();   // ³õÊ¼»¯²Ù×÷ÏµÍ³       
   \   00005A                ; Setup parameters for call to function osal_init_system
   \   00005A   12....       LCALL   `??osal_init_system::?relay`; Banked call to: osal_init_system
    150          
    151            // Allow interrupts
    152            osal_int_enable( INTS_ALL );  //´ò¿ªËùÓÐÖÐ¶Ï
   \   00005D                ; Setup parameters for call to function osal_int_enable
   \   00005D   79FF         MOV     R1,#-0x1
   \   00005F   12....       LCALL   `??osal_int_enable::?relay`; Banked call to: osal_int_enable
    153          
    154            // Final board initialization
    155            InitBoard( OB_READY );    //³õÊ¼»¯°åÔØÍâÉè
   \   000062                ; Setup parameters for call to function InitBoard
   \   000062   7902         MOV     R1,#0x2
   \   000064   12....       LCALL   `??InitBoard::?relay`; Banked call to: InitBoard
    156          
    157            // Display information about this device
    158            zmain_dev_info();     //ÏÔÊ¾Ïà¹ØÐÅÏ¢
    159          
    160            /* Display the device info on the LCD */
    161          #ifdef LCD_SUPPORTED
    162            zmain_lcd_init();
    163          #endif
    164          
    165          #ifdef WDT_IN_PM1
    166            /* If WDT is used, this is a good place to enable it. */
    167            WatchDogEnable( WDTIMX );
    168          #endif
    169            // No Return from here
    170            osal_start_system();  //Ö´ÐÐ²Ù×÷ÏµÍ³£¬½øÈ¥ºó²»»á·µ»Ø
   \   000067                ; Setup parameters for call to function osal_start_system
   \   000067   12....       LCALL   `??osal_start_system::?relay`; Banked call to: osal_start_system
    171          
    172            return 0;  // Shouldn't get here.
   \   00006A   7A00         MOV     R2,#0x0
   \   00006C   7B00         MOV     R3,#0x0
   \   00006E   02....       LJMP    ?BRET
   \   000071                REQUIRE SLEEPCMD
   \   000071                REQUIRE SLEEPSTA
   \   000071                REQUIRE CLKCONCMD
   \   000071                REQUIRE CLKCONSTA
   \   000071                REQUIRE P1DIR
   \   000071                REQUIRE P0INP
    173          } // main()
    174          
    175          /*********************************************************************
    176           * @fn      zmain_vdd_check
    177           * @brief   Check if the Vdd is OK to run the processor.
    178           * @return  Return if Vdd is ok; otherwise, flash LED, then reset
    179           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    180          static void zmain_vdd_check( void )
   \                     zmain_vdd_check:
    181          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    182            uint8 vdd_passed_count = 0;
   \   000005   7E00         MOV     R6,#0x0
    183            bool toggle = 0;
   \   000007   7F00         MOV     R7,#0x0
   \   000009   8002         SJMP    ??zmain_vdd_check_0
    184          
    185            // Repeat getting the sample until number of failures or successes hits MAX
    186            // then based on the count value, determine if the device is ready or not
    187            while ( vdd_passed_count < MAX_VDD_SAMPLES )
    188            {
    189              if ( HalAdcCheckVdd (ZMAIN_VDD_LIMIT) )
    190              {
    191                vdd_passed_count++;    // Keep track # times Vdd passes in a row
    192                MicroWait (10000);     // Wait 10ms to try again
    193              }
    194              else
    195              {
    196                vdd_passed_count = 0;  // Reset passed counter
    197                MicroWait (50000);     // Wait 50ms
    198                MicroWait (50000);     // Wait another 50ms to try again
    199              }
    200          
    201              /* toggle LED1 and LED2 */
    202              if (vdd_passed_count == 0)
    203              {
    204                if ((toggle = !(toggle)))
    205                  HAL_TOGGLE_LED1();
   \                     ??zmain_vdd_check_1:
   \   00000B   C297         CLR     0x90.7
   \                     ??zmain_vdd_check_0:
   \   00000D                ; Setup parameters for call to function HalAdcCheckVdd
   \   00000D   7904         MOV     R1,#0x4
   \   00000F   12....       LCALL   `??HalAdcCheckVdd::?relay`; Banked call to: HalAdcCheckVdd
   \   000012   E9           MOV     A,R1
   \   000013   6019         JZ      ??zmain_vdd_check_2
   \   000015   0E           INC     R6
   \   000016                ; Setup parameters for call to function Onboard_wait
   \   000016   7A10         MOV     R2,#0x10
   \   000018   7B27         MOV     R3,#0x27
   \   00001A   12....       LCALL   `??Onboard_wait::?relay`; Banked call to: Onboard_wait
   \   00001D   EE           MOV     A,R6
   \   00001E   601E         JZ      ??zmain_vdd_check_3
   \   000020   C3           CLR     C
   \   000021   9403         SUBB    A,#0x3
   \   000023   40E8         JC      ??zmain_vdd_check_0
    206                else
    207                  HAL_TOGGLE_LED2();
    208              }
    209            }
    210          
    211            /* turn off LED1 */
    212            HAL_TURN_OFF_LED1();
   \   000025   C297         CLR     0x90.7
    213            HAL_TURN_OFF_LED2();
   \   000027   C296         CLR     0x90.6
    214          }
   \   000029   7F01         MOV     R7,#0x1
   \   00002B   02....       LJMP    ?BANKED_LEAVE_XDATA
   \                     ??zmain_vdd_check_2:
   \   00002E   7E00         MOV     R6,#0x0
   \   000030                ; Setup parameters for call to function Onboard_wait
   \   000030   7A50         MOV     R2,#0x50
   \   000032   7BC3         MOV     R3,#-0x3d
   \   000034   12....       LCALL   `??Onboard_wait::?relay`; Banked call to: Onboard_wait
   \   000037                ; Setup parameters for call to function Onboard_wait
   \   000037   7A50         MOV     R2,#0x50
   \   000039   7BC3         MOV     R3,#-0x3d
   \   00003B   12....       LCALL   `??Onboard_wait::?relay`; Banked call to: Onboard_wait
   \                     ??zmain_vdd_check_3:
   \   00003E   EF           MOV     A,R7
   \   00003F   A2E0         MOV     C,0xE0 /* A   */.0
   \   000041   B3           CPL     C
   \   000042   E4           CLR     A
   \   000043   33           RLC     A
   \   000044   FF           MOV     R7,A
   \   000045   A2E0         MOV     C,0xE0 /* A   */.0
   \   000047   5008         JNC     ??zmain_vdd_check_4
   \   000049   A297         MOV     C,0x90.7
   \   00004B   40BE         JC      ??zmain_vdd_check_1
   \   00004D   D297         SETB    0x90.7
   \   00004F   80BC         SJMP    ??zmain_vdd_check_0
   \                     ??zmain_vdd_check_4:
   \   000051   A296         MOV     C,0x90.6
   \   000053   5004         JNC     ??zmain_vdd_check_5
   \   000055   C296         CLR     0x90.6
   \   000057   80B4         SJMP    ??zmain_vdd_check_0
   \                     ??zmain_vdd_check_5:
   \   000059   D296         SETB    0x90.6
   \   00005B   80B0         SJMP    ??zmain_vdd_check_0
   \   00005D                REQUIRE _A_P1
    215          
    216          /**************************************************************************************************
    217           * @fn          zmain_ext_addr
    218           *
    219           * @brief       Execute a prioritized search for a valid extended address and write the results
    220           *              into the OSAL NV system for use by the system. Temporary address not saved to NV.
    221           *
    222           * input parameters
    223           *
    224           * None.
    225           *
    226           * output parameters
    227           *
    228           * None.
    229           *
    230           * @return      None.
    231           **************************************************************************************************
    232           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    233          static void zmain_ext_addr(void)
   \                     zmain_ext_addr:
    234          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 11
   \   000005   74F5         MOV     A,#-0xb
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    235            uint8 nullAddr[Z_EXTADDR_LEN] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
   \   00000A   90....       MOV     DPTR,#`?<Constant {255, 255, 255, 255, 255, 255, 255,`
   \   00000D   7403         MOV     A,#0x3
   \   00000F   12....       LCALL   ?XSTACK_DISP102_8
   \   000012   7408         MOV     A,#0x8
   \   000014   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    236            uint8 writeNV = TRUE;
    237          
    238            // First check whether a non-erased extended address exists in the OSAL NV.
    239            if ((SUCCESS != osal_nv_item_init(ZCD_NV_EXTADDR, Z_EXTADDR_LEN, NULL))  ||
    240                (SUCCESS != osal_nv_read(ZCD_NV_EXTADDR, 0, Z_EXTADDR_LEN, aExtendedAddress)) ||
    241                (osal_memcmp(aExtendedAddress, nullAddr, Z_EXTADDR_LEN)))
   \   000017   85..82       MOV     DPL,?XSP + 0
   \   00001A   85..83       MOV     DPH,?XSP + 1
   \   00001D   74..         MOV     A,#aExtendedAddress & 0xff
   \   00001F   F0           MOVX    @DPTR,A
   \   000020   A3           INC     DPTR
   \   000021   74..         MOV     A,#(aExtendedAddress >> 8) & 0xff
   \   000023   F0           MOVX    @DPTR,A
   \   000024   A3           INC     DPTR
   \   000025   E4           CLR     A
   \   000026   F0           MOVX    @DPTR,A
   \   000027   7403         MOV     A,#0x3
   \   000029   12....       LCALL   ?XSTACK_DISP100_8
   \   00002C   88..         MOV     ?V0,R0
   \   00002E   89..         MOV     ?V1,R1
   \   000030   75..00       MOV     ?V2,#0x0
   \   000033                ; Setup parameters for call to function osal_nv_item_init
   \   000033   E4           CLR     A
   \   000034   F5..         MOV     ?V4,A
   \   000036   F5..         MOV     ?V5,A
   \   000038   78..         MOV     R0,#?V4
   \   00003A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003D   7C08         MOV     R4,#0x8
   \   00003F   7D00         MOV     R5,#0x0
   \   000041   7A01         MOV     R2,#0x1
   \   000043   7B00         MOV     R3,#0x0
   \   000045   12....       LCALL   `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   000048   7402         MOV     A,#0x2
   \   00004A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00004D   E9           MOV     A,R1
   \   00004E   7048         JNZ     ??zmain_ext_addr_0
   \   000050                ; Setup parameters for call to function osal_nv_read
   \   000050   75....       MOV     ?V4,#aExtendedAddress & 0xff
   \   000053   75....       MOV     ?V5,#(aExtendedAddress >> 8) & 0xff
   \   000056   78..         MOV     R0,#?V4
   \   000058   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005B   75..08       MOV     ?V4,#0x8
   \   00005E   75..00       MOV     ?V5,#0x0
   \   000061   78..         MOV     R0,#?V4
   \   000063   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000066   7C00         MOV     R4,#0x0
   \   000068   7D00         MOV     R5,#0x0
   \   00006A   7A01         MOV     R2,#0x1
   \   00006C   7B00         MOV     R3,#0x0
   \   00006E   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000071   7404         MOV     A,#0x4
   \   000073   12....       LCALL   ?DEALLOC_XSTACK8
   \   000076   E9           MOV     A,R1
   \   000077   701F         JNZ     ??zmain_ext_addr_0
   \   000079                ; Setup parameters for call to function osal_memcmp
   \   000079   78..         MOV     R0,#?V0
   \   00007B   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00007E   7C08         MOV     R4,#0x8
   \   000080   7D00         MOV     R5,#0x0
   \   000082   7403         MOV     A,#0x3
   \   000084   12....       LCALL   ?XSTACK_DISP0_8
   \   000087   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   00008A   12....       LCALL   `??osal_memcmp::?relay`; Banked call to: osal_memcmp
   \   00008D   7403         MOV     A,#0x3
   \   00008F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000092   E9           MOV     A,R1
   \   000093   7003         JNZ     $+5
   \   000095   02....       LJMP    ??zmain_ext_addr_1 & 0xFFFF
    242            {
    243              // Attempt to read the extended address from the location on the lock bits page
    244              // where the programming tools know to reserve it.
    245              HalFlashRead(HAL_FLASH_IEEE_PAGE, HAL_FLASH_IEEE_OSET, aExtendedAddress, Z_EXTADDR_LEN);
   \                     ??zmain_ext_addr_0:
   \   000098                ; Setup parameters for call to function HalFlashRead
   \   000098   75..08       MOV     ?V4,#0x8
   \   00009B   78..         MOV     R0,#?V4
   \   00009D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A0   7C..         MOV     R4,#aExtendedAddress & 0xff
   \   0000A2   7D..         MOV     R5,#(aExtendedAddress >> 8) & 0xff
   \   0000A4   7AE8         MOV     R2,#-0x18
   \   0000A6   7B07         MOV     R3,#0x7
   \   0000A8   797F         MOV     R1,#0x7f
   \   0000AA   12....       LCALL   `??HalFlashRead::?relay`; Banked call to: HalFlashRead
   \   0000AD   7402         MOV     A,#0x2
   \   0000AF   12....       LCALL   ?DEALLOC_XSTACK8
    246          
    247              if (osal_memcmp(aExtendedAddress, nullAddr, Z_EXTADDR_LEN))
   \   0000B2                ; Setup parameters for call to function osal_memcmp
   \   0000B2   78..         MOV     R0,#?V0
   \   0000B4   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000B7   7C08         MOV     R4,#0x8
   \   0000B9   7D00         MOV     R5,#0x0
   \   0000BB   7403         MOV     A,#0x3
   \   0000BD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C0   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   0000C3   12....       LCALL   `??osal_memcmp::?relay`; Banked call to: osal_memcmp
   \   0000C6   7403         MOV     A,#0x3
   \   0000C8   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000CB   E9           MOV     A,R1
   \   0000CC   6071         JZ      ??zmain_ext_addr_2
    248              {
    249                // Attempt to read the extended address from the designated location in the Info Page.
    250                if (!osal_memcmp((uint8 *)(P_INFOPAGE+HAL_INFOP_IEEE_OSET), nullAddr, Z_EXTADDR_LEN))
   \   0000CE                ; Setup parameters for call to function osal_memcmp
   \   0000CE   78..         MOV     R0,#?V0
   \   0000D0   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000D3   7C08         MOV     R4,#0x8
   \   0000D5   7D00         MOV     R5,#0x0
   \   0000D7   790C         MOV     R1,#0xc
   \   0000D9   7A78         MOV     R2,#0x78
   \   0000DB   7B00         MOV     R3,#0x0
   \   0000DD   12....       LCALL   `??osal_memcmp::?relay`; Banked call to: osal_memcmp
   \   0000E0   7403         MOV     A,#0x3
   \   0000E2   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E5   E9           MOV     A,R1
   \   0000E6   701D         JNZ     ??zmain_ext_addr_3
    251                {
    252                  osal_memcpy(aExtendedAddress, (uint8 *)(P_INFOPAGE+HAL_INFOP_IEEE_OSET), Z_EXTADDR_LEN);
   \   0000E8                ; Setup parameters for call to function osal_memcpy
   \   0000E8   75..0C       MOV     ?V0,#0xc
   \   0000EB   75..78       MOV     ?V1,#0x78
   \   0000EE   78..         MOV     R0,#?V0
   \   0000F0   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000F3   7C08         MOV     R4,#0x8
   \   0000F5   7D00         MOV     R5,#0x0
   \   0000F7   7A..         MOV     R2,#aExtendedAddress & 0xff
   \   0000F9   7B..         MOV     R3,#(aExtendedAddress >> 8) & 0xff
   \   0000FB   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   0000FE   7403         MOV     A,#0x3
   \   000100   12....       LCALL   ?DEALLOC_XSTACK8
   \   000103   803A         SJMP    ??zmain_ext_addr_2
    253                }
    254                else  // No valid extended address was found.
    255                {
    256                  uint8 idx;
    257                  
    258          #if !defined ( NV_RESTORE )
    259                  writeNV = FALSE;  // Make this a temporary IEEE address
    260          #endif
    261          
    262                  /* Attempt to create a sufficiently random extended address for expediency.
    263                   * Note: this is only valid/legal in a test environment and
    264                   *       must never be used for a commercial product.
    265                   */
    266                  for (idx = 0; idx < (Z_EXTADDR_LEN - 2);)
   \                     ??zmain_ext_addr_3:
   \   000105   7E00         MOV     R6,#0x0
    267                  {
    268                    uint16 randy = osal_rand();
   \                     ??zmain_ext_addr_4:
   \   000107                ; Setup parameters for call to function osal_rand
   \   000107   12....       LCALL   `??osal_rand::?relay`; Banked call to: osal_rand
   \   00010A   8A..         MOV     ?V0,R2
    269                    aExtendedAddress[idx++] = LO_UINT16(randy);
   \   00010C   EE           MOV     A,R6
   \   00010D   FA           MOV     R2,A
   \   00010E   74..         MOV     A,#aExtendedAddress & 0xff
   \   000110   2A           ADD     A,R2
   \   000111   F582         MOV     DPL,A
   \   000113   E4           CLR     A
   \   000114   34..         ADDC    A,#(aExtendedAddress >> 8) & 0xff
   \   000116   F583         MOV     DPH,A
   \   000118   E5..         MOV     A,?V0
   \   00011A   F0           MOVX    @DPTR,A
   \   00011B   0E           INC     R6
    270                    aExtendedAddress[idx++] = HI_UINT16(randy);
   \   00011C   EE           MOV     A,R6
   \   00011D   F8           MOV     R0,A
   \   00011E   12....       LCALL   ?Subroutine1 & 0xFFFF
    271                  }
   \                     ??CrossCallReturnLabel_2:
   \   000121   EB           MOV     A,R3
   \   000122   F0           MOVX    @DPTR,A
   \   000123   0E           INC     R6
   \   000124   EE           MOV     A,R6
   \   000125   C3           CLR     C
   \   000126   9406         SUBB    A,#0x6
   \   000128   40DD         JC      ??zmain_ext_addr_4
    272                  // Next-to-MSB identifies ZigBee devicetype.
    273          #if ZG_BUILD_COORDINATOR_TYPE && !ZG_BUILD_JOINING_TYPE
    274                  aExtendedAddress[idx++] = 0x10;
   \   00012A   08           INC     R0
   \   00012B   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   00012E   7410         MOV     A,#0x10
   \   000130   F0           MOVX    @DPTR,A
    275          #elif ZG_BUILD_RTRONLY_TYPE
    276                  aExtendedAddress[idx++] = 0x20;
    277          #else
    278                  aExtendedAddress[idx++] = 0x30;
    279          #endif
    280                  // MSB has historical signficance.
    281                  aExtendedAddress[idx] = 0xF8;
   \   000131   08           INC     R0
   \   000132   74..         MOV     A,#aExtendedAddress & 0xff
   \   000134   28           ADD     A,R0
   \   000135   F582         MOV     DPL,A
   \   000137   E4           CLR     A
   \   000138   34..         ADDC    A,#(aExtendedAddress >> 8) & 0xff
   \   00013A   F583         MOV     DPH,A
   \   00013C   74F8         MOV     A,#-0x8
   \   00013E   F0           MOVX    @DPTR,A
    282                }
    283              }
    284          
    285              if (writeNV)
    286              {
    287                (void)osal_nv_write(ZCD_NV_EXTADDR, 0, Z_EXTADDR_LEN, aExtendedAddress);
   \                     ??zmain_ext_addr_2:
   \   00013F                ; Setup parameters for call to function osal_nv_write
   \   00013F   75....       MOV     ?V0,#aExtendedAddress & 0xff
   \   000142   75....       MOV     ?V1,#(aExtendedAddress >> 8) & 0xff
   \   000145   78..         MOV     R0,#?V0
   \   000147   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00014A   75..08       MOV     ?V0,#0x8
   \   00014D   75..00       MOV     ?V1,#0x0
   \   000150   78..         MOV     R0,#?V0
   \   000152   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000155   7C00         MOV     R4,#0x0
   \   000157   7D00         MOV     R5,#0x0
   \   000159   7A01         MOV     R2,#0x1
   \   00015B   7B00         MOV     R3,#0x0
   \   00015D   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000160   7404         MOV     A,#0x4
   \   000162   12....       LCALL   ?DEALLOC_XSTACK8
    288              }
    289            }
    290          
    291            // Set the MAC PIB extended address according to results from above.
    292            (void)ZMacSetReq(MAC_EXTENDED_ADDRESS, aExtendedAddress);
   \                     ??zmain_ext_addr_1:
   \   000165                ; Setup parameters for call to function ZMacSetReq
   \   000165   7A..         MOV     R2,#aExtendedAddress & 0xff
   \   000167   7B..         MOV     R3,#(aExtendedAddress >> 8) & 0xff
   \   000169   79E2         MOV     R1,#-0x1e
   \   00016B   12....       LCALL   `??ZMacSetReq::?relay`; Banked call to: ZMacSetReq
    293          }
   \   00016E   740B         MOV     A,#0xb
   \   000170   12....       LCALL   ?DEALLOC_XSTACK8
   \   000173   7F06         MOV     R7,#0x6
   \   000175   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   74..         MOV     A,#aExtendedAddress & 0xff
   \   000002   2E           ADD     A,R6
   \   000003   F582         MOV     DPL,A
   \   000005   E4           CLR     A
   \   000006   34..         ADDC    A,#(aExtendedAddress >> 8) & 0xff
   \   000008   F583         MOV     DPH,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F9           MOV     R1,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FA           MOV     R2,A
   \   000005   A3           INC     DPTR
   \   000006   E0           MOVX    A,@DPTR
   \   000007   FB           MOV     R3,A
   \   000008   22           RET

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??main::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    main

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zmain_vdd_check::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zmain_vdd_check

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zmain_ext_addr::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zmain_ext_addr

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {255, 255, 255, 255, 255, 255, 255,`:
   \   000000   FF           DB 255
   \   000001   FF           DB 255
   \   000002   FF           DB 255
   \   000003   FF           DB 255
   \   000004   FF           DB 255
   \   000005   FF           DB 255
   \   000006   FF           DB 255
   \   000007   FF           DB 255
    294          
    295          /**************************************************************************************************
    296           * @fn          zmain_dev_info
    297           *
    298           * @brief       This displays the IEEE (MSB to LSB) on the LCD.
    299           *
    300           * input parameters
    301           *
    302           * None.
    303           *
    304           * output parameters
    305           *
    306           * None.
    307           *
    308           * @return      None.
    309           **************************************************************************************************
    310           */
    311          static void zmain_dev_info(void)
    312          {
    313          #ifdef LCD_SUPPORTED
    314            uint8 i;
    315            uint8 *xad;
    316            uint8 lcd_buf[Z_EXTADDR_LEN*2+1];
    317          
    318            // Display the extended address.
    319            xad = aExtendedAddress + Z_EXTADDR_LEN - 1;
    320          
    321            for (i = 0; i < Z_EXTADDR_LEN*2; xad--)
    322            {
    323              uint8 ch;
    324              ch = (*xad >> 4) & 0x0F;
    325              lcd_buf[i++] = ch + (( ch < 10 ) ? '0' : '7');
    326              ch = *xad & 0x0F;
    327              lcd_buf[i++] = ch + (( ch < 10 ) ? '0' : '7');
    328            }
    329            lcd_buf[Z_EXTADDR_LEN*2] = '\0';
    330            HalLcdWriteString( "IEEE: ", HAL_LCD_LINE_1 );
    331            HalLcdWriteString( (char*)lcd_buf, HAL_LCD_LINE_2 );
    332          #endif
    333          }
    334          
    335          #ifdef LCD_SUPPORTED
    336          /*********************************************************************
    337           * @fn      zmain_lcd_init
    338           * @brief   Initialize LCD at start up.
    339           * @return  none
    340           *********************************************************************/
    341          static void zmain_lcd_init ( void )
    342          {
    343          #ifdef SERIAL_DEBUG_SUPPORTED
    344            {
    345              HalLcdWriteString( "TexasInstruments", HAL_LCD_LINE_1 );
    346          
    347          #if defined( MT_MAC_FUNC )
    348          #if defined( ZDO_COORDINATOR )
    349                HalLcdWriteString( "MAC-MT Coord", HAL_LCD_LINE_2 );
    350          #else
    351                HalLcdWriteString( "MAC-MT Device", HAL_LCD_LINE_2 );
    352          #endif // ZDO
    353          #elif defined( MT_NWK_FUNC )
    354          #if defined( ZDO_COORDINATOR )
    355                HalLcdWriteString( "NWK Coordinator", HAL_LCD_LINE_2 );
    356          #else
    357                HalLcdWriteString( "NWK Device", HAL_LCD_LINE_2 );
    358          #endif // ZDO
    359          #endif // MT_FUNC
    360            }
    361          #endif // SERIAL_DEBUG_SUPPORTED
    362          }
    363          #endif
    364          
    365          /*********************************************************************
    366          *********************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      0      0   main
        0      0   -> HalDriverInit
        0      0   -> InitBoard
        0      0   -> ZMacInit
        0      0   -> afInit
        0      0   -> osal_init_system
        0      0   -> osal_int_disable
        0      0   -> osal_int_enable
        0      0   -> osal_nv_init
        0      0   -> osal_start_system
        0      0   -> zgInit
        0      0   -> zmain_ext_addr
        0      0   -> zmain_vdd_check
      1     29   zmain_ext_addr
        0     27   -> HalFlashRead
        0     25   -> ZMacSetReq
        0     28   -> osal_memcmp
        0     28   -> osal_memcpy
        0     27   -> osal_nv_item_init
        0     29   -> osal_nv_read
        0     29   -> osal_nv_write
        0     25   -> osal_rand
      0      9   zmain_vdd_check
        0      9   -> HalAdcCheckVdd
        0      9   -> Onboard_wait


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Constant {255, 255, 255, 255, 255, 255, 255,
       9  ?Subroutine0
      11  ?Subroutine1
       1  CLKCONCMD
       1  CLKCONSTA
       1  P0INP
       1  P1DIR
       1  SLEEPCMD
       1  SLEEPSTA
       1  _A_P1
     113  main
       6  main::?relay
     376  zmain_ext_addr
       6  zmain_ext_addr::?relay
      93  zmain_vdd_check
       6  zmain_vdd_check::?relay

 
 602 bytes in segment BANKED_CODE
  18 bytes in segment BANK_RELAYS
   7 bytes in segment SFR_AN
   8 bytes in segment XDATA_ROM_C
 
 620 bytes of CODE  memory
   8 bytes of CONST memory
   0 bytes of DATA  memory (+ 7 bytes shared)

Errors: none
Warnings: none
