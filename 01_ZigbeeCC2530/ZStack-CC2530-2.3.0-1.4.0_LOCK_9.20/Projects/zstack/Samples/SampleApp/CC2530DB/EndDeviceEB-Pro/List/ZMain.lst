###############################################################################
#
# IAR C/C++ Compiler V9.20.1.2476 for 8051                26/May/2017  16:13:47
# Copyright 2004-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\ZMain\TI2530DB\ZMain.c
#    Command line       =  
#        -f
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DBLINK_LEDS) -f
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg
#        (-DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_POLLED=3000
#        -DNWK_INDIRECT_MSG_TIMEOUT=7 -DMAX_RREQ_ENTRIES=8
#        -DAPSC_MAX_FRAME_RETRIES=3 -DNWK_MAX_DATA_RETRIES=2
#        -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9 -DAPS_MAX_GROUPS=16
#        -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"
#        -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000
#        -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)
#        -DREJOIN_POLL_RATE=440
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\ZMain\TI2530DB\ZMain.c
#        -D ZIGBEEPRO -D NWK_AUTO_POLL -D ZTOOL_P1 -D MT_TASK -D MT_SYS_FUNC -D
#        MT_ZDO_FUNC -D LCD_SUPPORTED=DEBUG -lC
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\EndDeviceEB-Pro\List\
#        -lA
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\EndDeviceEB-Pro\List\
#        --diag_suppress Pe001,Pa010 -o
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\EndDeviceEB-Pro\Obj\
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 8 -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\SOURCE\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\ZMAIN\TI2530DB\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MT\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\INCLUDE\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\TARGET\CC2530EB\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\MCU\CCSOC\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\INCLUDE\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\AF\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\NWK\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SEC\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SAPI\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SYS\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\ZDO\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\F8W\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES\SADDR\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES\SDATA\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\INCLUDE\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\HIGH_LEVEL\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\SINGLE_CHIP\
#        -Ohz --require_prototypes
#    List file          =  
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\EndDeviceEB-Pro\List\ZMain.lst
#    Object file        =  
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\EndDeviceEB-Pro\Obj\ZMain.r51
#
###############################################################################

D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\ZMain\TI2530DB\ZMain.c
      1          /**************************************************************************************************
      2            Filename:       ZMain.c
      3            Revised:        $Date: 2009-09-17 20:35:33 -0700 (Thu, 17 Sep 2009) $
      4            Revision:       $Revision: 20782 $
      5          
      6            Description:    Startup and shutdown code for ZStack
      7            Notes:          This version targets the Chipcon CC2530
      8          
      9          
     10            Copyright 2005-2009 Texas Instruments Incorporated. All rights reserved.
     11          
     12            IMPORTANT: Your use of this Software is limited to those specific rights
     13            granted under the terms of a software license agreement between the user
     14            who downloaded the software, his/her employer (which must be your employer)
     15            and Texas Instruments Incorporated (the "License").  You may not use this
     16            Software unless you agree to abide by the terms of the License. The License
     17            limits your use, and you acknowledge, that the Software may not be modified,
     18            copied or distributed unless embedded on a Texas Instruments microcontroller
     19            or used solely and exclusively in conjunction with a Texas Instruments radio
     20            frequency transceiver, which is integrated into your product.  Other than for
     21            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     22            works of, modify, distribute, perform, display or sell this Software and/or
     23            its documentation for any purpose.
     24          
     25            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     26            PROVIDED AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     27            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     28            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     29            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     30            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     31            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     32            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     33            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     34            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     35            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     36          
     37            Should you have any questions regarding your right to use this Software,
     38            contact Texas Instruments Incorporated at www.TI.com.
     39          **************************************************************************************************/
     40          
     41          /*********************************************************************
     42           * INCLUDES
     43           */
     44          
     45          #include "ZComDef.h"
     46          #include "OSAL.h"
     47          #include "OSAL_Nv.h"
     48          #include "OnBoard.h"

   \                                 In  segment SFR_AN, at 0x8f
   \   unsigned char volatile __sfr P0INP
   \                     P0INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x90
   \   union <unnamed> volatile __sfr _A_P1
   \                     _A_P1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9d
   \   unsigned char volatile __sfr SLEEPSTA
   \                     SLEEPSTA:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9e
   \   unsigned char volatile __sfr CLKCONSTA
   \                     CLKCONSTA:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbe
   \   unsigned char volatile __sfr SLEEPCMD
   \                     SLEEPCMD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc6
   \   unsigned char volatile __sfr CLKCONCMD
   \                     CLKCONCMD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfe
   \   unsigned char volatile __sfr P1DIR
   \                     P1DIR:
   \   000000                DS 1
     49          #include "ZMAC.h"
     50          
     51          #ifndef NONWK
     52            #include "AF.h"
     53          #endif
     54          
     55          /* Hal */
     56          #include "hal_lcd.h"
     57          #include "hal_led.h"
     58          #include "hal_adc.h"
     59          #include "hal_drivers.h"
     60          #include "hal_assert.h"
     61          #include "hal_flash.h"
     62          
     63          /*********************************************************************
     64           * MACROS
     65           */
     66          
     67          /*********************************************************************
     68           * CONSTANTS
     69           */
     70          
     71          // Maximun number of Vdd samples checked before go on
     72          #define MAX_VDD_SAMPLES  3
     73          #define ZMAIN_VDD_LIMIT  HAL_ADC_VDD_LIMIT_4
     74          
     75          /*********************************************************************
     76           * TYPEDEFS
     77           */
     78          
     79          /*********************************************************************
     80           * GLOBAL VARIABLES
     81           */
     82          
     83          /*********************************************************************
     84           * EXTERNAL VARIABLES
     85           */
     86          
     87          /*********************************************************************
     88           * EXTERNAL FUNCTIONS
     89           */
     90          
     91          extern bool HalAdcCheckVdd (uint8 limit);
     92          
     93          /*********************************************************************
     94           * LOCAL VARIABLES
     95           */
     96          
     97          /*********************************************************************
     98           * LOCAL FUNCTIONS
     99           */
    100          
    101          static void zmain_dev_info( void );
    102          static void zmain_ext_addr( void );
    103          static void zmain_vdd_check( void );
    104          
    105          #ifdef LCD_SUPPORTED
    106          static void zmain_lcd_init( void );
    107          #endif
    108          
    109          /*********************************************************************
    110           * @fn      main
    111           * @brief   First function called after startup.
    112           * @return  don't care
    113           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    114          int main( void )
   \                     main:
    115          {
   \   000000                ; Auto size: 17
   \   000000   74EF         MOV     A,#-0x11
   \   000002   12....       LCALL   ?ALLOC_XSTACK8
    116            // Turn off interrupts
    117            osal_int_disable( INTS_ALL );     //关所有中断
   \   000005                ; Setup parameters for call to function osal_int_disable
   \   000005   79FF         MOV     R1,#-0x1
   \   000007   12....       LCALL   `??osal_int_disable::?relay`; Banked call to: osal_int_disable
    118          
    119            // Initialization for board related stuff such as LEDs
    120            HAL_BOARD_INIT();     //初始化板载外设  
   \   00000A   53BEFB       ANL     0xbe,#0xfb
   \                     ??main_0:
   \   00000D   E59D         MOV     A,0x9d
   \   00000F   A2E6         MOV     C,0xE0 /* A   */.6
   \   000011   50FA         JNC     ??main_0
   \   000013   00           NOP
   \   000014   78F8         MOV     R0,#-0x8
   \   000016   7901         MOV     R1,#0x1
   \                     ??main_1:
   \   000018   00           NOP
   \   000019   E8           MOV     A,R0
   \   00001A   24FF         ADD     A,#-0x1
   \   00001C   18           DEC     R0
   \   00001D   E9           MOV     A,R1
   \   00001E   34FF         ADDC    A,#-0x1
   \   000020   F9           MOV     R1,A
   \   000021   E8           MOV     A,R0
   \   000022   49           ORL     A,R1
   \   000023   70F3         JNZ     ??main_1
   \   000025   75C600       MOV     0xc6,#0x0
   \                     ??main_2:
   \   000028   E59E         MOV     A,0x9e
   \   00002A   70FC         JNZ     ??main_2
   \   00002C   43BE04       ORL     0xbe,#0x4
   \   00002F   906270       MOV     DPTR,#0x6270
   \   000032   7408         MOV     A,#0x8
   \   000034   F0           MOVX    @DPTR,A
   \   000035   43FE80       ORL     0xfe,#0x80
   \   000038   43FE40       ORL     0xfe,#0x40
   \   00003B   43FE10       ORL     0xfe,#0x10
   \   00003E   438F01       ORL     0x8f,#0x1
    121          
    122            // Make sure supply voltage is high enough to run
    123            zmain_vdd_check();    //检查芯片电压是否正常
   \   000041                ; Setup parameters for call to function zmain_vdd_check
   \   000041   12....       LCALL   `??zmain_vdd_check::?relay`; Banked call to: zmain_vdd_check
    124          
    125            // Initialize board I/O
    126            InitBoard( OB_COLD );     //初始化IO
   \   000044                ; Setup parameters for call to function InitBoard
   \   000044   7900         MOV     R1,#0x0
   \   000046   12....       LCALL   `??InitBoard::?relay`; Banked call to: InitBoard
    127          
    128            // Initialze HAL drivers
    129            HalDriverInit();    //初始化各硬件驱动
   \   000049                ; Setup parameters for call to function HalDriverInit
   \   000049   12....       LCALL   `??HalDriverInit::?relay`; Banked call to: HalDriverInit
    130          
    131            // Initialize NV System
    132            osal_nv_init( NULL );     //初始化Flash存储器
   \   00004C                ; Setup parameters for call to function osal_nv_init
   \   00004C   7A00         MOV     R2,#0x0
   \   00004E   7B00         MOV     R3,#0x0
   \   000050   12....       LCALL   `??osal_nv_init::?relay`; Banked call to: osal_nv_init
    133          
    134            // Initialize the MAC
    135            ZMacInit();   //初始化MAC 层
   \   000053                ; Setup parameters for call to function ZMacInit
   \   000053   12....       LCALL   `??ZMacInit::?relay` ; Banked call to: ZMacInit
    136          
    137            // Determine the extended address
    138            zmain_ext_addr();     //确定IEEE 64位地址
   \   000056                ; Setup parameters for call to function zmain_ext_addr
   \   000056   12....       LCALL   `??zmain_ext_addr::?relay`; Banked call to: zmain_ext_addr
    139          
    140            // Initialize basic NV items
    141            zgInit();     // 初始化非易失变量
   \   000059                ; Setup parameters for call to function zgInit
   \   000059   12....       LCALL   `??zgInit::?relay`   ; Banked call to: zgInit
    142          
    143          #ifndef NONWK
    144            // Since the AF isn't a task, call it's initialization routine
    145            afInit();
   \   00005C                ; Setup parameters for call to function afInit
   \   00005C   12....       LCALL   `??afInit::?relay`   ; Banked call to: afInit
    146          #endif
    147          
    148            // Initialize the operating system
    149            osal_init_system();   // 初始化操作系统       
   \   00005F                ; Setup parameters for call to function osal_init_system
   \   00005F   12....       LCALL   `??osal_init_system::?relay`; Banked call to: osal_init_system
    150          
    151            // Allow interrupts
    152            osal_int_enable( INTS_ALL );  //打开所有中断
   \   000062                ; Setup parameters for call to function osal_int_enable
   \   000062   79FF         MOV     R1,#-0x1
   \   000064   12....       LCALL   `??osal_int_enable::?relay`; Banked call to: osal_int_enable
    153          
    154            // Final board initialization
    155            InitBoard( OB_READY );    //初始化板载外设
   \   000067                ; Setup parameters for call to function InitBoard
   \   000067   7902         MOV     R1,#0x2
   \   000069   12....       LCALL   `??InitBoard::?relay`; Banked call to: InitBoard
    156          
    157            // Display information about this device
    158            zmain_dev_info();     //显示相关信息
   \   00006C   78..         MOV     R0,#(aExtendedAddress + 7) & 0xff
   \   00006E   79..         MOV     R1,#((aExtendedAddress + 7) >> 8) & 0xff
   \   000070   7C00         MOV     R4,#0x0
   \                     ??main_3:
   \   000072   8882         MOV     DPL,R0
   \   000074   8983         MOV     DPH,R1
   \   000076   E0           MOVX    A,@DPTR
   \   000077   C4           SWAP    A
   \   000078   540F         ANL     A,#0xf
   \   00007A   FB           MOV     R3,A
   \   00007B   EC           MOV     A,R4
   \   00007C   FE           MOV     R6,A
   \   00007D   7401         MOV     A,#0x1
   \   00007F   2E           ADD     A,R6
   \   000080   FC           MOV     R4,A
   \   000081   EB           MOV     A,R3
   \   000082   C3           CLR     C
   \   000083   940A         SUBB    A,#0xa
   \   000085   5004         JNC     ??main_4
   \   000087   7A30         MOV     R2,#0x30
   \   000089   8002         SJMP    ??main_5
   \                     ??main_4:
   \   00008B   7A37         MOV     R2,#0x37
   \                     ??main_5:
   \   00008D   EB           MOV     A,R3
   \   00008E   2A           ADD     A,R2
   \   00008F   C0E0         PUSH    A
   \   000091   85..82       MOV     DPL,?XSP + 0
   \   000094   85..83       MOV     DPH,?XSP + 1
   \   000097   E582         MOV     A,DPL
   \   000099   2E           ADD     A,R6
   \   00009A   F582         MOV     DPL,A
   \   00009C   E4           CLR     A
   \   00009D   3583         ADDC    A,DPH
   \   00009F   F583         MOV     DPH,A
   \   0000A1   D0E0         POP     A
   \   0000A3   F0           MOVX    @DPTR,A
   \   0000A4   8882         MOV     DPL,R0
   \   0000A6   8983         MOV     DPH,R1
   \   0000A8   E0           MOVX    A,@DPTR
   \   0000A9   540F         ANL     A,#0xf
   \   0000AB   FB           MOV     R3,A
   \   0000AC   EC           MOV     A,R4
   \   0000AD   FF           MOV     R7,A
   \   0000AE   7401         MOV     A,#0x1
   \   0000B0   2C           ADD     A,R4
   \   0000B1   FC           MOV     R4,A
   \   0000B2   EB           MOV     A,R3
   \   0000B3   C3           CLR     C
   \   0000B4   940A         SUBB    A,#0xa
   \   0000B6   5004         JNC     ??main_6
   \   0000B8   7A30         MOV     R2,#0x30
   \   0000BA   8002         SJMP    ??main_7
   \                     ??main_6:
   \   0000BC   7A37         MOV     R2,#0x37
   \                     ??main_7:
   \   0000BE   EB           MOV     A,R3
   \   0000BF   2A           ADD     A,R2
   \   0000C0   C0E0         PUSH    A
   \   0000C2   85..82       MOV     DPL,?XSP + 0
   \   0000C5   85..83       MOV     DPH,?XSP + 1
   \   0000C8   E582         MOV     A,DPL
   \   0000CA   2F           ADD     A,R7
   \   0000CB   F582         MOV     DPL,A
   \   0000CD   E4           CLR     A
   \   0000CE   3583         ADDC    A,DPH
   \   0000D0   F583         MOV     DPH,A
   \   0000D2   D0E0         POP     A
   \   0000D4   F0           MOVX    @DPTR,A
   \   0000D5   E8           MOV     A,R0
   \   0000D6   24FF         ADD     A,#-0x1
   \   0000D8   18           DEC     R0
   \   0000D9   E9           MOV     A,R1
   \   0000DA   34FF         ADDC    A,#-0x1
   \   0000DC   F9           MOV     R1,A
   \   0000DD   EC           MOV     A,R4
   \   0000DE   C3           CLR     C
   \   0000DF   9410         SUBB    A,#0x10
   \   0000E1   408F         JC      ??main_3
   \   0000E3   7410         MOV     A,#0x10
   \   0000E5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E8   E4           CLR     A
   \   0000E9   F0           MOVX    @DPTR,A
   \   0000EA                ; Setup parameters for call to function HalLcdWriteString
   \   0000EA   7901         MOV     R1,#0x1
   \   0000EC   7A..         MOV     R2,#`?<Constant "IEEE: ">` & 0xff
   \   0000EE   7B..         MOV     R3,#(`?<Constant "IEEE: ">` >> 8) & 0xff
   \   0000F0   12....       LCALL   `??HalLcdWriteString::?relay`; Banked call to: HalLcdWriteString
   \   0000F3                ; Setup parameters for call to function HalLcdWriteString
   \   0000F3   7902         MOV     R1,#0x2
   \   0000F5   AA..         MOV     R2,?XSP + 0
   \   0000F7   AB..         MOV     R3,?XSP + 1
   \   0000F9   12....       LCALL   `??HalLcdWriteString::?relay`; Banked call to: HalLcdWriteString
    159          
    160            /* Display the device info on the LCD */
    161          #ifdef LCD_SUPPORTED
    162            zmain_lcd_init();
   \   0000FC                ; Setup parameters for call to function HalLcdWriteString
   \   0000FC   7901         MOV     R1,#0x1
   \   0000FE   7A..         MOV     R2,#`?<Constant "TexasInstruments">` & 0xff
   \   000100   7B..         MOV     R3,#(`?<Constant "TexasInstruments">` >> 8) & 0xff
   \   000102   12....       LCALL   `??HalLcdWriteString::?relay`; Banked call to: HalLcdWriteString
    163          #endif
    164          
    165          #ifdef WDT_IN_PM1
    166            /* If WDT is used, this is a good place to enable it. */
    167            WatchDogEnable( WDTIMX );
    168          #endif
    169            // No Return from here
    170            osal_start_system();  //执行操作系统，进去后不会返回
   \   000105                ; Setup parameters for call to function osal_start_system
   \   000105   12....       LCALL   `??osal_start_system::?relay`; Banked call to: osal_start_system
    171          
    172            return 0;  // Shouldn't get here.
   \   000108   7A00         MOV     R2,#0x0
   \   00010A   7B00         MOV     R3,#0x0
   \   00010C   7411         MOV     A,#0x11
   \   00010E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000111   02....       LJMP    ?BRET
   \   000114                REQUIRE SLEEPCMD
   \   000114                REQUIRE SLEEPSTA
   \   000114                REQUIRE CLKCONCMD
   \   000114                REQUIRE CLKCONSTA
   \   000114                REQUIRE P1DIR
   \   000114                REQUIRE P0INP
    173          } // main()
    174          
    175          /*********************************************************************
    176           * @fn      zmain_vdd_check
    177           * @brief   Check if the Vdd is OK to run the processor.
    178           * @return  Return if Vdd is ok; otherwise, flash LED, then reset
    179           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    180          static void zmain_vdd_check( void )
   \                     zmain_vdd_check:
    181          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    182            uint8 vdd_passed_count = 0;
   \   000005   7E00         MOV     R6,#0x0
    183            bool toggle = 0;
   \   000007   7F00         MOV     R7,#0x0
   \   000009   8002         SJMP    ??zmain_vdd_check_0
    184          
    185            // Repeat getting the sample until number of failures or successes hits MAX
    186            // then based on the count value, determine if the device is ready or not
    187            while ( vdd_passed_count < MAX_VDD_SAMPLES )
    188            {
    189              if ( HalAdcCheckVdd (ZMAIN_VDD_LIMIT) )
    190              {
    191                vdd_passed_count++;    // Keep track # times Vdd passes in a row
    192                MicroWait (10000);     // Wait 10ms to try again
    193              }
    194              else
    195              {
    196                vdd_passed_count = 0;  // Reset passed counter
    197                MicroWait (50000);     // Wait 50ms
    198                MicroWait (50000);     // Wait another 50ms to try again
    199              }
    200          
    201              /* toggle LED1 and LED2 */
    202              if (vdd_passed_count == 0)
    203              {
    204                if ((toggle = !(toggle)))
    205                  HAL_TOGGLE_LED1();
   \                     ??zmain_vdd_check_1:
   \   00000B   C297         CLR     0x90.7
   \                     ??zmain_vdd_check_0:
   \   00000D                ; Setup parameters for call to function HalAdcCheckVdd
   \   00000D   7904         MOV     R1,#0x4
   \   00000F   12....       LCALL   `??HalAdcCheckVdd::?relay`; Banked call to: HalAdcCheckVdd
   \   000012   E9           MOV     A,R1
   \   000013   6019         JZ      ??zmain_vdd_check_2
   \   000015   0E           INC     R6
   \   000016                ; Setup parameters for call to function Onboard_wait
   \   000016   7A10         MOV     R2,#0x10
   \   000018   7B27         MOV     R3,#0x27
   \   00001A   12....       LCALL   `??Onboard_wait::?relay`; Banked call to: Onboard_wait
   \   00001D   EE           MOV     A,R6
   \   00001E   601E         JZ      ??zmain_vdd_check_3
   \   000020   C3           CLR     C
   \   000021   9403         SUBB    A,#0x3
   \   000023   40E8         JC      ??zmain_vdd_check_0
    206                else
    207                  HAL_TOGGLE_LED2();
    208              }
    209            }
    210          
    211            /* turn off LED1 */
    212            HAL_TURN_OFF_LED1();
   \   000025   C297         CLR     0x90.7
    213            HAL_TURN_OFF_LED2();
   \   000027   C296         CLR     0x90.6
    214          }
   \   000029   7F01         MOV     R7,#0x1
   \   00002B   02....       LJMP    ?BANKED_LEAVE_XDATA
   \                     ??zmain_vdd_check_2:
   \   00002E   7E00         MOV     R6,#0x0
   \   000030                ; Setup parameters for call to function Onboard_wait
   \   000030   7A50         MOV     R2,#0x50
   \   000032   7BC3         MOV     R3,#-0x3d
   \   000034   12....       LCALL   `??Onboard_wait::?relay`; Banked call to: Onboard_wait
   \   000037                ; Setup parameters for call to function Onboard_wait
   \   000037   7A50         MOV     R2,#0x50
   \   000039   7BC3         MOV     R3,#-0x3d
   \   00003B   12....       LCALL   `??Onboard_wait::?relay`; Banked call to: Onboard_wait
   \                     ??zmain_vdd_check_3:
   \   00003E   EF           MOV     A,R7
   \   00003F   A2E0         MOV     C,0xE0 /* A   */.0
   \   000041   B3           CPL     C
   \   000042   E4           CLR     A
   \   000043   33           RLC     A
   \   000044   FF           MOV     R7,A
   \   000045   A2E0         MOV     C,0xE0 /* A   */.0
   \   000047   5008         JNC     ??zmain_vdd_check_4
   \   000049   A297         MOV     C,0x90.7
   \   00004B   40BE         JC      ??zmain_vdd_check_1
   \   00004D   D297         SETB    0x90.7
   \   00004F   80BC         SJMP    ??zmain_vdd_check_0
   \                     ??zmain_vdd_check_4:
   \   000051   A296         MOV     C,0x90.6
   \   000053   5004         JNC     ??zmain_vdd_check_5
   \   000055   C296         CLR     0x90.6
   \   000057   80B4         SJMP    ??zmain_vdd_check_0
   \                     ??zmain_vdd_check_5:
   \   000059   D296         SETB    0x90.6
   \   00005B   80B0         SJMP    ??zmain_vdd_check_0
   \   00005D                REQUIRE _A_P1
    215          
    216          /**************************************************************************************************
    217           * @fn          zmain_ext_addr
    218           *
    219           * @brief       Execute a prioritized search for a valid extended address and write the results
    220           *              into the OSAL NV system for use by the system. Temporary address not saved to NV.
    221           *
    222           * input parameters
    223           *
    224           * None.
    225           *
    226           * output parameters
    227           *
    228           * None.
    229           *
    230           * @return      None.
    231           **************************************************************************************************
    232           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    233          static void zmain_ext_addr(void)
   \                     zmain_ext_addr:
    234          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 11
   \   000005   74F5         MOV     A,#-0xb
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    235            uint8 nullAddr[Z_EXTADDR_LEN] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
   \   00000A   90....       MOV     DPTR,#`?<Constant {255, 255, 255, 255, 255, 255, 255,`
   \   00000D   7403         MOV     A,#0x3
   \   00000F   12....       LCALL   ?XSTACK_DISP102_8
   \   000012   7408         MOV     A,#0x8
   \   000014   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    236            uint8 writeNV = TRUE;
    237          
    238            // First check whether a non-erased extended address exists in the OSAL NV.
    239            if ((SUCCESS != osal_nv_item_init(ZCD_NV_EXTADDR, Z_EXTADDR_LEN, NULL))  ||
    240                (SUCCESS != osal_nv_read(ZCD_NV_EXTADDR, 0, Z_EXTADDR_LEN, aExtendedAddress)) ||
    241                (osal_memcmp(aExtendedAddress, nullAddr, Z_EXTADDR_LEN)))
   \   000017   85..82       MOV     DPL,?XSP + 0
   \   00001A   85..83       MOV     DPH,?XSP + 1
   \   00001D   74..         MOV     A,#aExtendedAddress & 0xff
   \   00001F   F0           MOVX    @DPTR,A
   \   000020   A3           INC     DPTR
   \   000021   74..         MOV     A,#(aExtendedAddress >> 8) & 0xff
   \   000023   F0           MOVX    @DPTR,A
   \   000024   A3           INC     DPTR
   \   000025   E4           CLR     A
   \   000026   F0           MOVX    @DPTR,A
   \   000027   7403         MOV     A,#0x3
   \   000029   12....       LCALL   ?XSTACK_DISP100_8
   \   00002C   88..         MOV     ?V0,R0
   \   00002E   89..         MOV     ?V1,R1
   \   000030   75..00       MOV     ?V2,#0x0
   \   000033                ; Setup parameters for call to function osal_nv_item_init
   \   000033   E4           CLR     A
   \   000034   F5..         MOV     ?V4,A
   \   000036   F5..         MOV     ?V5,A
   \   000038   78..         MOV     R0,#?V4
   \   00003A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003D   7C08         MOV     R4,#0x8
   \   00003F   7D00         MOV     R5,#0x0
   \   000041   7A01         MOV     R2,#0x1
   \   000043   7B00         MOV     R3,#0x0
   \   000045   12....       LCALL   `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   000048   7402         MOV     A,#0x2
   \   00004A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00004D   E9           MOV     A,R1
   \   00004E   7048         JNZ     ??zmain_ext_addr_0
   \   000050                ; Setup parameters for call to function osal_nv_read
   \   000050   75....       MOV     ?V4,#aExtendedAddress & 0xff
   \   000053   75....       MOV     ?V5,#(aExtendedAddress >> 8) & 0xff
   \   000056   78..         MOV     R0,#?V4
   \   000058   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005B   75..08       MOV     ?V4,#0x8
   \   00005E   75..00       MOV     ?V5,#0x0
   \   000061   78..         MOV     R0,#?V4
   \   000063   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000066   7C00         MOV     R4,#0x0
   \   000068   7D00         MOV     R5,#0x0
   \   00006A   7A01         MOV     R2,#0x1
   \   00006C   7B00         MOV     R3,#0x0
   \   00006E   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000071   7404         MOV     A,#0x4
   \   000073   12....       LCALL   ?DEALLOC_XSTACK8
   \   000076   E9           MOV     A,R1
   \   000077   701F         JNZ     ??zmain_ext_addr_0
   \   000079                ; Setup parameters for call to function osal_memcmp
   \   000079   78..         MOV     R0,#?V0
   \   00007B   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00007E   7C08         MOV     R4,#0x8
   \   000080   7D00         MOV     R5,#0x0
   \   000082   7403         MOV     A,#0x3
   \   000084   12....       LCALL   ?XSTACK_DISP0_8
   \   000087   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   00008A   12....       LCALL   `??osal_memcmp::?relay`; Banked call to: osal_memcmp
   \   00008D   7403         MOV     A,#0x3
   \   00008F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000092   E9           MOV     A,R1
   \   000093   7003         JNZ     $+5
   \   000095   02....       LJMP    ??zmain_ext_addr_1 & 0xFFFF
    242            {
    243              // Attempt to read the extended address from the location on the lock bits page
    244              // where the programming tools know to reserve it.
    245              HalFlashRead(HAL_FLASH_IEEE_PAGE, HAL_FLASH_IEEE_OSET, aExtendedAddress, Z_EXTADDR_LEN);
   \                     ??zmain_ext_addr_0:
   \   000098                ; Setup parameters for call to function HalFlashRead
   \   000098   75..08       MOV     ?V4,#0x8
   \   00009B   78..         MOV     R0,#?V4
   \   00009D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A0   7C..         MOV     R4,#aExtendedAddress & 0xff
   \   0000A2   7D..         MOV     R5,#(aExtendedAddress >> 8) & 0xff
   \   0000A4   7AE8         MOV     R2,#-0x18
   \   0000A6   7B07         MOV     R3,#0x7
   \   0000A8   797F         MOV     R1,#0x7f
   \   0000AA   12....       LCALL   `??HalFlashRead::?relay`; Banked call to: HalFlashRead
   \   0000AD   7402         MOV     A,#0x2
   \   0000AF   12....       LCALL   ?DEALLOC_XSTACK8
    246          
    247              if (osal_memcmp(aExtendedAddress, nullAddr, Z_EXTADDR_LEN))
   \   0000B2                ; Setup parameters for call to function osal_memcmp
   \   0000B2   78..         MOV     R0,#?V0
   \   0000B4   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000B7   7C08         MOV     R4,#0x8
   \   0000B9   7D00         MOV     R5,#0x0
   \   0000BB   7403         MOV     A,#0x3
   \   0000BD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C0   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   0000C3   12....       LCALL   `??osal_memcmp::?relay`; Banked call to: osal_memcmp
   \   0000C6   7403         MOV     A,#0x3
   \   0000C8   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000CB   E9           MOV     A,R1
   \   0000CC   6035         JZ      ??zmain_ext_addr_2
    248              {
    249                // Attempt to read the extended address from the designated location in the Info Page.
    250                if (!osal_memcmp((uint8 *)(P_INFOPAGE+HAL_INFOP_IEEE_OSET), nullAddr, Z_EXTADDR_LEN))
   \   0000CE                ; Setup parameters for call to function osal_memcmp
   \   0000CE   78..         MOV     R0,#?V0
   \   0000D0   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000D3   7C08         MOV     R4,#0x8
   \   0000D5   7D00         MOV     R5,#0x0
   \   0000D7   790C         MOV     R1,#0xc
   \   0000D9   7A78         MOV     R2,#0x78
   \   0000DB   7B00         MOV     R3,#0x0
   \   0000DD   12....       LCALL   `??osal_memcmp::?relay`; Banked call to: osal_memcmp
   \   0000E0   7403         MOV     A,#0x3
   \   0000E2   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E5   E9           MOV     A,R1
   \   0000E6   7054         JNZ     ??zmain_ext_addr_3
    251                {
    252                  osal_memcpy(aExtendedAddress, (uint8 *)(P_INFOPAGE+HAL_INFOP_IEEE_OSET), Z_EXTADDR_LEN);
   \   0000E8                ; Setup parameters for call to function osal_memcpy
   \   0000E8   75..0C       MOV     ?V0,#0xc
   \   0000EB   75..78       MOV     ?V1,#0x78
   \   0000EE   78..         MOV     R0,#?V0
   \   0000F0   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000F3   7C08         MOV     R4,#0x8
   \   0000F5   7D00         MOV     R5,#0x0
   \   0000F7   7A..         MOV     R2,#aExtendedAddress & 0xff
   \   0000F9   7B..         MOV     R3,#(aExtendedAddress >> 8) & 0xff
   \   0000FB   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   0000FE   7403         MOV     A,#0x3
   \   000100   12....       LCALL   ?DEALLOC_XSTACK8
    253                }
    254                else  // No valid extended address was found.
    255                {
    256                  uint8 idx;
    257                  
    258          #if !defined ( NV_RESTORE )
    259                  writeNV = FALSE;  // Make this a temporary IEEE address
    260          #endif
    261          
    262                  /* Attempt to create a sufficiently random extended address for expediency.
    263                   * Note: this is only valid/legal in a test environment and
    264                   *       must never be used for a commercial product.
    265                   */
    266                  for (idx = 0; idx < (Z_EXTADDR_LEN - 2);)
    267                  {
    268                    uint16 randy = osal_rand();
    269                    aExtendedAddress[idx++] = LO_UINT16(randy);
    270                    aExtendedAddress[idx++] = HI_UINT16(randy);
    271                  }
    272                  // Next-to-MSB identifies ZigBee devicetype.
    273          #if ZG_BUILD_COORDINATOR_TYPE && !ZG_BUILD_JOINING_TYPE
    274                  aExtendedAddress[idx++] = 0x10;
    275          #elif ZG_BUILD_RTRONLY_TYPE
    276                  aExtendedAddress[idx++] = 0x20;
    277          #else
    278                  aExtendedAddress[idx++] = 0x30;
    279          #endif
    280                  // MSB has historical signficance.
    281                  aExtendedAddress[idx] = 0xF8;
    282                }
    283              }
    284          
    285              if (writeNV)
    286              {
    287                (void)osal_nv_write(ZCD_NV_EXTADDR, 0, Z_EXTADDR_LEN, aExtendedAddress);
   \                     ??zmain_ext_addr_2:
   \   000103                ; Setup parameters for call to function osal_nv_write
   \   000103   75....       MOV     ?V0,#aExtendedAddress & 0xff
   \   000106   75....       MOV     ?V1,#(aExtendedAddress >> 8) & 0xff
   \   000109   78..         MOV     R0,#?V0
   \   00010B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00010E   75..08       MOV     ?V0,#0x8
   \   000111   75..00       MOV     ?V1,#0x0
   \   000114   78..         MOV     R0,#?V0
   \   000116   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000119   7C00         MOV     R4,#0x0
   \   00011B   7D00         MOV     R5,#0x0
   \   00011D   7A01         MOV     R2,#0x1
   \   00011F   7B00         MOV     R3,#0x0
   \   000121   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000124   7404         MOV     A,#0x4
   \   000126   12....       LCALL   ?DEALLOC_XSTACK8
    288              }
    289            }
    290          
    291            // Set the MAC PIB extended address according to results from above.
    292            (void)ZMacSetReq(MAC_EXTENDED_ADDRESS, aExtendedAddress);
   \                     ??zmain_ext_addr_1:
   \   000129                ; Setup parameters for call to function ZMacSetReq
   \   000129   7A..         MOV     R2,#aExtendedAddress & 0xff
   \   00012B   7B..         MOV     R3,#(aExtendedAddress >> 8) & 0xff
   \   00012D   79E2         MOV     R1,#-0x1e
   \   00012F   12....       LCALL   `??ZMacSetReq::?relay`; Banked call to: ZMacSetReq
    293          }
   \   000132   740B         MOV     A,#0xb
   \   000134   12....       LCALL   ?DEALLOC_XSTACK8
   \   000137   7F06         MOV     R7,#0x6
   \   000139   02....       LJMP    ?BANKED_LEAVE_XDATA
   \                     ??zmain_ext_addr_3:
   \   00013C   7E00         MOV     R6,#0x0
   \                     ??zmain_ext_addr_4:
   \   00013E                ; Setup parameters for call to function osal_rand
   \   00013E   12....       LCALL   `??osal_rand::?relay`; Banked call to: osal_rand
   \   000141   8A..         MOV     ?V0,R2
   \   000143   EE           MOV     A,R6
   \   000144   FA           MOV     R2,A
   \   000145   74..         MOV     A,#aExtendedAddress & 0xff
   \   000147   2A           ADD     A,R2
   \   000148   F582         MOV     DPL,A
   \   00014A   E4           CLR     A
   \   00014B   34..         ADDC    A,#(aExtendedAddress >> 8) & 0xff
   \   00014D   F583         MOV     DPH,A
   \   00014F   E5..         MOV     A,?V0
   \   000151   F0           MOVX    @DPTR,A
   \   000152   0E           INC     R6
   \   000153   EE           MOV     A,R6
   \   000154   F8           MOV     R0,A
   \   000155   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   000158   EB           MOV     A,R3
   \   000159   F0           MOVX    @DPTR,A
   \   00015A   0E           INC     R6
   \   00015B   EE           MOV     A,R6
   \   00015C   C3           CLR     C
   \   00015D   9406         SUBB    A,#0x6
   \   00015F   40DD         JC      ??zmain_ext_addr_4
   \   000161   08           INC     R0
   \   000162   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   000165   7430         MOV     A,#0x30
   \   000167   F0           MOVX    @DPTR,A
   \   000168   08           INC     R0
   \   000169   74..         MOV     A,#aExtendedAddress & 0xff
   \   00016B   28           ADD     A,R0
   \   00016C   F582         MOV     DPL,A
   \   00016E   E4           CLR     A
   \   00016F   34..         ADDC    A,#(aExtendedAddress >> 8) & 0xff
   \   000171   F583         MOV     DPH,A
   \   000173   74F8         MOV     A,#-0x8
   \   000175   F0           MOVX    @DPTR,A
   \   000176   80B1         SJMP    ??zmain_ext_addr_1

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   74..         MOV     A,#aExtendedAddress & 0xff
   \   000002   2E           ADD     A,R6
   \   000003   F582         MOV     DPL,A
   \   000005   E4           CLR     A
   \   000006   34..         ADDC    A,#(aExtendedAddress >> 8) & 0xff
   \   000008   F583         MOV     DPH,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F9           MOV     R1,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FA           MOV     R2,A
   \   000005   A3           INC     DPTR
   \   000006   E0           MOVX    A,@DPTR
   \   000007   FB           MOV     R3,A
   \   000008   22           RET

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??main::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    main

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zmain_vdd_check::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zmain_vdd_check

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zmain_ext_addr::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zmain_ext_addr

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {255, 255, 255, 255, 255, 255, 255,`:
   \   000000   FF           DB 255
   \   000001   FF           DB 255
   \   000002   FF           DB 255
   \   000003   FF           DB 255
   \   000004   FF           DB 255
   \   000005   FF           DB 255
   \   000006   FF           DB 255
   \   000007   FF           DB 255

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "IEEE: ">`:
   \   000000   49454545     DB "IEEE: "
   \            3A2000  

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "TexasInstruments">`:
   \   000000   54657861     DB "TexasInstruments"
   \            73496E73
   \            7472756D
   \            656E7473
   \            00      
    294          
    295          /**************************************************************************************************
    296           * @fn          zmain_dev_info
    297           *
    298           * @brief       This displays the IEEE (MSB to LSB) on the LCD.
    299           *
    300           * input parameters
    301           *
    302           * None.
    303           *
    304           * output parameters
    305           *
    306           * None.
    307           *
    308           * @return      None.
    309           **************************************************************************************************
    310           */
    311          static void zmain_dev_info(void)
    312          {
    313          #ifdef LCD_SUPPORTED
    314            uint8 i;
    315            uint8 *xad;
    316            uint8 lcd_buf[Z_EXTADDR_LEN*2+1];
    317          
    318            // Display the extended address.
    319            xad = aExtendedAddress + Z_EXTADDR_LEN - 1;
    320          
    321            for (i = 0; i < Z_EXTADDR_LEN*2; xad--)
    322            {
    323              uint8 ch;
    324              ch = (*xad >> 4) & 0x0F;
    325              lcd_buf[i++] = ch + (( ch < 10 ) ? '0' : '7');
    326              ch = *xad & 0x0F;
    327              lcd_buf[i++] = ch + (( ch < 10 ) ? '0' : '7');
    328            }
    329            lcd_buf[Z_EXTADDR_LEN*2] = '\0';
    330            HalLcdWriteString( "IEEE: ", HAL_LCD_LINE_1 );
    331            HalLcdWriteString( (char*)lcd_buf, HAL_LCD_LINE_2 );
    332          #endif
    333          }
    334          
    335          #ifdef LCD_SUPPORTED
    336          /*********************************************************************
    337           * @fn      zmain_lcd_init
    338           * @brief   Initialize LCD at start up.
    339           * @return  none
    340           *********************************************************************/
    341          static void zmain_lcd_init ( void )
    342          {
    343          #ifdef SERIAL_DEBUG_SUPPORTED
    344            {
    345              HalLcdWriteString( "TexasInstruments", HAL_LCD_LINE_1 );
    346          
    347          #if defined( MT_MAC_FUNC )
    348          #if defined( ZDO_COORDINATOR )
    349                HalLcdWriteString( "MAC-MT Coord", HAL_LCD_LINE_2 );
    350          #else
    351                HalLcdWriteString( "MAC-MT Device", HAL_LCD_LINE_2 );
    352          #endif // ZDO
    353          #elif defined( MT_NWK_FUNC )
    354          #if defined( ZDO_COORDINATOR )
    355                HalLcdWriteString( "NWK Coordinator", HAL_LCD_LINE_2 );
    356          #else
    357                HalLcdWriteString( "NWK Device", HAL_LCD_LINE_2 );
    358          #endif // ZDO
    359          #endif // MT_FUNC
    360            }
    361          #endif // SERIAL_DEBUG_SUPPORTED
    362          }
    363          #endif
    364          
    365          /*********************************************************************
    366          *********************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      1     17   main
        0     17   -> HalDriverInit
        0     17   -> HalLcdWriteString
        0     17   -> InitBoard
        0     17   -> ZMacInit
        0     17   -> afInit
        0     17   -> osal_init_system
        0     17   -> osal_int_disable
        0     17   -> osal_int_enable
        0     17   -> osal_nv_init
        0     17   -> osal_start_system
        0     17   -> zgInit
        0     17   -> zmain_ext_addr
        0     17   -> zmain_vdd_check
      1     46   zmain_ext_addr
        0     27   -> HalFlashRead
        0     25   -> ZMacSetReq
        0     28   -> osal_memcmp
        0     28   -> osal_memcpy
        0     27   -> osal_nv_item_init
        0     29   -> osal_nv_read
        0     29   -> osal_nv_write
        0     25   -> osal_rand
      0     26   zmain_vdd_check
        0      9   -> HalAdcCheckVdd
        0      9   -> Onboard_wait


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       7  ?<Constant "IEEE: ">
      17  ?<Constant "TexasInstruments">
       8  ?<Constant {255, 255, 255, 255, 255, 255, 255,
       9  ?Subroutine0
      11  ?Subroutine1
       1  CLKCONCMD
       1  CLKCONSTA
       1  P0INP
       1  P1DIR
       1  SLEEPCMD
       1  SLEEPSTA
       1  _A_P1
     276  main
       6  main::?relay
     376  zmain_ext_addr
       6  zmain_ext_addr::?relay
      93  zmain_vdd_check
       6  zmain_vdd_check::?relay

 
 765 bytes in segment BANKED_CODE
  18 bytes in segment BANK_RELAYS
   7 bytes in segment SFR_AN
  32 bytes in segment XDATA_ROM_C
 
 783 bytes of CODE  memory
  32 bytes of CONST memory
   0 bytes of DATA  memory (+ 7 bytes shared)

Errors: none
Warnings: none
