###############################################################################
#
# IAR C/C++ Compiler V9.20.1.2476 for 8051                26/May/2017  16:13:46
# Copyright 2004-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Components\stack\zdo\ZDSecMgr.c
#    Command line       =  
#        -f
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DBLINK_LEDS) -f
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg
#        (-DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_POLLED=3000
#        -DNWK_INDIRECT_MSG_TIMEOUT=7 -DMAX_RREQ_ENTRIES=8
#        -DAPSC_MAX_FRAME_RETRIES=3 -DNWK_MAX_DATA_RETRIES=2
#        -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9 -DAPS_MAX_GROUPS=16
#        -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"
#        -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000
#        -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)
#        -DREJOIN_POLL_RATE=440
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Components\stack\zdo\ZDSecMgr.c -D
#        ZIGBEEPRO -D NWK_AUTO_POLL -D ZTOOL_P1 -D MT_TASK -D MT_SYS_FUNC -D
#        MT_ZDO_FUNC -D LCD_SUPPORTED=DEBUG -lC
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\EndDeviceEB-Pro\List\
#        -lA
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\EndDeviceEB-Pro\List\
#        --diag_suppress Pe001,Pa010 -o
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\EndDeviceEB-Pro\Obj\
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 8 -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\SOURCE\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\ZMAIN\TI2530DB\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MT\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\INCLUDE\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\TARGET\CC2530EB\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\MCU\CCSOC\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\INCLUDE\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\AF\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\NWK\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SEC\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SAPI\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SYS\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\ZDO\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\F8W\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES\SADDR\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES\SDATA\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\INCLUDE\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\HIGH_LEVEL\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\
#        -I
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\SINGLE_CHIP\
#        -Ohz --require_prototypes
#    List file          =  
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\EndDeviceEB-Pro\List\ZDSecMgr.lst
#    Object file        =  
#        D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp\CC2530DB\EndDeviceEB-Pro\Obj\ZDSecMgr.r51
#
###############################################################################

D:\Zigbee\ZStack-CC2530-2.3.0-1.4.0\Components\stack\zdo\ZDSecMgr.c
      1          /**************************************************************************************************
      2            Filename:       ZDSecMgr.c
      3            Revised:        $Date: 2010-01-08 13:29:59 -0800 (Fri, 08 Jan 2010) $
      4            Revision:       $Revision: 21465 $
      5          
      6            Description:    The ZigBee Device Security Manager.
      7          
      8          
      9            Copyright 2005-2009 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          #ifdef __cplusplus
     41          extern "C"
     42          {
     43          #endif
     44          
     45          /******************************************************************************
     46           * INCLUDES
     47           */
     48          #include "ZComdef.h"
     49          #include "OSAL.h"
     50          #include "OSAL_NV.h"
     51          #include "ZGlobals.h"
     52          #include "ssp.h"
     53          #include "nwk_globals.h"
     54          #include "nwk.h"
     55          #include "NLMEDE.h"
     56          #include "AddrMgr.h"
     57          #include "AssocList.h"
     58          #include "APSMEDE.h"
     59          #include "AF.h"
     60          #include "ZDConfig.h"
     61          #include "ZDApp.h"
     62          #include "ZDSecMgr.h"
     63          
     64          
     65          /******************************************************************************
     66           * CONSTANTS
     67           */
     68          // maximum number of devices managed by this Security Manager
     69          #if !defined ( ZDSECMGR_DEVICE_MAX )
     70            #define ZDSECMGR_DEVICE_MAX 3
     71          #endif
     72          
     73          // total number of preconfigured devices (EXT address, MASTER key)
     74          //devtag.pro.security
     75          //#define ZDSECMGR_PRECONFIG_MAX ZDSECMGR_DEVICE_MAX
     76          #define ZDSECMGR_PRECONFIG_MAX 0
     77          
     78          // maximum number of MASTER keys this device may hold
     79          #define ZDSECMGR_MASTERKEY_MAX ZDSECMGR_DEVICE_MAX
     80          
     81          // maximum number of LINK keys this device may store
     82          #define ZDSECMGR_ENTRY_MAX ZDSECMGR_DEVICE_MAX
     83          
     84          // total number of devices under control - authentication, SKKE, etc.
     85          #define ZDSECMGR_CTRL_MAX ZDSECMGR_DEVICE_MAX
     86          
     87          // total number of stored devices
     88          #if !defined ( ZDSECMGR_STORED_DEVICES )
     89            #define ZDSECMGR_STORED_DEVICES 3
     90          #endif
     91            
     92          // Total number of preconfigured trust center link key
     93          #if !defined ( ZDSECMGR_TC_DEVICE_MAX )
     94            #define ZDSECMGR_TC_DEVICE_MAX 1
     95          #endif
     96            
     97          #if ( ZDSECMGR_TC_DEVICE_MAX < 1 ) || ( ZDSECMGR_TC_DEVICE_MAX > 255 )
     98            #error "ZDSECMGR_TC_DEVICE_MAX shall be between 1 and 255 !"
     99          #endif
    100            
    101          #define ZDSECMGR_CTRL_NONE       0
    102          #define ZDSECMGR_CTRL_INIT       1
    103          #define ZDSECMGR_CTRL_TK_MASTER  2
    104          #define ZDSECMGR_CTRL_SKKE_INIT  3
    105          #define ZDSECMGR_CTRL_SKKE_WAIT  4
    106          #define ZDSECMGR_CTRL_SKKE_DONE  5
    107          #define ZDSECMGR_CTRL_SKKE_FAIL  6
    108          #define ZDSECMGR_CTRL_TK_NWK     7
    109          
    110          #define ZDSECMGR_CTRL_BASE_CNTR      1
    111          #define ZDSECMGR_CTRL_SKKE_INIT_CNTR 1
    112          #define ZDSECMGR_CTRL_TK_NWK_CNTR    1
    113          
    114          // set SKA slot maximum
    115          #define ZDSECMGR_SKA_SLOT_MAX 1
    116          
    117          // APSME Stub Implementations
    118          #define ZDSecMgrMasterKeyGet   APSME_MasterKeyGet
    119          #define ZDSecMgrLinkKeySet     APSME_LinkKeySet
    120          #define ZDSecMgrLinkKeyDataGet APSME_LinkKeyDataGet
    121          #define ZDSecMgrKeyFwdToChild  APSME_KeyFwdToChild
    122          
    123          #if !defined( MAX_APS_FRAMECOUNTER_CHANGES )
    124            // The number of times the frame counter can change before
    125            // saving to NV
    126            #define MAX_APS_FRAMECOUNTER_CHANGES    10
    127          #endif
    128          
    129          /******************************************************************************
    130           * TYPEDEFS
    131           */
    132          typedef struct
    133          {
    134            uint8 extAddr[Z_EXTADDR_LEN];
    135            uint8 key[SEC_KEY_LEN];
    136          } ZDSecMgrPreConfigData_t;
    137          
    138          typedef struct
    139          {
    140            uint16 ami;
    141            uint8  key[SEC_KEY_LEN];
    142          } ZDSecMgrMasterKeyData_t;
    143          
    144          //should match APSME_LinkKeyData_t;
    145          typedef struct
    146          {
    147            uint8               key[SEC_KEY_LEN];
    148            APSME_LinkKeyData_t apsmelkd;
    149          } ZDSecMgrLinkKeyData_t;
    150          
    151          typedef struct
    152          {
    153            uint16                ami;
    154            ZDSecMgrLinkKeyData_t lkd;
    155            ZDSecMgr_Authentication_Option authenticateOption;
    156          } ZDSecMgrEntry_t;
    157          
    158          typedef struct
    159          {
    160            ZDSecMgrEntry_t* entry;
    161            uint16           parentAddr;
    162            uint8            secure;
    163            uint8            state;
    164            uint8            cntr;
    165            //uint8          next;
    166          } ZDSecMgrCtrl_t;
    167          
    168          typedef struct
    169          {
    170            uint16          nwkAddr;
    171            uint8*          extAddr;
    172            uint16          parentAddr;
    173            uint8           secure;
    174            uint8           devStatus;
    175            ZDSecMgrCtrl_t* ctrl;
    176          } ZDSecMgrDevice_t;
    177          
    178          /******************************************************************************
    179           * LOCAL VARIABLES
    180           */
    181          #if 0 // Taken out because the following functionality is only used for test
    182                // purpose. A more efficient (above) way is used. It can be put
    183                // back in if customers request for a white/black list feature.
    184          uint8 ZDSecMgrStoredDeviceList[ZDSECMGR_STORED_DEVICES][Z_EXTADDR_LEN] =
    185          {
    186            { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    187            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
    188            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    189          };
    190          #endif
    191          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    192          uint8 ZDSecMgrTCExtAddr[Z_EXTADDR_LEN]=
   \                     ZDSecMgrTCExtAddr:
   \   000000                DS 8
   \   000008                REQUIRE __INIT_XDATA_Z
    193            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    194          

   \                                 In  segment XDATA_I, align 1, keep-with-next
    195          uint8 ZDSecMgrTCMasterKey[SEC_KEY_LEN] =
   \                     ZDSecMgrTCMasterKey:
   \   000000                DS 16
   \   000010                REQUIRE `?<Initializer for ZDSecMgrTCMasterKey>`
   \   000010                REQUIRE __INIT_XDATA_I
    196            {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    197             0x89,0x67,0x45,0x23,0x01,0xEF,0xCD,0xAB};
    198          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    199          uint8 ZDSecMgrTCAuthenticated = FALSE;
   \                     ZDSecMgrTCAuthenticated:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    200          uint8 ZDSecMgrTCDataLoaded    = FALSE;
   \                     ZDSecMgrTCDataLoaded:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    201          
    202          //devtag.pro.security - remove this
    203          #if ( ZDSECMGR_PRECONFIG_MAX != 0 )
    204          const ZDSecMgrPreConfigData_t ZDSecMgrPreConfigData[ZDSECMGR_PRECONFIG_MAX] =
    205          {
    206            //---------------------------------------------------------------------------
    207            // DEVICE A
    208            //---------------------------------------------------------------------------
    209            {
    210              // extAddr
    211              {0x7C,0x01,0x12,0x13,0x14,0x15,0x16,0x17},
    212          
    213              // key
    214              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    215               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    216            },
    217            //---------------------------------------------------------------------------
    218            // DEVICE B
    219            //---------------------------------------------------------------------------
    220            {
    221              // extAddr
    222              {0x84,0x03,0x00,0x00,0x00,0x4B,0x12,0x00},
    223          
    224              // key
    225              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    226               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    227            },
    228            //---------------------------------------------------------------------------
    229            // DEVICE C
    230            //---------------------------------------------------------------------------
    231            {
    232              // extAddr
    233              {0x3E,0x01,0x12,0x13,0x14,0x15,0x16,0x17},
    234          
    235              // key
    236              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    237               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    238            },
    239          };
    240          #endif // ( ZDSECMGR_PRECONFIG_MAX != 0 )
    241          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    242          ZDSecMgrMasterKeyData_t* ZDSecMgrMasterKeyData = NULL;
   \                     ZDSecMgrMasterKeyData:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    243          ZDSecMgrEntry_t*         ZDSecMgrEntries       = NULL;
   \                     ZDSecMgrEntries:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    244          ZDSecMgrCtrl_t*          ZDSecMgrCtrlData      = NULL;
   \                     ZDSecMgrCtrlData:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    245          void ZDSecMgrAddrMgrUpdate( uint16 ami, uint16 nwkAddr );
    246          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
    247          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    248          uint8 ZDSecMgrPermitJoiningEnabled;
   \                     ZDSecMgrPermitJoiningEnabled:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    249          uint8 ZDSecMgrPermitJoiningTimed;
   \                     ZDSecMgrPermitJoiningTimed:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    250          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    251          APSME_TCLinkKey_t TrustCenterLinkKey;
   \                     TrustCenterLinkKey:
   \   000000                DS 32
   \   000020                REQUIRE __INIT_XDATA_Z
    252          
    253          /******************************************************************************
    254           * PRIVATE FUNCTIONS
    255           *
    256           *   ZDSecMgrMasterKeyInit
    257           *   ZDSecMgrAddrStore
    258           *   ZDSecMgrExtAddrStore
    259           *   ZDSecMgrExtAddrLookup
    260           *   ZDSecMgrMasterKeyLookup
    261           *   ZDSecMgrMasterKeyStore
    262           *   ZDSecMgrEntryInit
    263           *   ZDSecMgrEntryLookup
    264           *   ZDSecMgrEntryLookupAMI
    265           *   ZDSecMgrEntryLookupExt
    266           *   ZDSecMgrEntryFree
    267           *   ZDSecMgrEntryNew
    268           *   ZDSecMgrCtrlInit
    269           *   ZDSecMgrCtrlRelease
    270           *   ZDSecMgrCtrlLookup
    271           *   ZDSecMgrCtrlSet
    272           *   ZDSecMgrCtrlAdd
    273           *   ZDSecMgrCtrlTerm
    274           *   ZDSecMgrCtrlReset
    275           *   ZDSecMgrMasterKeyLoad
    276           *   ZDSecMgrAppKeyGet
    277           *   ZDSecMgrAppKeyReq
    278           *   ZDSecMgrEstablishKey
    279           *   ZDSecMgrSendMasterKey
    280           *   ZDSecMgrSendNwkKey
    281           *   ZDSecMgrDeviceEntryRemove
    282           *   ZDSecMgrDeviceEntryAdd
    283           *   ZDSecMgrDeviceCtrlHandler
    284           *   ZDSecMgrDeviceCtrlSetup
    285           *   ZDSecMgrDeviceCtrlUpdate
    286           *   ZDSecMgrDeviceRemove
    287           *   ZDSecMgrDeviceValidateSKKE
    288           *   ZDSecMgrDeviceValidateRM
    289           *   ZDSecMgrDeviceValidateCM
    290           *   ZDSecMgrDeviceValidate
    291           *   ZDSecMgrDeviceJoin
    292           *   ZDSecMgrDeviceJoinDirect
    293           *   ZDSecMgrDeviceJoinFwd
    294           *   ZDSecMgrDeviceNew
    295           *   ZDSecMgrAssocDeviceAuth
    296           *   ZDSecMgrAuthInitiate
    297           *   ZDSecMgrAuthNwkKey
    298           *   APSME_TCLinkKeyInit
    299           *   APSME_IsDefaultTCLK
    300           */
    301          //-----------------------------------------------------------------------------
    302          // master key data
    303          //-----------------------------------------------------------------------------
    304          void ZDSecMgrMasterKeyInit( void );
    305          
    306          //-----------------------------------------------------------------------------
    307          // address management
    308          //-----------------------------------------------------------------------------
    309          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    310          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    311          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami );
    312          
    313          //-----------------------------------------------------------------------------
    314          // MASTER key data
    315          //-----------------------------------------------------------------------------
    316          ZStatus_t ZDSecMgrMasterKeyLookup( uint16 ami, uint8** key );
    317          ZStatus_t ZDSecMgrMasterKeyStore( uint16 ami, uint8* key );
    318          
    319          //-----------------------------------------------------------------------------
    320          // entry data
    321          //-----------------------------------------------------------------------------
    322          void ZDSecMgrEntryInit(uint8 state);
    323          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry );
    324          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry );
    325          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry );
    326          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry );
    327          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry );
    328          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option );
    329          
    330          //-----------------------------------------------------------------------------
    331          // control data
    332          //-----------------------------------------------------------------------------
    333          void ZDSecMgrCtrlInit( void );
    334          void ZDSecMgrCtrlRelease( ZDSecMgrCtrl_t* ctrl );
    335          void ZDSecMgrCtrlLookup( ZDSecMgrEntry_t* entry, ZDSecMgrCtrl_t** ctrl );
    336          void ZDSecMgrCtrlSet( ZDSecMgrDevice_t* device,
    337                                ZDSecMgrEntry_t*  entry,
    338                                ZDSecMgrCtrl_t*   ctrl );
    339          ZStatus_t ZDSecMgrCtrlAdd( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t*  entry );
    340          void ZDSecMgrCtrlTerm( ZDSecMgrEntry_t* entry );
    341          ZStatus_t ZDSecMgrCtrlReset( ZDSecMgrDevice_t* device,
    342                                       ZDSecMgrEntry_t*  entry );
    343          
    344          //-----------------------------------------------------------------------------
    345          // key support
    346          //-----------------------------------------------------------------------------
    347          ZStatus_t ZDSecMgrMasterKeyLoad( uint8* extAddr, uint8* key );
    348          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
    349                                       uint8*  initExtAddr,
    350                                       uint16  partNwkAddr,
    351                                       uint8*  partExtAddr,
    352                                       uint8** key,
    353                                       uint8*  keyType );
    354          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind );
    355          ZStatus_t ZDSecMgrEstablishKey( ZDSecMgrDevice_t* device );
    356          ZStatus_t ZDSecMgrSendMasterKey( ZDSecMgrDevice_t* device );
    357          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device );
    358          
    359          //-----------------------------------------------------------------------------
    360          // device entry
    361          //-----------------------------------------------------------------------------
    362          void ZDSecMgrDeviceEntryRemove( ZDSecMgrEntry_t* entry );
    363          ZStatus_t ZDSecMgrDeviceEntryAdd( ZDSecMgrDevice_t* device, uint16 ami );
    364          #if defined NV_RESTORE
    365          static void ZDSecMgrWriteNV(void);
    366          static void ZDSecMgrRestoreFromNV(void);
    367          #endif
    368          
    369          //-----------------------------------------------------------------------------
    370          // device control
    371          //-----------------------------------------------------------------------------
    372          void ZDSecMgrDeviceCtrlHandler( ZDSecMgrDevice_t* device );
    373          void ZDSecMgrDeviceCtrlSetup( ZDSecMgrDevice_t* device );
    374          void ZDSecMgrDeviceCtrlUpdate( uint8* extAddr, uint8 state );
    375          
    376          //-----------------------------------------------------------------------------
    377          // device management
    378          //-----------------------------------------------------------------------------
    379          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device );
    380          ZStatus_t ZDSecMgrDeviceValidateSKKE( ZDSecMgrDevice_t* device );
    381          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device );
    382          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device );
    383          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device );
    384          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device );
    385          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device );
    386          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device );
    387          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* device );
    388          
    389          //-----------------------------------------------------------------------------
    390          // association management
    391          //-----------------------------------------------------------------------------
    392          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc );
    393          
    394          //-----------------------------------------------------------------------------
    395          // authentication management
    396          //-----------------------------------------------------------------------------
    397          void ZDSecMgrAuthInitiate( uint8* responder );
    398          void ZDSecMgrAuthNwkKey( void );
    399          
    400          //-----------------------------------------------------------------------------
    401          // APSME function
    402          //-----------------------------------------------------------------------------
    403          void APSME_TCLinkKeyInit( void );
    404          uint8 APSME_IsDefaultTCLK( uint8 *extAddr );
    405          
    406          /******************************************************************************
    407           * @fn          ZDSecMgrMasterKeyInit                     ]
    408           *
    409           * @brief       Initialize master key data.
    410           *
    411           * @param       none
    412           *
    413           * @return      none
    414           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    415          void ZDSecMgrMasterKeyInit( void )
   \                     ZDSecMgrMasterKeyInit:
    416          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    417            uint16 index;
    418            uint16 size;
    419          
    420            // allocate MASTER key data
    421            size = (short)( sizeof(ZDSecMgrMasterKeyData_t) * ZDSECMGR_MASTERKEY_MAX );
    422          
    423            ZDSecMgrMasterKeyData = osal_mem_alloc( size );
   \   000004                ; Setup parameters for call to function osal_mem_alloc
   \   000004   7A36         MOV     R2,#0x36
   \   000006   7B00         MOV     R3,#0x0
   \   000008   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00000B   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   00000E   12....       LCALL   ??Subroutine78_0 & 0xFFFF
    424          
    425            // initialize MASTER key data
    426            if ( ZDSecMgrMasterKeyData != NULL )
   \                     ??CrossCallReturnLabel_121:
   \   000011   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   000014   12....       LCALL   ??Subroutine83_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_162:
   \   000017   6025         JZ      ??ZDSecMgrMasterKeyInit_0
    427            {
    428              for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX; index++ )
   \   000019   7800         MOV     R0,#0x0
   \   00001B   7900         MOV     R1,#0x0
    429              {
    430                ZDSecMgrMasterKeyData[index].ami = INVALID_NODE_ADDR;
   \                     ??ZDSecMgrMasterKeyInit_1:
   \   00001D   E8           MOV     A,R0
   \   00001E   FA           MOV     R2,A
   \   00001F   E9           MOV     A,R1
   \   000020   FB           MOV     R3,A
   \   000021   EA           MOV     A,R2
   \   000022   75F012       MOV     B,#0x12
   \   000025   A4           MUL     AB
   \   000026   FA           MOV     R2,A
   \   000027   ACF0         MOV     R4,B
   \   000029   75F012       MOV     B,#0x12
   \   00002C   EB           MOV     A,R3
   \   00002D   A4           MUL     AB
   \   00002E   2C           ADD     A,R4
   \   00002F   FB           MOV     R3,A
   \   000030   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   000033   12....       LCALL   ?Subroutine39 & 0xFFFF
    431              }
   \                     ??CrossCallReturnLabel_27:
   \   000036   7001         JNZ     ??ZDSecMgrMasterKeyInit_2
   \   000038   09           INC     R1
   \                     ??ZDSecMgrMasterKeyInit_2:
   \   000039   12....       LCALL   ?Subroutine49 & 0xFFFF
    432            }
   \                     ??CrossCallReturnLabel_44:
   \   00003C   40DF         JC      ??ZDSecMgrMasterKeyInit_1
    433          }
   \                     ??ZDSecMgrMasterKeyInit_0:
   \   00003E   02....       LJMP    ??Subroutine77_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   000003   74FE         MOV     A,#-0x2
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   04           INC     A
   \   000008   F0           MOVX    @DPTR,A
   \   000009   08           INC     R0
   \   00000A   E8           MOV     A,R0
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine49:
   \   000000   C3           CLR     C
   \   000001   9403         SUBB    A,#0x3
   \   000003   E9           MOV     A,R1
   \   000004   9400         SUBB    A,#0x0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine61:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2A           ADD     A,R2
   \   000002   FC           MOV     R4,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   3B           ADDC    A,R3
   \   000006   8C82         MOV     DPL,R4
   \   000008   F583         MOV     DPH,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine58:
   \   000000   12....       LCALL   ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_216:
   \   000003   E8           MOV     A,R0
   \   000004   49           ORL     A,R1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine77_0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine78_0:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine83_0:
   \   000000   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_180:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine63:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   22           RET
    434          //devtag.pro.security
    435          #if 0
    436          void ZDSecMgrMasterKeyInit( void )
    437          {
    438            uint16         index;
    439            uint16         size;
    440            AddrMgrEntry_t entry;
    441          
    442          
    443            // allocate MASTER key data
    444            size = (short)( sizeof(ZDSecMgrMasterKeyData_t) * ZDSECMGR_MASTERKEY_MAX );
    445          
    446            ZDSecMgrMasterKeyData = osal_mem_alloc( size );
    447          
    448            // initialize MASTER key data
    449            if ( ZDSecMgrMasterKeyData != NULL )
    450            {
    451              for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX; index++ )
    452              {
    453                ZDSecMgrMasterKeyData[index].ami = INVALID_NODE_ADDR;
    454              }
    455          
    456              // check if preconfigured keys are enabled
    457              //-------------------------------------------------------------------------
    458              #if ( ZDSECMGR_PRECONFIG_MAX != 0 )
    459              //-------------------------------------------------------------------------
    460              if ( zgPreConfigKeys == TRUE )
    461              {
    462                // sync configured data
    463                entry.user = ADDRMGR_USER_SECURITY;
    464          
    465                for ( index = 0; index < ZDSECMGR_PRECONFIG_MAX; index++ )
    466                {
    467                  // check for Address Manager entry
    468                  AddrMgrExtAddrSet( entry.extAddr,
    469                                     (uint8*)ZDSecMgrPreConfigData[index].extAddr );
    470          
    471                  if ( AddrMgrEntryLookupExt( &entry ) != TRUE )
    472                  {
    473                    // update Address Manager
    474                    AddrMgrEntryUpdate( &entry );
    475                  }
    476          
    477                  if ( entry.index != INVALID_NODE_ADDR )
    478                  {
    479                    // sync MASTER keys with Address Manager index
    480                    ZDSecMgrMasterKeyData[index].ami = entry.index;
    481          
    482                    osal_memcpy( ZDSecMgrMasterKeyData[index].key,
    483                             (void*)ZDSecMgrPreConfigData[index].key, SEC_KEY_LEN );
    484                  }
    485                }
    486              }
    487              //-------------------------------------------------------------------------
    488              #endif // ( ZDSECMGR_PRECONFIG_MAX != 0 )
    489              //-------------------------------------------------------------------------
    490            }
    491          }
    492          #endif
    493          
    494          /******************************************************************************
    495           * @fn          ZDSecMgrAddrStore
    496           *
    497           * @brief       Store device addresses.
    498           *
    499           * @param       nwkAddr - [in] NWK address
    500           * @param       extAddr - [in] EXT address
    501           * @param       ami     - [out] Address Manager index
    502           *
    503           * @return      ZStatus_t
    504           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    505          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrAddrStore:
    506          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    507            ZStatus_t      status;
    508            AddrMgrEntry_t entry;
    509          
    510          
    511            // add entry
    512            entry.user    = ADDRMGR_USER_SECURITY;
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   7402         MOV     A,#0x2
   \   000012   F0           MOVX    @DPTR,A
    513            entry.nwkAddr = nwkAddr;
   \   000013   14           DEC     A
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   12....       LCALL   ??Subroutine78_0 & 0xFFFF
    514            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \                     ??CrossCallReturnLabel_122:
   \   00001A                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   00001A   7403         MOV     A,#0x3
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   AA82         MOV     R2,DPL
   \   000021   AB83         MOV     R3,DPH
   \   000023   12....       LCALL   `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
   \   000026   7416         MOV     A,#0x16
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   12....       LCALL   ?Subroutine47 & 0xFFFF
    515          
    516            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \                     ??CrossCallReturnLabel_40:
   \   00002E   12....       LCALL   `??AddrMgrEntryUpdate::?relay`; Banked call to: AddrMgrEntryUpdate
   \   000031   E9           MOV     A,R1
   \   000032   6401         XRL     A,#0x1
   \   000034   700A         JNZ     ??ZDSecMgrAddrStore_0
    517            {
    518              // return successful results
    519              *ami   = entry.index;
   \   000036   740B         MOV     A,#0xb
   \   000038   12....       LCALL   ?XSTACK_DISP0_8
   \   00003B   12....       LCALL   ?Subroutine27 & 0xFFFF
    520              status = ZSuccess;
    521            }
   \                     ??CrossCallReturnLabel_14:
   \   00003E   8008         SJMP    ??CrossCallReturnLabel_17
    522            else
    523            {
    524              // return failed results
    525              *ami   = entry.index;
   \                     ??ZDSecMgrAddrStore_0:
   \   000040   740B         MOV     A,#0xb
   \   000042   12....       LCALL   ?XSTACK_DISP0_8
   \   000045   12....       LCALL   ?Subroutine28 & 0xFFFF
    526              status = ZNwkUnknownDevice;
    527            }
    528          
    529            return status;
   \                     ??CrossCallReturnLabel_17:
   \   000048   02....       LJMP    ?Subroutine9 & 0xFFFF
    530          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine47:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FE           MOV     R6,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FF           MOV     R7,A
   \   000005                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000005                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000005   AA..         MOV     R2,?XSP + 0
   \   000007   AB..         MOV     R3,?XSP + 1
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_203:
   \   000003   79C8         MOV     R1,#-0x38
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_202:
   \   000003   7900         MOV     R1,#0x0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   740D         MOV     A,#0xd
   \   000002   02....       LJMP    ??Subroutine71_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine71_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine72_0
   \   000003                ; // Fall through to label ??Subroutine72_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine72_0:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine54:
   \   000000   12....       LCALL   ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_214:
   \   000003   8E82         MOV     DPL,R6
   \   000005   8F83         MOV     DPH,R7
   \   000007                REQUIRE ??Subroutine90_0
   \   000007                ; // Fall through to label ??Subroutine90_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine90_0:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET
    531          
    532          /******************************************************************************
    533           * @fn          ZDSecMgrExtAddrStore
    534           *
    535           * @brief       Store EXT address.
    536           *
    537           * @param       extAddr - [in] EXT address
    538           * @param       ami     - [out] Address Manager index
    539           *
    540           * @return      ZStatus_t
    541           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    542          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrStore:
    543          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    544            ZStatus_t      status;
    545            AddrMgrEntry_t entry;
    546          
    547          
    548            // add entry
    549            entry.user    = ADDRMGR_USER_SECURITY;
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   7402         MOV     A,#0x2
   \   000012   F0           MOVX    @DPTR,A
    550            entry.nwkAddr = nwkAddr;
   \   000013   14           DEC     A
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   12....       LCALL   ??Subroutine78_0 & 0xFFFF
    551            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \                     ??CrossCallReturnLabel_123:
   \   00001A                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   00001A   7403         MOV     A,#0x3
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   AA82         MOV     R2,DPL
   \   000021   AB83         MOV     R3,DPH
   \   000023   12....       LCALL   `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
   \   000026   7416         MOV     A,#0x16
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   12....       LCALL   ?Subroutine47 & 0xFFFF
    552          
    553            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \                     ??CrossCallReturnLabel_41:
   \   00002E   12....       LCALL   `??AddrMgrEntryUpdate::?relay`; Banked call to: AddrMgrEntryUpdate
   \   000031   E9           MOV     A,R1
   \   000032   6401         XRL     A,#0x1
   \   000034   700A         JNZ     ??ZDSecMgrExtAddrStore_0
    554            {
    555              // return successful results
    556              *ami   = entry.index;
   \   000036   740B         MOV     A,#0xb
   \   000038   12....       LCALL   ?XSTACK_DISP0_8
   \   00003B   12....       LCALL   ?Subroutine27 & 0xFFFF
    557              status = ZSuccess;
    558            }
   \                     ??CrossCallReturnLabel_15:
   \   00003E   8008         SJMP    ??CrossCallReturnLabel_18
    559            else
    560            {
    561              // return failed results
    562              *ami   = entry.index;
   \                     ??ZDSecMgrExtAddrStore_0:
   \   000040   740B         MOV     A,#0xb
   \   000042   12....       LCALL   ?XSTACK_DISP0_8
   \   000045   12....       LCALL   ?Subroutine28 & 0xFFFF
    563              status = ZNwkUnknownDevice;
    564            }
    565          
    566            return status;
   \                     ??CrossCallReturnLabel_18:
   \   000048   80..         SJMP    ?Subroutine9
    567          }
    568          
    569          /******************************************************************************
    570           * @fn          ZDSecMgrExtAddrLookup
    571           *
    572           * @brief       Lookup index for specified EXT address.
    573           *
    574           * @param       extAddr - [in] EXT address
    575           * @param       ami     - [out] Address Manager index
    576           *
    577           * @return      ZStatus_t
    578           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    579          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrLookup:
    580          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
    581            ZStatus_t      status;
    582            AddrMgrEntry_t entry;
    583          
    584          
    585            // lookup entry
    586            entry.user = ADDRMGR_USER_SECURITY;
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   7402         MOV     A,#0x2
   \   000016   F0           MOVX    @DPTR,A
    587            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \   000017                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000017   EA           MOV     A,R2
   \   000018   FC           MOV     R4,A
   \   000019   EB           MOV     A,R3
   \   00001A   FD           MOV     R5,A
   \   00001B   7403         MOV     A,#0x3
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   AA82         MOV     R2,DPL
   \   000022   AB83         MOV     R3,DPH
   \   000024   12....       LCALL   `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
    588          
    589            if ( AddrMgrEntryLookupExt( &entry ) == TRUE )
   \   000027                ; Setup parameters for call to function AddrMgrEntryLookupExt
   \   000027   AA..         MOV     R2,?XSP + 0
   \   000029   AB..         MOV     R3,?XSP + 1
   \   00002B   12....       LCALL   `??AddrMgrEntryLookupExt::?relay`; Banked call to: AddrMgrEntryLookupExt
   \   00002E   E9           MOV     A,R1
   \   00002F   6401         XRL     A,#0x1
   \   000031   700A         JNZ     ??ZDSecMgrExtAddrLookup_0
    590            {
    591              // return successful results
    592              *ami   = entry.index;
   \   000033   740B         MOV     A,#0xb
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   12....       LCALL   ?Subroutine27 & 0xFFFF
    593              status = ZSuccess;
    594            }
   \                     ??CrossCallReturnLabel_16:
   \   00003B   8008         SJMP    ??CrossCallReturnLabel_19
    595            else
    596            {
    597              // return failed results
    598              *ami   = entry.index;
   \                     ??ZDSecMgrExtAddrLookup_0:
   \   00003D   740B         MOV     A,#0xb
   \   00003F   12....       LCALL   ?XSTACK_DISP0_8
   \   000042   12....       LCALL   ?Subroutine28 & 0xFFFF
    599              status = ZNwkUnknownDevice;
    600            }
    601          
    602            return status;
   \                     ??CrossCallReturnLabel_19:
   \   000045                REQUIRE ?Subroutine9
   \   000045                ; // Fall through to label ?Subroutine9
    603          }
    604          
    605          /******************************************************************************
    606           * @fn          ZDSecMgrMasterKeyLookup
    607           *
    608           * @brief       Lookup MASTER key for specified address index.
    609           *
    610           * @param       ami - [in] Address Manager index
    611           * @param       key - [out] valid MASTER key
    612           *
    613           * @return      ZStatus_t
    614           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    615          ZStatus_t ZDSecMgrMasterKeyLookup( uint16 ami, uint8** key )
   \                     ZDSecMgrMasterKeyLookup:
    616          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   12....       LCALL   ?Subroutine55 & 0xFFFF
    617            ZStatus_t status;
    618            uint16    index;
    619          
    620          
    621            // initialize results
    622            *key   = NULL;
    623            status = ZNwkUnknownDevice;
    624          
    625            // verify data is available
    626            if ( ZDSecMgrMasterKeyData != NULL )
   \                     ??CrossCallReturnLabel_77:
   \   000008   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   00000B   12....       LCALL   ??Subroutine83_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_163:
   \   00000E   6043         JZ      ??ZDSecMgrMasterKeyLookup_0
    627            {
    628              for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX ; index++ )
   \   000010   7800         MOV     R0,#0x0
   \   000012   7900         MOV     R1,#0x0
    629              {
    630                if ( ZDSecMgrMasterKeyData[index].ami == ami )
   \                     ??ZDSecMgrMasterKeyLookup_1:
   \   000014   E8           MOV     A,R0
   \   000015   FC           MOV     R4,A
   \   000016   E9           MOV     A,R1
   \   000017   FD           MOV     R5,A
   \   000018   EC           MOV     A,R4
   \   000019   75F012       MOV     B,#0x12
   \   00001C   A4           MUL     AB
   \   00001D   FC           MOV     R4,A
   \   00001E   85F0..       MOV     ?V1,B
   \   000021   75F012       MOV     B,#0x12
   \   000024   ED           MOV     A,R5
   \   000025   A4           MUL     AB
   \   000026   25..         ADD     A,?V1
   \   000028   FD           MOV     R5,A
   \   000029   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   2C           ADD     A,R4
   \   00002E   FC           MOV     R4,A
   \   00002F   A3           INC     DPTR
   \   000030   E0           MOVX    A,@DPTR
   \   000031   3D           ADDC    A,R5
   \   000032   FD           MOV     R5,A
   \   000033   8C82         MOV     DPL,R4
   \   000035   8D83         MOV     DPH,R5
   \   000037   E0           MOVX    A,@DPTR
   \   000038   6A           XRL     A,R2
   \   000039   7003         JNZ     ??ZDSecMgrMasterKeyLookup_2
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   6B           XRL     A,R3
   \                     ??ZDSecMgrMasterKeyLookup_2:
   \   00003E   7009         JNZ     ??CrossCallReturnLabel_71
    631                {
    632                  // return successful results
    633                  *key   = ZDSecMgrMasterKeyData[index].key;
   \   000040   EC           MOV     A,R4
   \   000041   2402         ADD     A,#0x2
   \   000043   F8           MOV     R0,A
   \   000044   E4           CLR     A
   \   000045   3D           ADDC    A,R5
   \   000046   12....       LCALL   ?Subroutine17 & 0xFFFF
    634                  status = ZSuccess;
    635          
    636                  // break from loop
    637                  index  = ZDSECMGR_MASTERKEY_MAX;
    638                }
    639              }
   \                     ??CrossCallReturnLabel_71:
   \   000049   08           INC     R0
   \   00004A   E8           MOV     A,R0
   \   00004B   7001         JNZ     ??ZDSecMgrMasterKeyLookup_3
   \   00004D   09           INC     R1
   \                     ??ZDSecMgrMasterKeyLookup_3:
   \   00004E   12....       LCALL   ?Subroutine49 & 0xFFFF
    640            }
   \                     ??CrossCallReturnLabel_45:
   \   000051   40C1         JC      ??ZDSecMgrMasterKeyLookup_1
    641          
    642            return status;
   \                     ??ZDSecMgrMasterKeyLookup_0:
   \   000053                REQUIRE ?Subroutine11
   \   000053                ; // Fall through to label ?Subroutine11
    643          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   A9..         MOV     R1,?V0
   \   000002   02....       LJMP    ??Subroutine86_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine55:
   \   000000   EC           MOV     A,R4
   \   000001   FE           MOV     R6,A
   \   000002   ED           MOV     A,R5
   \   000003   FF           MOV     R7,A
   \   000004   8E82         MOV     DPL,R6
   \   000006   8F83         MOV     DPH,R7
   \   000008                REQUIRE ??Subroutine64_0
   \   000008                ; // Fall through to label ??Subroutine64_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine64_0:
   \   000000   E4           CLR     A
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   F0           MOVX    @DPTR,A
   \   000004   75..C8       MOV     ?V0,#-0x38
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   F9           MOV     R1,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005                REQUIRE ??Subroutine65_0
   \   000005                ; // Fall through to label ??Subroutine65_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine65_0:
   \   000000   12....       LCALL   ??Subroutine90_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_204:
   \   000003   75..00       MOV     ?V0,#0x0
   \   000006   7803         MOV     R0,#0x3
   \   000008   7900         MOV     R1,#0x0
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine86_0:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    644          
    645          /******************************************************************************
    646           * @fn          ZDSecMgrMasterKeyStore
    647           *
    648           * @brief       Store MASTER key for specified address index.
    649           *
    650           * @param       ami - [in] Address Manager index
    651           * @param       key - [in] valid key to store
    652           *
    653           * @return      ZStatus_t
    654           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    655          ZStatus_t ZDSecMgrMasterKeyStore( uint16 ami, uint8* key )
   \                     ZDSecMgrMasterKeyStore:
    656          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V4,R2
   \   000007   8B..         MOV     ?V5,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
    657            ZStatus_t status;
    658            uint16    index;
    659            uint8*    entry;
    660          
    661          
    662            // initialize results
    663            status = ZNwkUnknownDevice;
   \   00000D   7CC8         MOV     R4,#-0x38
    664          
    665            // verify data is available
    666            if ( ZDSecMgrMasterKeyData != NULL )
   \   00000F   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   000012   12....       LCALL   ??Subroutine83_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_164:
   \   000015   606F         JZ      ??ZDSecMgrMasterKeyStore_0
    667            {
    668              for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX ; index++ )
   \   000017   7800         MOV     R0,#0x0
   \   000019   7900         MOV     R1,#0x0
    669              {
    670                if ( ZDSecMgrMasterKeyData[index].ami == INVALID_NODE_ADDR )
   \                     ??ZDSecMgrMasterKeyStore_1:
   \   00001B   E8           MOV     A,R0
   \   00001C   FA           MOV     R2,A
   \   00001D   E9           MOV     A,R1
   \   00001E   FB           MOV     R3,A
   \   00001F   EA           MOV     A,R2
   \   000020   75F012       MOV     B,#0x12
   \   000023   A4           MUL     AB
   \   000024   FA           MOV     R2,A
   \   000025   ADF0         MOV     R5,B
   \   000027   75F012       MOV     B,#0x12
   \   00002A   EB           MOV     A,R3
   \   00002B   A4           MUL     AB
   \   00002C   2D           ADD     A,R5
   \   00002D   FB           MOV     R3,A
   \   00002E   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   000031   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   000034   64FE         XRL     A,#0xfe
   \   000036   7003         JNZ     ??ZDSecMgrMasterKeyStore_2
   \   000038   A3           INC     DPTR
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   F4           CPL     A
   \                     ??ZDSecMgrMasterKeyStore_2:
   \   00003B   703F         JNZ     ??ZDSecMgrMasterKeyStore_3
    671                {
    672                  // store EXT address index
    673                  ZDSecMgrMasterKeyData[index].ami = ami;
   \   00003D   8A82         MOV     DPL,R2
   \   00003F   8B83         MOV     DPH,R3
   \   000041   E5..         MOV     A,?V4
   \   000043   F0           MOVX    @DPTR,A
   \   000044   A3           INC     DPTR
   \   000045   E5..         MOV     A,?V5
   \   000047   F0           MOVX    @DPTR,A
    674          
    675                  entry = ZDSecMgrMasterKeyData[index].key;
   \   000048   EA           MOV     A,R2
   \   000049   2402         ADD     A,#0x2
   \   00004B   FA           MOV     R2,A
   \   00004C   5001         JNC     ??ZDSecMgrMasterKeyStore_4
   \   00004E   0B           INC     R3
    676          
    677                  if ( key != NULL )
   \                     ??ZDSecMgrMasterKeyStore_4:
   \   00004F   EE           MOV     A,R6
   \   000050   4F           ORL     A,R7
   \   000051   601A         JZ      ??ZDSecMgrMasterKeyStore_5
    678                  {
    679                    osal_memcpy( entry, key,  SEC_KEY_LEN );
   \   000053                ; Setup parameters for call to function osal_memcpy
   \   000053   8E..         MOV     ?V0,R6
   \   000055   8F..         MOV     ?V1,R7
   \   000057   75..00       MOV     ?V2,#0x0
   \   00005A   78..         MOV     R0,#?V0
   \   00005C   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00005F   7C10         MOV     R4,#0x10
   \   000061   7D00         MOV     R5,#0x0
   \   000063   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000066   7403         MOV     A,#0x3
   \   000068   12....       LCALL   ?DEALLOC_XSTACK8
   \   00006B   8009         SJMP    ??ZDSecMgrMasterKeyStore_6
    680                  }
    681                  else
    682                  {
    683                    osal_memset( entry, 0, SEC_KEY_LEN );
   \                     ??ZDSecMgrMasterKeyStore_5:
   \   00006D                ; Setup parameters for call to function osal_memset
   \   00006D   7C10         MOV     R4,#0x10
   \   00006F   7D00         MOV     R5,#0x0
   \   000071   7900         MOV     R1,#0x0
   \   000073   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
    684                  }
    685          
    686                  // return successful results
    687                  status = ZSuccess;
   \                     ??ZDSecMgrMasterKeyStore_6:
   \   000076   7C00         MOV     R4,#0x0
    688          
    689                  // break from loop
    690                  index  = ZDSECMGR_MASTERKEY_MAX;
   \   000078   7803         MOV     R0,#0x3
   \   00007A   7900         MOV     R1,#0x0
    691                }
    692              }
   \                     ??ZDSecMgrMasterKeyStore_3:
   \   00007C   08           INC     R0
   \   00007D   E8           MOV     A,R0
   \   00007E   7001         JNZ     ??ZDSecMgrMasterKeyStore_7
   \   000080   09           INC     R1
   \                     ??ZDSecMgrMasterKeyStore_7:
   \   000081   12....       LCALL   ?Subroutine49 & 0xFFFF
    693            }
   \                     ??CrossCallReturnLabel_46:
   \   000084   4095         JC      ??ZDSecMgrMasterKeyStore_1
    694          
    695            return status;
   \                     ??ZDSecMgrMasterKeyStore_0:
   \   000086   EC           MOV     A,R4
   \   000087   F9           MOV     R1,A
   \   000088                REQUIRE ?Subroutine3
   \   000088                ; // Fall through to label ?Subroutine3
    696          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   7F06         MOV     R7,#0x6
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000   12....       LCALL   ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine57:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2A           ADD     A,R2
   \   000002   FA           MOV     R2,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   3B           ADDC    A,R3
   \   000006   FB           MOV     R3,A
   \   000007   8A82         MOV     DPL,R2
   \   000009   8B83         MOV     DPH,R3
   \   00000B   22           RET
    697          
    698          /******************************************************************************
    699           * @fn          ZDSecMgrEntryInit
    700           *
    701           * @brief       Initialize entry sub module
    702           *
    703           * @param       state - device initialization state
    704           *
    705           * @return      none
    706           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    707          void ZDSecMgrEntryInit(uint8 state)
   \                     ZDSecMgrEntryInit:
    708          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    709            if (ZDSecMgrEntries == NULL)
   \   000004   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000007   12....       LCALL   ??Subroutine83_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_165:
   \   00000A   703A         JNZ     ??ZDSecMgrEntryInit_0
    710            {
    711              uint16 index;
    712          
    713              if ((ZDSecMgrEntries = osal_mem_alloc(sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX)) == NULL)
   \   00000C                ; Setup parameters for call to function osal_mem_alloc
   \   00000C   7A57         MOV     R2,#0x57
   \   00000E   7B00         MOV     R3,#0x0
   \   000010   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000013   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000016   12....       LCALL   ??Subroutine78_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_124:
   \   000019   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00001C   12....       LCALL   ??Subroutine83_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_166:
   \   00001F   6025         JZ      ??ZDSecMgrEntryInit_0
    714              {
    715                return;
    716              }
    717          
    718              for (index = 0; index < ZDSECMGR_ENTRY_MAX; index++)
   \   000021   7800         MOV     R0,#0x0
   \   000023   7900         MOV     R1,#0x0
    719              {
    720                ZDSecMgrEntries[index].ami = INVALID_NODE_ADDR;
   \                     ??ZDSecMgrEntryInit_1:
   \   000025   E8           MOV     A,R0
   \   000026   FA           MOV     R2,A
   \   000027   E9           MOV     A,R1
   \   000028   FB           MOV     R3,A
   \   000029   EA           MOV     A,R2
   \   00002A   75F01D       MOV     B,#0x1d
   \   00002D   A4           MUL     AB
   \   00002E   FA           MOV     R2,A
   \   00002F   ACF0         MOV     R4,B
   \   000031   75F01D       MOV     B,#0x1d
   \   000034   EB           MOV     A,R3
   \   000035   A4           MUL     AB
   \   000036   2C           ADD     A,R4
   \   000037   FB           MOV     R3,A
   \   000038   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00003B   12....       LCALL   ?Subroutine39 & 0xFFFF
    721              }
   \                     ??CrossCallReturnLabel_28:
   \   00003E   7001         JNZ     ??ZDSecMgrEntryInit_2
   \   000040   09           INC     R1
   \                     ??ZDSecMgrEntryInit_2:
   \   000041   12....       LCALL   ?Subroutine49 & 0xFFFF
    722            }
   \                     ??CrossCallReturnLabel_47:
   \   000044   40DF         JC      ??ZDSecMgrEntryInit_1
    723          
    724          #if defined NV_RESTORE
    725            if (state == ZDO_INITDEV_RESTORED_NETWORK_STATE)
    726            {
    727              ZDSecMgrRestoreFromNV();
    728            }
    729          #else
    730            (void)state;
    731          #endif
    732          }
   \                     ??ZDSecMgrEntryInit_0:
   \   000046   02....       LJMP    ??Subroutine77_0 & 0xFFFF
    733          
    734          /******************************************************************************
    735           * @fn          ZDSecMgrEntryLookup
    736           *
    737           * @brief       Lookup entry index using specified NWK address.
    738           *
    739           * @param       nwkAddr - [in] NWK address
    740           * @param       entry   - [out] valid entry
    741           *
    742           * @return      ZStatus_t
    743           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    744          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookup:
    745          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   12....       LCALL   ?Subroutine16 & 0xFFFF
    746            ZStatus_t      status;
    747            uint16         index;
    748            AddrMgrEntry_t addrMgrEntry;
    749          
    750          
    751            // initialize results
    752            *entry = NULL;
    753            status = ZNwkUnknownDevice;
    754          
    755            // verify data is available
    756            if ( ZDSecMgrEntries != NULL )
   \                     ??CrossCallReturnLabel_74:
   \   000010   6064         JZ      ??ZDSecMgrEntryLookup_0
    757            {
    758              addrMgrEntry.user    = ADDRMGR_USER_SECURITY;
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   7402         MOV     A,#0x2
   \   00001A   F0           MOVX    @DPTR,A
    759              addrMgrEntry.nwkAddr = nwkAddr;
   \   00001B   14           DEC     A
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   EA           MOV     A,R2
   \   000020   F0           MOVX    @DPTR,A
   \   000021   A3           INC     DPTR
   \   000022   EB           MOV     A,R3
   \   000023   12....       LCALL   ??Subroutine80_0 & 0xFFFF
    760          
    761              if ( AddrMgrEntryLookupNwk( &addrMgrEntry ) == TRUE )
   \                     ??CrossCallReturnLabel_151:
   \   000026   12....       LCALL   `??AddrMgrEntryLookupNwk::?relay`; Banked call to: AddrMgrEntryLookupNwk
   \   000029   E9           MOV     A,R1
   \   00002A   6401         XRL     A,#0x1
   \   00002C   7048         JNZ     ??ZDSecMgrEntryLookup_0
    762              {
    763                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   00002E   7800         MOV     R0,#0x0
   \   000030   7900         MOV     R1,#0x0
    764                {
    765                  if ( addrMgrEntry.index == ZDSecMgrEntries[index].ami )
   \                     ??ZDSecMgrEntryLookup_1:
   \   000032   E8           MOV     A,R0
   \   000033   FA           MOV     R2,A
   \   000034   E9           MOV     A,R1
   \   000035   FB           MOV     R3,A
   \   000036   EA           MOV     A,R2
   \   000037   75F01D       MOV     B,#0x1d
   \   00003A   A4           MUL     AB
   \   00003B   FA           MOV     R2,A
   \   00003C   ACF0         MOV     R4,B
   \   00003E   75F01D       MOV     B,#0x1d
   \   000041   EB           MOV     A,R3
   \   000042   A4           MUL     AB
   \   000043   2C           ADD     A,R4
   \   000044   FB           MOV     R3,A
   \   000045   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000048   E0           MOVX    A,@DPTR
   \   000049   2A           ADD     A,R2
   \   00004A   FA           MOV     R2,A
   \   00004B   A3           INC     DPTR
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   3B           ADDC    A,R3
   \   00004E   FB           MOV     R3,A
   \   00004F   740B         MOV     A,#0xb
   \   000051   12....       LCALL   ?XSTACK_DISP0_8
   \   000054   E0           MOVX    A,@DPTR
   \   000055   FC           MOV     R4,A
   \   000056   A3           INC     DPTR
   \   000057   E0           MOVX    A,@DPTR
   \   000058   FD           MOV     R5,A
   \   000059   8A82         MOV     DPL,R2
   \   00005B   8B83         MOV     DPH,R3
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   6C           XRL     A,R4
   \   00005F   7003         JNZ     ??ZDSecMgrEntryLookup_2
   \   000061   A3           INC     DPTR
   \   000062   E0           MOVX    A,@DPTR
   \   000063   6D           XRL     A,R5
   \                     ??ZDSecMgrEntryLookup_2:
   \   000064   7006         JNZ     ??CrossCallReturnLabel_72
    766                  {
    767                    // return successful results
    768                    *entry = &ZDSecMgrEntries[index];
   \   000066   EA           MOV     A,R2
   \   000067   F8           MOV     R0,A
   \   000068   EB           MOV     A,R3
   \   000069   12....       LCALL   ?Subroutine17 & 0xFFFF
    769                    status = ZSuccess;
    770          
    771                    // break from loop
    772                    index = ZDSECMGR_ENTRY_MAX;
    773                  }
    774                }
   \                     ??CrossCallReturnLabel_72:
   \   00006C   08           INC     R0
   \   00006D   E8           MOV     A,R0
   \   00006E   7001         JNZ     ??ZDSecMgrEntryLookup_3
   \   000070   09           INC     R1
   \                     ??ZDSecMgrEntryLookup_3:
   \   000071   12....       LCALL   ?Subroutine49 & 0xFFFF
    775              }
    776            }
   \                     ??CrossCallReturnLabel_48:
   \   000074   40BC         JC      ??ZDSecMgrEntryLookup_1
    777          
    778            return status;
   \                     ??ZDSecMgrEntryLookup_0:
   \   000076   A9..         MOV     R1,?V0
   \   000078   02....       LJMP    ?Subroutine2 & 0xFFFF
    779          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   FF           MOV     R7,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005                REQUIRE ??Subroutine66_0
   \   000005                ; // Fall through to label ??Subroutine66_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine66_0:
   \   000000   12....       LCALL   ??Subroutine64_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_79:
   \   000003   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000006   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_179:
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine80_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceCtrlHandler
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceJoin
   \   000001                ; Setup parameters for call to function APSME_AuthenticateReq
   \   000001                ; Setup parameters for call to function APSME_RequestKeyReq
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000001                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   000001                ; Setup parameters for call to function APSME_EstablishKeyReq
   \   000001                ; Setup parameters for call to function APSME_TransportKeyReq
   \   000001                ; Setup parameters for call to function AddrMgrEntryGet
   \   000001                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000001                ; Setup parameters for call to function NLME_LeaveReq
   \   000001                ; Setup parameters for call to function APSME_UpdateDeviceReq
   \   000001                ; Setup parameters for call to function APSME_AuthenticateReq
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceNew
   \   000001                ; Setup parameters for call to function APSME_EstablishKeyRsp
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000001   AA..         MOV     R2,?XSP + 0
   \   000003   AB..         MOV     R3,?XSP + 1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   740D         MOV     A,#0xd
   \   000002                REQUIRE ??Subroutine85_0
   \   000002                ; // Fall through to label ??Subroutine85_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine85_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine86_0
   \   000003                ; // Fall through to label ??Subroutine86_0
    780          
    781          /******************************************************************************
    782           * @fn          ZDSecMgrEntryLookupAMI
    783           *
    784           * @brief       Lookup entry using specified address index
    785           *
    786           * @param       ami   - [in] Address Manager index
    787           * @param       entry - [out] valid entry
    788           *
    789           * @return      ZStatus_t
    790           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    791          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupAMI:
    792          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    793            ZStatus_t status;
    794            uint16    index;
    795          
    796          
    797            // initialize results
    798            *entry = NULL;
   \   000009   8C82         MOV     DPL,R4
   \   00000B   8D83         MOV     DPH,R5
   \   00000D   12....       LCALL   ??Subroutine66_0 & 0xFFFF
    799            status = ZNwkUnknownDevice;
    800          
    801            // verify data is available
    802            if ( ZDSecMgrEntries != NULL )
   \                     ??CrossCallReturnLabel_76:
   \   000010   603C         JZ      ??ZDSecMgrEntryLookupAMI_0
    803            {
    804              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000012   7800         MOV     R0,#0x0
   \   000014   7900         MOV     R1,#0x0
    805              {
    806                if ( ZDSecMgrEntries[index].ami == ami )
   \                     ??ZDSecMgrEntryLookupAMI_1:
   \   000016   E8           MOV     A,R0
   \   000017   FA           MOV     R2,A
   \   000018   E9           MOV     A,R1
   \   000019   FB           MOV     R3,A
   \   00001A   EA           MOV     A,R2
   \   00001B   75F01D       MOV     B,#0x1d
   \   00001E   A4           MUL     AB
   \   00001F   FA           MOV     R2,A
   \   000020   85F0..       MOV     ?V1,B
   \   000023   75F01D       MOV     B,#0x1d
   \   000026   EB           MOV     A,R3
   \   000027   A4           MUL     AB
   \   000028   25..         ADD     A,?V1
   \   00002A   FB           MOV     R3,A
   \   00002B   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00002E   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   000031   6E           XRL     A,R6
   \   000032   7003         JNZ     ??ZDSecMgrEntryLookupAMI_2
   \   000034   A3           INC     DPTR
   \   000035   E0           MOVX    A,@DPTR
   \   000036   6F           XRL     A,R7
   \                     ??ZDSecMgrEntryLookupAMI_2:
   \   000037   700B         JNZ     ??CrossCallReturnLabel_73
    807                {
    808                  // return successful results
    809                  *entry = &ZDSecMgrEntries[index];
   \   000039   EA           MOV     A,R2
   \   00003A   F8           MOV     R0,A
   \   00003B   EB           MOV     A,R3
   \   00003C   F9           MOV     R1,A
   \   00003D   8C82         MOV     DPL,R4
   \   00003F   8D83         MOV     DPH,R5
   \   000041   12....       LCALL   ??Subroutine65_0 & 0xFFFF
    810                  status = ZSuccess;
    811          
    812                  // break from loop
    813                  index = ZDSECMGR_ENTRY_MAX;
    814                }
    815              }
   \                     ??CrossCallReturnLabel_73:
   \   000044   08           INC     R0
   \   000045   E8           MOV     A,R0
   \   000046   7001         JNZ     ??ZDSecMgrEntryLookupAMI_3
   \   000048   09           INC     R1
   \                     ??ZDSecMgrEntryLookupAMI_3:
   \   000049   12....       LCALL   ?Subroutine49 & 0xFFFF
    816            }
   \                     ??CrossCallReturnLabel_49:
   \   00004C   40C8         JC      ??ZDSecMgrEntryLookupAMI_1
    817          
    818            return status;
   \                     ??ZDSecMgrEntryLookupAMI_0:
   \   00004E   02....       LJMP    ?Subroutine11 & 0xFFFF
    819          }
    820          
    821          /******************************************************************************
    822           * @fn          ZDSecMgrEntryLookupExt
    823           *
    824           * @brief       Lookup entry index using specified EXT address.
    825           *
    826           * @param       extAddr - [in] EXT address
    827           * @param       entry   - [out] valid entry
    828           *
    829           * @return      ZStatus_t
    830           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    831          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupExt:
    832          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   12....       LCALL   ?Subroutine55 & 0xFFFF
    833            ZStatus_t status;
    834            uint16    ami;
    835          
    836          
    837            // initialize results
    838            *entry = NULL;
    839            status = ZNwkUnknownDevice;
    840          
    841            // lookup address index
    842            if ( ZDSecMgrExtAddrLookup( extAddr, &ami ) == ZSuccess )
   \                     ??CrossCallReturnLabel_78:
   \   00000D                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000D   AC..         MOV     R4,?XSP + 0
   \   00000F   AD..         MOV     R5,?XSP + 1
   \   000011   12....       LCALL   `??ZDSecMgrExtAddrLookup::?relay`; Banked call to: ZDSecMgrExtAddrLookup
   \   000014   E9           MOV     A,R1
   \   000015   7009         JNZ     ??ZDSecMgrEntryLookupExt_0
    843            {
    844              status = ZDSecMgrEntryLookupAMI( ami, entry );
   \   000017                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000017   12....       LCALL   ?Subroutine36 & 0xFFFF
    845            }
   \                     ??CrossCallReturnLabel_118:
   \   00001A   12....       LCALL   `??ZDSecMgrEntryLookupAMI::?relay`; Banked call to: ZDSecMgrEntryLookupAMI
   \   00001D   E9           MOV     A,R1
   \   00001E   F5..         MOV     ?V0,A
    846          
    847            return status;
   \                     ??ZDSecMgrEntryLookupExt_0:
   \   000020   02....       LJMP    ?Subroutine1 & 0xFFFF
    848          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   A9..         MOV     R1,?V0
   \   000002                REQUIRE ??Subroutine70_0
   \   000002                ; // Fall through to label ??Subroutine70_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine70_0:
   \   000000   7402         MOV     A,#0x2
   \   000002                REQUIRE ??Subroutine71_0
   \   000002                ; // Fall through to label ??Subroutine71_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   EE           MOV     A,R6
   \   000001   FC           MOV     R4,A
   \   000002   EF           MOV     A,R7
   \   000003   FD           MOV     R5,A
   \   000004                REQUIRE ??Subroutine74_0
   \   000004                ; // Fall through to label ??Subroutine74_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine74_0:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine75_0
   \   000006                ; // Fall through to label ??Subroutine75_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine75_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET
    849          
    850          /******************************************************************************
    851           * @fn          ZDSecMgrEntryFree
    852           *
    853           * @brief       Free entry.
    854           *
    855           * @param       entry - [in] valid entry
    856           *
    857           * @return      ZStatus_t
    858           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    859          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrEntryFree:
   \   000000   02....       LJMP    ?Subroutine0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
    860          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    861            entry->ami = INVALID_NODE_ADDR;
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   74FE         MOV     A,#-0x2
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   A3           INC     DPTR
   \   00000C   04           INC     A
   \   00000D                REQUIRE ??Subroutine76_0
   \   00000D                ; // Fall through to label ??Subroutine76_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine76_0:
   \   000000   F0           MOVX    @DPTR,A
    862          }
   \   000001                REQUIRE ??Subroutine77_0
   \   000001                ; // Fall through to label ??Subroutine77_0
    863          
    864          /******************************************************************************
    865           * @fn          ZDSecMgrEntryNew
    866           *
    867           * @brief       Get a new entry.
    868           *
    869           * @param       entry - [out] valid entry
    870           *
    871           * @return      ZStatus_t
    872           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    873          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryNew:
    874          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   12....       LCALL   ?Subroutine16 & 0xFFFF
    875            ZStatus_t status;
    876            uint16    index;
    877          
    878          
    879            // initialize results
    880            *entry = NULL;
    881            status = ZNwkUnknownDevice;
    882          
    883            // verify data is available
    884            if ( ZDSecMgrEntries != NULL )
   \                     ??CrossCallReturnLabel_75:
   \   00000B   605D         JZ      ??ZDSecMgrEntryNew_0
    885            {
    886              // find available entry
    887              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   00000D   7A00         MOV     R2,#0x0
   \   00000F   7B00         MOV     R3,#0x0
    888              {
    889                if ( ZDSecMgrEntries[index].ami == INVALID_NODE_ADDR )
   \                     ??ZDSecMgrEntryNew_1:
   \   000011   EA           MOV     A,R2
   \   000012   F8           MOV     R0,A
   \   000013   EB           MOV     A,R3
   \   000014   F9           MOV     R1,A
   \   000015   E8           MOV     A,R0
   \   000016   75F01D       MOV     B,#0x1d
   \   000019   A4           MUL     AB
   \   00001A   F8           MOV     R0,A
   \   00001B   ACF0         MOV     R4,B
   \   00001D   75F01D       MOV     B,#0x1d
   \   000020   E9           MOV     A,R1
   \   000021   A4           MUL     AB
   \   000022   2C           ADD     A,R4
   \   000023   F9           MOV     R1,A
   \   000024   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000027   E0           MOVX    A,@DPTR
   \   000028   28           ADD     A,R0
   \   000029   FC           MOV     R4,A
   \   00002A   A3           INC     DPTR
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   39           ADDC    A,R1
   \   00002D   FD           MOV     R5,A
   \   00002E   8C82         MOV     DPL,R4
   \   000030   8D83         MOV     DPH,R5
   \   000032   E0           MOVX    A,@DPTR
   \   000033   64FE         XRL     A,#0xfe
   \   000035   7003         JNZ     ??ZDSecMgrEntryNew_2
   \   000037   A3           INC     DPTR
   \   000038   E0           MOVX    A,@DPTR
   \   000039   F4           CPL     A
   \                     ??ZDSecMgrEntryNew_2:
   \   00003A   7021         JNZ     ??ZDSecMgrEntryNew_3
    890                {
    891                  // return successful result
    892                  *entry = &ZDSecMgrEntries[index];
   \   00003C   EC           MOV     A,R4
   \   00003D   FA           MOV     R2,A
   \   00003E   ED           MOV     A,R5
   \   00003F   12....       LCALL   ?Subroutine33 & 0xFFFF
    893                  status = ZSuccess;
   \                     ??CrossCallReturnLabel_129:
   \   000042   75..00       MOV     ?V0,#0x0
    894          
    895                  // Set the authentication option to default
    896                  ZDSecMgrEntries[index].authenticateOption = ZDSecMgr_Not_Authenticated;
   \   000045   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000048   E0           MOVX    A,@DPTR
   \   000049   28           ADD     A,R0
   \   00004A   F8           MOV     R0,A
   \   00004B   A3           INC     DPTR
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   39           ADDC    A,R1
   \   00004E   F9           MOV     R1,A
   \   00004F   E8           MOV     A,R0
   \   000050   241C         ADD     A,#0x1c
   \   000052   F582         MOV     DPL,A
   \   000054   E4           CLR     A
   \   000055   39           ADDC    A,R1
   \   000056   F583         MOV     DPH,A
   \   000058   E4           CLR     A
   \   000059   F0           MOVX    @DPTR,A
    897          
    898                  // break from loop
    899                  index = ZDSECMGR_ENTRY_MAX;
   \   00005A   7A03         MOV     R2,#0x3
   \   00005C   FB           MOV     R3,A
    900                }
    901              }
   \                     ??ZDSecMgrEntryNew_3:
   \   00005D   0A           INC     R2
   \   00005E   EA           MOV     A,R2
   \   00005F   7001         JNZ     ??ZDSecMgrEntryNew_4
   \   000061   0B           INC     R3
   \                     ??ZDSecMgrEntryNew_4:
   \   000062   C3           CLR     C
   \   000063   9403         SUBB    A,#0x3
   \   000065   EB           MOV     A,R3
   \   000066   9400         SUBB    A,#0x0
   \   000068   40A7         JC      ??ZDSecMgrEntryNew_1
    902            }
    903          
    904            return status;
   \                     ??ZDSecMgrEntryNew_0:
   \   00006A   02....       LJMP    ?Subroutine11 & 0xFFFF
    905          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   FB           MOV     R3,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005                REQUIRE ??Subroutine78_0
   \   000005                ; // Fall through to label ??Subroutine78_0
    906          
    907          /******************************************************************************
    908           * @fn          ZDSecMgrCtrlInit
    909           *
    910           * @brief       Initialize control sub module
    911           *
    912           * @param       none
    913           *
    914           * @return      none
    915           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    916          void ZDSecMgrCtrlInit( void )
   \                     ZDSecMgrCtrlInit:
    917          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    918            uint16 size;
    919            uint16 index;
    920          
    921            // allocate entry data
    922            size = (short)( sizeof(ZDSecMgrCtrl_t) * ZDSECMGR_CTRL_MAX );
    923          
    924            ZDSecMgrCtrlData = osal_mem_alloc( size );
   \   000004                ; Setup parameters for call to function osal_mem_alloc
   \   000004   7A15         MOV     R2,#0x15
   \   000006   7B00         MOV     R3,#0x0
   \   000008   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00000B   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00000E   EA           MOV     A,R2
   \   00000F   F0           MOVX    @DPTR,A
   \   000010   A3           INC     DPTR
   \   000011   EB           MOV     A,R3
   \   000012   12....       LCALL   ?Subroutine23 & 0xFFFF
    925          
    926            // initialize data
    927            if ( ZDSecMgrCtrlData != NULL )
   \                     ??CrossCallReturnLabel_8:
   \   000015   602E         JZ      ??ZDSecMgrCtrlInit_0
    928            {
    929              for( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   000017   7800         MOV     R0,#0x0
   \   000019   7900         MOV     R1,#0x0
    930              {
    931                ZDSecMgrCtrlData[index].state = ZDSECMGR_CTRL_NONE;
   \                     ??ZDSecMgrCtrlInit_1:
   \   00001B   E8           MOV     A,R0
   \   00001C   FA           MOV     R2,A
   \   00001D   E9           MOV     A,R1
   \   00001E   FB           MOV     R3,A
   \   00001F   EA           MOV     A,R2
   \   000020   75F007       MOV     B,#0x7
   \   000023   A4           MUL     AB
   \   000024   FA           MOV     R2,A
   \   000025   ACF0         MOV     R4,B
   \   000027   75F007       MOV     B,#0x7
   \   00002A   EB           MOV     A,R3
   \   00002B   A4           MUL     AB
   \   00002C   2C           ADD     A,R4
   \   00002D   FB           MOV     R3,A
   \   00002E   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000031   12....       LCALL   ?Subroutine61 & 0xFFFF
    932              }
   \                     ??CrossCallReturnLabel_69:
   \   000034   A3           INC     DPTR
   \   000035   A3           INC     DPTR
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   E4           CLR     A
   \   00003A   F0           MOVX    @DPTR,A
   \   00003B   08           INC     R0
   \   00003C   E8           MOV     A,R0
   \   00003D   7001         JNZ     ??ZDSecMgrCtrlInit_2
   \   00003F   09           INC     R1
   \                     ??ZDSecMgrCtrlInit_2:
   \   000040   12....       LCALL   ?Subroutine49 & 0xFFFF
    933            }
   \                     ??CrossCallReturnLabel_50:
   \   000043   40D6         JC      ??ZDSecMgrCtrlInit_1
    934          }
   \                     ??ZDSecMgrCtrlInit_0:
   \   000045   02....       LJMP    ??Subroutine77_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000004   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_178:
   \   000007   22           RET
    935          
    936          /******************************************************************************
    937           * @fn          ZDSecMgrCtrlRelease
    938           *
    939           * @brief       Release control data.
    940           *
    941           * @param       ctrl - [in] valid control data
    942           *
    943           * @return      none
    944           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    945          void ZDSecMgrCtrlRelease( ZDSecMgrCtrl_t* ctrl )
   \                     ZDSecMgrCtrlRelease:
    946          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    947            // should always be enough entry control data
    948            ctrl->state = ZDSECMGR_CTRL_NONE;
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   E4           CLR     A
   \   00000E   02....       LJMP    ??Subroutine76_0 & 0xFFFF
    949          }
    950          
    951          /******************************************************************************
    952           * @fn          ZDSecMgrCtrlLookup
    953           *
    954           * @brief       Lookup control data.
    955           *
    956           * @param       entry - [in] valid entry data
    957           * @param       ctrl  - [out] control data - NULL if not found
    958           *
    959           * @return      none
    960           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    961          void ZDSecMgrCtrlLookup( ZDSecMgrEntry_t* entry, ZDSecMgrCtrl_t** ctrl )
   \                     ZDSecMgrCtrlLookup:
    962          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    963            uint16 index;
    964          
    965          
    966            // initialize search results
    967            *ctrl = NULL;
   \   000009   8C82         MOV     DPL,R4
   \   00000B   8D83         MOV     DPH,R5
   \   00000D   E4           CLR     A
   \   00000E   F0           MOVX    @DPTR,A
   \   00000F   A3           INC     DPTR
   \   000010   12....       LCALL   ?Subroutine23 & 0xFFFF
    968          
    969            // verify data is available
    970            if ( ZDSecMgrCtrlData != NULL )
   \                     ??CrossCallReturnLabel_9:
   \   000013   604B         JZ      ??ZDSecMgrCtrlLookup_0
    971            {
    972              for ( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   000015   7800         MOV     R0,#0x0
   \   000017   7900         MOV     R1,#0x0
    973              {
    974                // make sure control data is in use
    975                if ( ZDSecMgrCtrlData[index].state != ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrCtrlLookup_1:
   \   000019   E8           MOV     A,R0
   \   00001A   FA           MOV     R2,A
   \   00001B   E9           MOV     A,R1
   \   00001C   FB           MOV     R3,A
   \   00001D   EA           MOV     A,R2
   \   00001E   75F007       MOV     B,#0x7
   \   000021   A4           MUL     AB
   \   000022   FA           MOV     R2,A
   \   000023   85F0..       MOV     ?V0,B
   \   000026   75F007       MOV     B,#0x7
   \   000029   EB           MOV     A,R3
   \   00002A   A4           MUL     AB
   \   00002B   25..         ADD     A,?V0
   \   00002D   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_29:
   \   000030   6024         JZ      ??ZDSecMgrCtrlLookup_2
    976                {
    977                  // check for entry match
    978                  if ( ZDSecMgrCtrlData[index].entry == entry )
   \   000032   8A82         MOV     DPL,R2
   \   000034   8B83         MOV     DPH,R3
   \   000036   E0           MOVX    A,@DPTR
   \   000037   F5..         MOV     ?V0,A
   \   000039   A3           INC     DPTR
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   F5..         MOV     ?V1,A
   \   00003D   EE           MOV     A,R6
   \   00003E   65..         XRL     A,?V0
   \   000040   7003         JNZ     ??ZDSecMgrCtrlLookup_3
   \   000042   EF           MOV     A,R7
   \   000043   65..         XRL     A,?V1
   \                     ??ZDSecMgrCtrlLookup_3:
   \   000045   700F         JNZ     ??ZDSecMgrCtrlLookup_2
    979                  {
    980                    // return this control data
    981                    *ctrl = &ZDSecMgrCtrlData[index];
   \   000047   EA           MOV     A,R2
   \   000048   F8           MOV     R0,A
   \   000049   EB           MOV     A,R3
   \   00004A   F9           MOV     R1,A
   \   00004B   8C82         MOV     DPL,R4
   \   00004D   8D83         MOV     DPH,R5
   \   00004F   12....       LCALL   ??Subroutine79_0 & 0xFFFF
    982          
    983                    // break from loop
    984                    index = ZDSECMGR_CTRL_MAX;
   \                     ??CrossCallReturnLabel_131:
   \   000052   7803         MOV     R0,#0x3
   \   000054   7900         MOV     R1,#0x0
    985                  }
    986                }
    987              }
   \                     ??ZDSecMgrCtrlLookup_2:
   \   000056   08           INC     R0
   \   000057   E8           MOV     A,R0
   \   000058   7001         JNZ     ??ZDSecMgrCtrlLookup_4
   \   00005A   09           INC     R1
   \                     ??ZDSecMgrCtrlLookup_4:
   \   00005B   12....       LCALL   ?Subroutine49 & 0xFFFF
    988            }
   \                     ??CrossCallReturnLabel_51:
   \   00005E   40B9         JC      ??ZDSecMgrCtrlLookup_1
    989          }
   \                     ??ZDSecMgrCtrlLookup_0:
   \   000060   02....       LJMP    ??Subroutine86_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000   FB           MOV     R3,A
   \   000001   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000004   12....       LCALL   ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine79_0:
   \   000000   12....       LCALL   ??Subroutine90_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_206:
   \   000003   22           RET
    990          
    991          /******************************************************************************
    992           * @fn          ZDSecMgrCtrlSet
    993           *
    994           * @brief       Set control data.
    995           *
    996           * @param       device - [in] valid device data
    997           * @param       entry  - [in] valid entry data
    998           * @param       ctrl   - [in] valid control data
    999           *
   1000           * @return      none
   1001           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1002          void ZDSecMgrCtrlSet( ZDSecMgrDevice_t* device,
   \                     ZDSecMgrCtrlSet:
   1003                                ZDSecMgrEntry_t*  entry,
   1004                                ZDSecMgrCtrl_t*   ctrl )
   1005          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   7409         MOV     A,#0x9
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   12....       LCALL   ??Subroutine88_0 & 0xFFFF
   1006            // set control date
   1007            ctrl->parentAddr = device->parentAddr;
   \                     ??CrossCallReturnLabel_187:
   \   00000D   8A82         MOV     DPL,R2
   \   00000F   8B83         MOV     DPH,R3
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   FE           MOV     R6,A
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   FF           MOV     R7,A
   \   00001A   8882         MOV     DPL,R0
   \   00001C   8983         MOV     DPH,R1
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   EE           MOV     A,R6
   \   000021   F0           MOVX    @DPTR,A
   \   000022   A3           INC     DPTR
   \   000023   EF           MOV     A,R7
   \   000024   12....       LCALL   ?Subroutine24 & 0xFFFF
   1008            ctrl->secure     = device->secure;
   \                     ??CrossCallReturnLabel_10:
   \   000027   E0           MOVX    A,@DPTR
   \   000028   8882         MOV     DPL,R0
   \   00002A   8983         MOV     DPH,R1
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   12....       LCALL   ?Subroutine56 & 0xFFFF
   1009            ctrl->entry      = entry;
   \                     ??CrossCallReturnLabel_61:
   \   000033   EC           MOV     A,R4
   \   000034   F0           MOVX    @DPTR,A
   \   000035   A3           INC     DPTR
   \   000036   ED           MOV     A,R5
   \   000037   12....       LCALL   ?Subroutine25 & 0xFFFF
   1010            ctrl->state      = ZDSECMGR_CTRL_INIT;
   \                     ??CrossCallReturnLabel_12:
   \   00003A   7401         MOV     A,#0x1
   \   00003C   12....       LCALL   ?Subroutine25 & 0xFFFF
   1011            ctrl->cntr       = 0;
   \                     ??CrossCallReturnLabel_13:
   \   00003F   A3           INC     DPTR
   \   000040   E4           CLR     A
   \   000041   12....       LCALL   ?Subroutine24 & 0xFFFF
   1012          
   1013            // set device pointer
   1014            device->ctrl = ctrl;
   \                     ??CrossCallReturnLabel_11:
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   12....       LCALL   ??Subroutine79_0 & 0xFFFF
   1015          }
   \                     ??CrossCallReturnLabel_132:
   \   000049   02....       LJMP    ??Subroutine72_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   12....       LCALL   ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine56:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function AssocGetWithExt
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine88_0:
   \   000000   12....       LCALL   ??Subroutine91_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_213:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine91_0:
   \   000000   12....       LCALL   ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_217:
   \   000003   22           RET
   1016          
   1017          /******************************************************************************
   1018           * @fn          ZDSecMgrCtrlAdd
   1019           *
   1020           * @brief       Add control data.
   1021           *
   1022           * @param       device - [in] valid device data
   1023           * @param       entry  - [in] valid entry data
   1024           *
   1025           * @return      ZStatus_t
   1026           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1027          ZStatus_t ZDSecMgrCtrlAdd( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t*  entry )
   \                     ZDSecMgrCtrlAdd:
   1028          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   1029            ZStatus_t status;
   1030            uint16    index;
   1031          
   1032          
   1033            // initialize results
   1034            status = ZNwkUnknownDevice;
   \   00000D   7CC8         MOV     R4,#-0x38
   1035          
   1036            // verify data is available
   1037            if ( ZDSecMgrCtrlData != NULL )
   \   00000F   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000012   12....       LCALL   ??Subroutine83_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_167:
   \   000015   6044         JZ      ??ZDSecMgrCtrlAdd_0
   1038            {
   1039              // look for an empty slot
   1040              for ( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   000017   7800         MOV     R0,#0x0
   \   000019   7900         MOV     R1,#0x0
   1041              {
   1042                if ( ZDSecMgrCtrlData[index].state == ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrCtrlAdd_1:
   \   00001B   E8           MOV     A,R0
   \   00001C   FA           MOV     R2,A
   \   00001D   E9           MOV     A,R1
   \   00001E   FB           MOV     R3,A
   \   00001F   EA           MOV     A,R2
   \   000020   75F007       MOV     B,#0x7
   \   000023   A4           MUL     AB
   \   000024   FA           MOV     R2,A
   \   000025   ADF0         MOV     R5,B
   \   000027   75F007       MOV     B,#0x7
   \   00002A   EB           MOV     A,R3
   \   00002B   A4           MUL     AB
   \   00002C   2D           ADD     A,R5
   \   00002D   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_30:
   \   000030   701F         JNZ     ??ZDSecMgrCtrlAdd_2
   1043                {
   1044                  // return successful results
   1045                  ZDSecMgrCtrlSet( device, entry, &ZDSecMgrCtrlData[index] );
   \   000032                ; Setup parameters for call to function ZDSecMgrCtrlSet
   \   000032   8A..         MOV     ?V2,R2
   \   000034   8B..         MOV     ?V3,R3
   \   000036   78..         MOV     R0,#?V2
   \   000038   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003B   EE           MOV     A,R6
   \   00003C   FC           MOV     R4,A
   \   00003D   EF           MOV     A,R7
   \   00003E   FD           MOV     R5,A
   \   00003F   AA..         MOV     R2,?V0
   \   000041   AB..         MOV     R3,?V1
   \   000043   12....       LCALL   `??ZDSecMgrCtrlSet::?relay`; Banked call to: ZDSecMgrCtrlSet
   \   000046   7402         MOV     A,#0x2
   \   000048   12....       LCALL   ?DEALLOC_XSTACK8
   1046          
   1047                  status = ZSuccess;
   \   00004B   7C00         MOV     R4,#0x0
   1048          
   1049                  // break from loop
   1050                  index = ZDSECMGR_CTRL_MAX;
   \   00004D   7803         MOV     R0,#0x3
   \   00004F   7900         MOV     R1,#0x0
   1051                }
   1052              }
   \                     ??ZDSecMgrCtrlAdd_2:
   \   000051   08           INC     R0
   \   000052   E8           MOV     A,R0
   \   000053   7001         JNZ     ??ZDSecMgrCtrlAdd_3
   \   000055   09           INC     R1
   \                     ??ZDSecMgrCtrlAdd_3:
   \   000056   12....       LCALL   ?Subroutine49 & 0xFFFF
   1053            }
   \                     ??CrossCallReturnLabel_52:
   \   000059   40C0         JC      ??ZDSecMgrCtrlAdd_1
   1054          
   1055            return status;
   \                     ??ZDSecMgrCtrlAdd_0:
   \   00005B   EC           MOV     A,R4
   \   00005C   F9           MOV     R1,A
   \   00005D   02....       LJMP    ??Subroutine82_0 & 0xFFFF
   1056          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine82_0:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
   1057          
   1058          /******************************************************************************
   1059           * @fn          ZDSecMgrCtrlTerm
   1060           *
   1061           * @brief       Terminate device control.
   1062           *
   1063           * @param       entry - [in] valid entry data
   1064           *
   1065           * @return      none
   1066           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1067          void ZDSecMgrCtrlTerm( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrCtrlTerm:
   1068          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 2
   \   000004   74FE         MOV     A,#-0x2
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   1069            ZDSecMgrCtrl_t* ctrl;
   1070          
   1071            // remove device from control data
   1072            ZDSecMgrCtrlLookup ( entry, &ctrl );
   \   000009                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   000009   AC..         MOV     R4,?XSP + 0
   \   00000B   AD..         MOV     R5,?XSP + 1
   \   00000D   12....       LCALL   `??ZDSecMgrCtrlLookup::?relay`; Banked call to: ZDSecMgrCtrlLookup
   1073          
   1074            if ( ctrl != NULL )
   \   000010   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_173:
   \   000013   6010         JZ      ??ZDSecMgrCtrlTerm_0
   1075            {
   1076              ZDSecMgrCtrlRelease ( ctrl );
   \   000015   85..82       MOV     DPL,?XSP + 0
   \   000018   85..83       MOV     DPH,?XSP + 1
   \   00001B   12....       LCALL   ??Subroutine69_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   E4           CLR     A
   \   000024   F0           MOVX    @DPTR,A
   1077            }
   1078          }
   \                     ??ZDSecMgrCtrlTerm_0:
   \   000025   02....       LJMP    ?Subroutine8 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine83_0
   \   000006                ; // Fall through to label ??Subroutine83_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   7402         MOV     A,#0x2
   \   000002                REQUIRE ??Subroutine92_0
   \   000002                ; // Fall through to label ??Subroutine92_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine92_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   02....       LJMP    ??Subroutine77_0 & 0xFFFF
   1079          
   1080          /******************************************************************************
   1081           * @fn          ZDSecMgrCtrlReset
   1082           *
   1083           * @brief       Reset control data.
   1084           *
   1085           * @param       device - [in] valid device data
   1086           * @param       entry  - [in] valid entry data
   1087           *
   1088           * @return      ZStatus_t
   1089           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1090          ZStatus_t ZDSecMgrCtrlReset( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrCtrlReset:
   1091          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0,R2
   \   00000C   8B..         MOV     ?V1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   1092            ZStatus_t       status;
   1093            ZDSecMgrCtrl_t* ctrl;
   1094          
   1095          
   1096            // initialize results
   1097            status = ZNwkUnknownDevice;
   1098          
   1099            // look for a match for the entry
   1100            ZDSecMgrCtrlLookup( entry, &ctrl );
   \   000012                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   000012   AC..         MOV     R4,?XSP + 0
   \   000014   AD..         MOV     R5,?XSP + 1
   \   000016   EE           MOV     A,R6
   \   000017   FA           MOV     R2,A
   \   000018   EF           MOV     A,R7
   \   000019   FB           MOV     R3,A
   \   00001A   12....       LCALL   `??ZDSecMgrCtrlLookup::?relay`; Banked call to: ZDSecMgrCtrlLookup
   1101          
   1102            if ( ctrl != NULL )
   \   00001D   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_174:
   \   000020   601D         JZ      ??ZDSecMgrCtrlReset_0
   1103            {
   1104              ZDSecMgrCtrlSet( device, entry, ctrl );
   \   000022                ; Setup parameters for call to function ZDSecMgrCtrlSet
   \   000022   85..82       MOV     DPL,?XSP + 0
   \   000025   85..83       MOV     DPH,?XSP + 1
   \   000028   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00002B   EE           MOV     A,R6
   \   00002C   FC           MOV     R4,A
   \   00002D   EF           MOV     A,R7
   \   00002E   FD           MOV     R5,A
   \   00002F   AA..         MOV     R2,?V0
   \   000031   AB..         MOV     R3,?V1
   \   000033   12....       LCALL   `??ZDSecMgrCtrlSet::?relay`; Banked call to: ZDSecMgrCtrlSet
   \   000036   7402         MOV     A,#0x2
   \   000038   12....       LCALL   ?DEALLOC_XSTACK8
   1105          
   1106              status = ZSuccess;
   \   00003B   7900         MOV     R1,#0x0
   \   00003D   800D         SJMP    ??ZDSecMgrCtrlReset_1
   1107            }
   1108            else
   1109            {
   1110              status = ZDSecMgrCtrlAdd( device, entry );
   \                     ??ZDSecMgrCtrlReset_0:
   \   00003F                ; Setup parameters for call to function ZDSecMgrCtrlAdd
   \   00003F   EE           MOV     A,R6
   \   000040   FC           MOV     R4,A
   \   000041   EF           MOV     A,R7
   \   000042   FD           MOV     R5,A
   \   000043   AA..         MOV     R2,?V0
   \   000045   AB..         MOV     R3,?V1
   \   000047   12....       LCALL   `??ZDSecMgrCtrlAdd::?relay`; Banked call to: ZDSecMgrCtrlAdd
   \   00004A   E9           MOV     A,R1
   \   00004B   F9           MOV     R1,A
   1111            }
   1112          
   1113            return status;
   \                     ??ZDSecMgrCtrlReset_1:
   \   00004C                REQUIRE ?Subroutine12
   \   00004C                ; // Fall through to label ?Subroutine12
   1114          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   7402         MOV     A,#0x2
   \   000002   02....       LJMP    ??Subroutine85_0 & 0xFFFF
   1115          
   1116          /******************************************************************************
   1117           * @fn          ZDSecMgrMasterKeyLoad
   1118           *
   1119           * @brief       Load the MASTER key for device with specified EXT
   1120           *              address.
   1121           *
   1122           * @param       extAddr - [in] EXT address of device
   1123           * @param       key     - [in] MASTER key shared with device
   1124           *
   1125           * @return      ZStatus_t
   1126           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1127          ZStatus_t ZDSecMgrMasterKeyLoad( uint8* extAddr, uint8* key )
   \                     ZDSecMgrMasterKeyLoad:
   1128          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   1129            ZStatus_t status;
   1130            uint8*    loaded;
   1131            uint16    ami;
   1132          
   1133          
   1134            // set status based on policy
   1135            status = ZDSecMgrExtAddrLookup( extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   AC..         MOV     R4,?XSP + 0
   \   000010   AD..         MOV     R5,?XSP + 1
   \   000012   12....       LCALL   `??ZDSecMgrExtAddrLookup::?relay`; Banked call to: ZDSecMgrExtAddrLookup
   \   000015   E9           MOV     A,R1
   \   000016   F5..         MOV     ?V0,A
   1136          
   1137            if ( status == ZSuccess )
   \   000018   7039         JNZ     ??ZDSecMgrMasterKeyLoad_0
   1138            {
   1139              // get the address index
   1140              if ( ZDSecMgrMasterKeyLookup( ami, &loaded ) == ZSuccess )
   \   00001A                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   00001A   7402         MOV     A,#0x2
   \   00001C   12....       LCALL   ?XSTACK_DISP102_8
   \   00001F   12....       LCALL   ??Subroutine74_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_114:
   \   000022   12....       LCALL   `??ZDSecMgrMasterKeyLookup::?relay`; Banked call to: ZDSecMgrMasterKeyLookup
   \   000025   E9           MOV     A,R1
   \   000026   7022         JNZ     ??ZDSecMgrMasterKeyLoad_1
   1141              {
   1142                // overwrite old key
   1143                osal_memcpy( loaded, key, SEC_KEY_LEN );
   \   000028                ; Setup parameters for call to function osal_memcpy
   \   000028   8E..         MOV     ?V4,R6
   \   00002A   8F..         MOV     ?V5,R7
   \   00002C   75..00       MOV     ?V6,#0x0
   \   00002F   78..         MOV     R0,#?V4
   \   000031   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000034   7C10         MOV     R4,#0x10
   \   000036   7D00         MOV     R5,#0x0
   \   000038   7405         MOV     A,#0x5
   \   00003A   12....       LCALL   ?XSTACK_DISP0_8
   \   00003D   12....       LCALL   ??Subroutine75_0 & 0xFFFF
   1144              }
   \                     ??CrossCallReturnLabel_93:
   \   000040   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000043   7403         MOV     A,#0x3
   \   000045   12....       LCALL   ?DEALLOC_XSTACK8
   \   000048   8009         SJMP    ??ZDSecMgrMasterKeyLoad_0
   1145              else
   1146              {
   1147                // store new key -- NULL will zero key
   1148                status = ZDSecMgrMasterKeyStore( ami, key );
   \                     ??ZDSecMgrMasterKeyLoad_1:
   \   00004A                ; Setup parameters for call to function ZDSecMgrMasterKeyStore
   \   00004A   12....       LCALL   ?Subroutine36 & 0xFFFF
   1149              }
   1150            }
   \                     ??CrossCallReturnLabel_119:
   \   00004D   12....       LCALL   `??ZDSecMgrMasterKeyStore::?relay`; Banked call to: ZDSecMgrMasterKeyStore
   \   000050   E9           MOV     A,R1
   \   000051   F5..         MOV     ?V0,A
   1151          
   1152            return status;
   \                     ??ZDSecMgrMasterKeyLoad_0:
   \   000053   A9..         MOV     R1,?V0
   \   000055   7404         MOV     A,#0x4
   \   000057                REQUIRE ?Subroutine5
   \   000057                ; // Fall through to label ?Subroutine5
   1153          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F07         MOV     R7,#0x7
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA
   1154          
   1155          /******************************************************************************
   1156           * @fn          ZDSecMgrAppKeyGet
   1157           *
   1158           * @brief       get an APP key - option APP(MASTER or LINK) key
   1159           *
   1160           * @param       initNwkAddr - [in] NWK address of initiator device
   1161           * @param       initExtAddr - [in] EXT address of initiator device
   1162           * @param       partNwkAddr - [in] NWK address of partner device
   1163           * @param       partExtAddr - [in] EXT address of partner device
   1164           * @param       key         - [out] APP(MASTER or LINK) key
   1165           * @param       keyType     - [out] APP(MASTER or LINK) key type
   1166           *
   1167           * @return      ZStatus_t
   1168           */

   \                                 In  segment XDATA_I, align 1, keep-with-next
   1169          uint8 ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;    // Set the default key type
   \                     ZDSecMgrAppKeyType:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for ZDSecMgrAppKeyType>`
   \   000001                REQUIRE __INIT_XDATA_I
   1170                                                           // to KEY_TYPE_APP_LINK since
   1171                                                           // only specific requirement
   1172                                                           // right now comes from SE profile
   1173          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1174          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
   \                     ZDSecMgrAppKeyGet:
   1175                                       uint8*  initExtAddr,
   1176                                       uint16  partNwkAddr,
   1177                                       uint8*  partExtAddr,
   1178                                       uint8** key,
   1179                                       uint8*  keyType )
   1180          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1181            // Intentionally unreferenced parameters
   1182            (void)initNwkAddr;
   1183            (void)initExtAddr;
   1184            (void)partNwkAddr;
   1185            (void)partExtAddr;
   1186            
   1187            //---------------------------------------------------------------------------
   1188            // note:
   1189            // should use a robust mechanism to generate keys, for example
   1190            // combine EXT addresses and call a hash function
   1191            //---------------------------------------------------------------------------
   1192            SSP_GetTrueRand( SEC_KEY_LEN, *key );
   \   000004                ; Setup parameters for call to function SSP_GetTrueRand
   \   000004   7404         MOV     A,#0x4
   \   000006   12....       LCALL   ?XSTACK_DISP0_8
   \   000009   12....       LCALL   ??Subroutine68_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_84:
   \   00000C   12....       LCALL   ??Subroutine75_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_94:
   \   00000F   7910         MOV     R1,#0x10
   \   000011   12....       LCALL   `??SSP_GetTrueRand::?relay`; Banked call to: SSP_GetTrueRand
   1193          
   1194            *keyType = ZDSecMgrAppKeyType;
   \   000014   90....       MOV     DPTR,#ZDSecMgrAppKeyType
   \   000017   E0           MOVX    A,@DPTR
   \   000018   C0E0         PUSH    A
   \   00001A   7406         MOV     A,#0x6
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   12....       LCALL   ??Subroutine68_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_85:
   \   000022   D0E0         POP     A
   \   000024   F0           MOVX    @DPTR,A
   1195          
   1196            return ZSuccess;
   \   000025   7900         MOV     R1,#0x0
   \   000027   02....       LJMP    ??Subroutine77_0 & 0xFFFF
   1197          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine68_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002                REQUIRE ??Subroutine69_0
   \   000002                ; // Fall through to label ??Subroutine69_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine69_0:
   \   000000   A3           INC     DPTR
   \   000001   E0           MOVX    A,@DPTR
   \   000002   F583         MOV     DPH,A
   \   000004   8882         MOV     DPL,R0
   \   000006   22           RET
   1198          
   1199          /******************************************************************************
   1200           * @fn          ZDSecMgrAppKeyReq
   1201           *
   1202           * @brief       Process request for APP key between two devices.
   1203           *
   1204           * @param       device - [in] ZDO_RequestKeyInd_t, request info
   1205           *
   1206           * @return      none
   1207           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1208          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrAppKeyReq:
   1209          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 39
   \   000005   74D9         MOV     A,#-0x27
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1210            APSME_TransportKeyReq_t req;
   1211            uint8                   initExtAddr[Z_EXTADDR_LEN];
   1212            uint16                  partNwkAddr;
   1213            uint8                   key[SEC_KEY_LEN];
   1214          
   1215          
   1216            // validate initiator and partner
   1217            if ( ( APSME_LookupNwkAddr( ind->partExtAddr, &partNwkAddr ) == TRUE ) &&
   1218                 ( APSME_LookupExtAddr( ind->srcAddr, initExtAddr ) == TRUE      )   )
   \   00000E   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   000011                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   000011   AC..         MOV     R4,?XSP + 0
   \   000013   AD..         MOV     R5,?XSP + 1
   \   000015   AA..         MOV     R2,?V0
   \   000017   FB           MOV     R3,A
   \   000018   12....       LCALL   `??APSME_LookupNwkAddr::?relay`; Banked call to: APSME_LookupNwkAddr
   \   00001B   E9           MOV     A,R1
   \   00001C   6401         XRL     A,#0x1
   \   00001E   6003         JZ      $+5
   \   000020   02....       LJMP    ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   \   000023   EE           MOV     A,R6
   \   000024   2402         ADD     A,#0x2
   \   000026   FE           MOV     R6,A
   \   000027   5001         JNC     ??ZDSecMgrAppKeyReq_1
   \   000029   0F           INC     R7
   \                     ??ZDSecMgrAppKeyReq_1:
   \   00002A                ; Setup parameters for call to function APSME_LookupExtAddr
   \   00002A   740F         MOV     A,#0xf
   \   00002C   12....       LCALL   ?XSTACK_DISP102_8
   \   00002F   8E82         MOV     DPL,R6
   \   000031   8F83         MOV     DPH,R7
   \   000033   12....       LCALL   ??Subroutine75_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_95:
   \   000036   12....       LCALL   `??APSME_LookupExtAddr::?relay`; Banked call to: APSME_LookupExtAddr
   \   000039   E9           MOV     A,R1
   \   00003A   6401         XRL     A,#0x1
   \   00003C   6003         JZ      $+5
   \   00003E   02....       LJMP    ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   1219            {
   1220              // point the key to some memory
   1221              req.key = key;
   \   000041   7417         MOV     A,#0x17
   \   000043   12....       LCALL   ?XSTACK_DISP100_8
   \   000046   7406         MOV     A,#0x6
   \   000048   12....       LCALL   ?XSTACK_DISP0_8
   \   00004B   12....       LCALL   ??Subroutine79_0 & 0xFFFF
   1222          
   1223              // get an APP key - option APP (MASTER or LINK) key
   1224              if ( ZDSecMgrAppKeyGet( ind->srcAddr,
   1225                                      initExtAddr,
   1226                                      partNwkAddr,
   1227                                      ind->partExtAddr,
   1228                                      &req.key,
   1229                                      &req.keyType ) == ZSuccess )
   \                     ??CrossCallReturnLabel_133:
   \   00004E                ; Setup parameters for call to function ZDSecMgrAppKeyGet
   \   00004E   7404         MOV     A,#0x4
   \   000050   12....       LCALL   ?XSTACK_DISP0_8
   \   000053   8582..       MOV     ?V2,DPL
   \   000056   8583..       MOV     ?V3,DPH
   \   000059   78..         MOV     R0,#?V2
   \   00005B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005E   7408         MOV     A,#0x8
   \   000060   12....       LCALL   ?XSTACK_DISP0_8
   \   000063   8582..       MOV     ?V2,DPL
   \   000066   8583..       MOV     ?V3,DPH
   \   000069   78..         MOV     R0,#?V2
   \   00006B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006E   78..         MOV     R0,#?V0
   \   000070   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000073   7406         MOV     A,#0x6
   \   000075   12....       LCALL   ?XSTACK_DISP0_8
   \   000078   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00007B   7417         MOV     A,#0x17
   \   00007D   12....       LCALL   ?XSTACK_DISP102_8
   \   000080   8E82         MOV     DPL,R6
   \   000082   8F83         MOV     DPH,R7
   \   000084   12....       LCALL   ??Subroutine75_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_96:
   \   000087   12....       LCALL   `??ZDSecMgrAppKeyGet::?relay`; Banked call to: ZDSecMgrAppKeyGet
   \   00008A   7408         MOV     A,#0x8
   \   00008C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00008F   E9           MOV     A,R1
   \   000090   7068         JNZ     ??ZDSecMgrAppKeyReq_0
   1230              {
   1231                // always secure
   1232                req.nwkSecure = TRUE;
   \   000092   740C         MOV     A,#0xc
   \   000094   12....       LCALL   ?XSTACK_DISP0_8
   \   000097   7401         MOV     A,#0x1
   \   000099   F0           MOVX    @DPTR,A
   1233                req.apsSecure = TRUE;
   \   00009A   740B         MOV     A,#0xb
   \   00009C   12....       LCALL   ?XSTACK_DISP0_8
   \   00009F   7401         MOV     A,#0x1
   \   0000A1   F0           MOVX    @DPTR,A
   1234                req.tunnel    = NULL;
   \   0000A2   740D         MOV     A,#0xd
   \   0000A4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A7   E4           CLR     A
   \   0000A8   F0           MOVX    @DPTR,A
   \   0000A9   A3           INC     DPTR
   \   0000AA   12....       LCALL   ?Subroutine34 & 0xFFFF
   1235          
   1236                // send key to initiator device
   1237                req.dstAddr   = ind->srcAddr;
   \                     ??CrossCallReturnLabel_22:
   \   0000AD   F9           MOV     R1,A
   \   0000AE   7402         MOV     A,#0x2
   \   0000B0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B3   12....       LCALL   ??Subroutine79_0 & 0xFFFF
   1238                req.extAddr   = ind->partExtAddr;
   \                     ??CrossCallReturnLabel_134:
   \   0000B6   7408         MOV     A,#0x8
   \   0000B8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BB   E5..         MOV     A,?V0
   \   0000BD   F0           MOVX    @DPTR,A
   \   0000BE   A3           INC     DPTR
   \   0000BF   E5..         MOV     A,?V1
   \   0000C1   F0           MOVX    @DPTR,A
   1239                req.initiator = TRUE;
   \   0000C2   740A         MOV     A,#0xa
   \   0000C4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C7   7401         MOV     A,#0x1
   \   0000C9   F0           MOVX    @DPTR,A
   1240                APSME_TransportKeyReq( &req );
   \   0000CA                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000CA   04           INC     A
   \   0000CB   12....       LCALL   ?XSTACK_DISP101_8
   \   0000CE   12....       LCALL   `??APSME_TransportKeyReq::?relay`; Banked call to: APSME_TransportKeyReq
   1241          
   1242                // send key to partner device
   1243                req.dstAddr   = partNwkAddr;
   \   0000D1   85..82       MOV     DPL,?XSP + 0
   \   0000D4   85..83       MOV     DPH,?XSP + 1
   \   0000D7   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   0000DA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DD   12....       LCALL   ??Subroutine79_0 & 0xFFFF
   1244                req.extAddr   = initExtAddr;
   \                     ??CrossCallReturnLabel_135:
   \   0000E0   740F         MOV     A,#0xf
   \   0000E2   12....       LCALL   ?XSTACK_DISP100_8
   \   0000E5   7408         MOV     A,#0x8
   \   0000E7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EA   12....       LCALL   ??Subroutine84_0 & 0xFFFF
   1245                req.initiator = FALSE;
   \                     ??CrossCallReturnLabel_183:
   \   0000ED   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F0   E4           CLR     A
   \   0000F1   F0           MOVX    @DPTR,A
   1246          
   1247                APSME_TransportKeyReq( &req );
   \   0000F2                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000F2   7402         MOV     A,#0x2
   \   0000F4   12....       LCALL   ?XSTACK_DISP101_8
   \   0000F7   12....       LCALL   `??APSME_TransportKeyReq::?relay`; Banked call to: APSME_TransportKeyReq
   1248              }
   1249            }
   1250          }
   \                     ??ZDSecMgrAppKeyReq_0:
   \   0000FA   7427         MOV     A,#0x27
   \   0000FC   02....       LJMP    ??Subroutine81_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000   12....       LCALL   ??Subroutine91_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_210:
   \   000003   7402         MOV     A,#0x2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   12....       LCALL   ??Subroutine93_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_219:
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine81_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine82_0
   \   000003                ; // Fall through to label ??Subroutine82_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine84_0:
   \   000000   12....       LCALL   ??Subroutine90_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_207:
   \   000003                ; Setup parameters for call to function AddrMgrEntryGet
   \   000003                ; Setup parameters for call to function AddrMgrEntryGet
   \   000003   740A         MOV     A,#0xa
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine51:
   \   000000   EE           MOV     A,R6
   \   000001   2405         ADD     A,#0x5
   \   000003   F5..         MOV     ?V0,A
   \   000005   E4           CLR     A
   \   000006   3F           ADDC    A,R7
   \   000007   F5..         MOV     ?V1,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine93_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET
   1251          
   1252          /******************************************************************************
   1253           * @fn          ZDSecMgrEstablishKey
   1254           *
   1255           * @brief       Start SKKE with device joining network.
   1256           *
   1257           * @param       device - [in] ZDSecMgrDevice_t, device info
   1258           *
   1259           * @return      ZStatus_t
   1260           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1261          ZStatus_t ZDSecMgrEstablishKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrEstablishKey:
   1262          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV     A,#-0x7
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1263            ZStatus_t               status;
   1264            APSME_EstablishKeyReq_t req;
   1265          
   1266          
   1267            req.respExtAddr = device->extAddr;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   12....       LCALL   ??Subroutine79_0 & 0xFFFF
   1268            req.method      = APSME_SKKE_METHOD;
   \                     ??CrossCallReturnLabel_136:
   \   00001D   7404         MOV     A,#0x4
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   E4           CLR     A
   \   000023   F0           MOVX    @DPTR,A
   1269          
   1270            if ( device->parentAddr == NLME_GetShortAddr() )
   \   000024                ; Setup parameters for call to function NLME_GetShortAddr
   \   000024   12....       LCALL   `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   000027   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_196:
   \   00002A   EA           MOV     A,R2
   \   00002B   68           XRL     A,R0
   \   00002C   7002         JNZ     ??ZDSecMgrEstablishKey_0
   \   00002E   EB           MOV     A,R3
   \   00002F   69           XRL     A,R1
   \                     ??ZDSecMgrEstablishKey_0:
   \   000030   7017         JNZ     ??ZDSecMgrEstablishKey_1
   1271            {
   1272              req.dstAddr   = device->nwkAddr;
   \   000032   8E82         MOV     DPL,R6
   \   000034   8F83         MOV     DPH,R7
   \   000036   12....       LCALL   ??Subroutine88_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_188:
   \   000039   12....       LCALL   ?Subroutine29 & 0xFFFF
   1273              //devtag.0604.todo - remove obsolete
   1274              req.apsSecure = FALSE;
   \                     ??CrossCallReturnLabel_80:
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   E4           CLR     A
   \   000040   F0           MOVX    @DPTR,A
   1275              req.nwkSecure = FALSE;
   \   000041   7406         MOV     A,#0x6
   \   000043   12....       LCALL   ?XSTACK_DISP0_8
   \   000046   E4           CLR     A
   \   000047   8010         SJMP    ??ZDSecMgrEstablishKey_2
   1276            }
   1277            else
   1278            {
   1279              req.dstAddr   = device->parentAddr;
   \                     ??ZDSecMgrEstablishKey_1:
   \   000049   12....       LCALL   ?Subroutine29 & 0xFFFF
   1280              //devtag.0604.todo - remove obsolete
   1281              req.apsSecure = TRUE;
   \                     ??CrossCallReturnLabel_81:
   \   00004C   12....       LCALL   ?XSTACK_DISP0_8
   \   00004F   7401         MOV     A,#0x1
   \   000051   F0           MOVX    @DPTR,A
   1282              req.nwkSecure = TRUE;
   \   000052   7406         MOV     A,#0x6
   \   000054   12....       LCALL   ?XSTACK_DISP0_8
   \   000057   7401         MOV     A,#0x1
   1283            }
   \                     ??ZDSecMgrEstablishKey_2:
   \   000059   12....       LCALL   ??Subroutine80_0 & 0xFFFF
   1284          
   1285            status = APSME_EstablishKeyReq( &req );
   1286          
   1287            return status;
   \                     ??CrossCallReturnLabel_152:
   \   00005C   12....       LCALL   `??APSME_EstablishKeyReq::?relay`; Banked call to: APSME_EstablishKeyReq
   \   00005F   7407         MOV     A,#0x7
   \   000061   02....       LJMP    ??Subroutine85_0 & 0xFFFF
   1288          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine67_0
   \   000006                ; // Fall through to label ??Subroutine67_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine67_0:
   \   000000   12....       LCALL   ??Subroutine90_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_205:
   \   000003                ; Setup parameters for call to function APSME_RemoveDeviceReq
   \   000003   7405         MOV     A,#0x5
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine44:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006                REQUIRE ??Subroutine87_0
   \   000006                ; // Fall through to label ??Subroutine87_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine87_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine88_0
   \   000002                ; // Fall through to label ??Subroutine88_0
   1289          
   1290          /******************************************************************************
   1291           * @fn          ZDSecMgrSendMasterKey
   1292           *
   1293           * @brief       Send MASTER key to device joining network.
   1294           *
   1295           * @param       device - [in] ZDSecMgrDevice_t, device info
   1296           *
   1297           * @return      ZStatus_t
   1298           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1299          ZStatus_t ZDSecMgrSendMasterKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrSendMasterKey:
   1300          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1301            ZStatus_t               status;
   1302            APSME_TransportKeyReq_t req;
   1303          
   1304          
   1305            req.keyType = KEY_TYPE_TC_MASTER;
   \   00000E   7402         MOV     A,#0x2
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   E4           CLR     A
   \   000014   12....       LCALL   ?Subroutine20 & 0xFFFF
   1306            req.extAddr = device->extAddr;
   \                     ??CrossCallReturnLabel_2:
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   12....       LCALL   ??Subroutine79_0 & 0xFFFF
   1307            req.tunnel  = NULL;
   \                     ??CrossCallReturnLabel_137:
   \   00001D   740B         MOV     A,#0xb
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   E4           CLR     A
   \   000023   F0           MOVX    @DPTR,A
   \   000024   A3           INC     DPTR
   \   000025   F0           MOVX    @DPTR,A
   1308          
   1309            ZDSecMgrMasterKeyLookup( device->ctrl->entry->ami, &req.key );
   \   000026                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000026   7404         MOV     A,#0x4
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   AC82         MOV     R4,DPL
   \   00002D   AD83         MOV     R5,DPH
   \   00002F   8E82         MOV     DPL,R6
   \   000031   8F83         MOV     DPH,R7
   \   000033   A3           INC     DPTR
   \   000034   A3           INC     DPTR
   \   000035   A3           INC     DPTR
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   12....       LCALL   ??Subroutine68_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_86:
   \   00003E   12....       LCALL   ??Subroutine68_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_87:
   \   000041   12....       LCALL   ??Subroutine75_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_97:
   \   000044   12....       LCALL   `??ZDSecMgrMasterKeyLookup::?relay`; Banked call to: ZDSecMgrMasterKeyLookup
   1310          
   1311            //check if using secure hop to to parent
   1312            if ( device->parentAddr != NLME_GetShortAddr() )
   \   000047                ; Setup parameters for call to function NLME_GetShortAddr
   \   000047   12....       LCALL   `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   00004A   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_197:
   \   00004D   EA           MOV     A,R2
   \   00004E   68           XRL     A,R0
   \   00004F   7002         JNZ     ??ZDSecMgrSendMasterKey_0
   \   000051   EB           MOV     A,R3
   \   000052   69           XRL     A,R1
   \                     ??ZDSecMgrSendMasterKey_0:
   \   000053   6012         JZ      ??ZDSecMgrSendMasterKey_1
   1313            {
   1314              //send to parent with security
   1315              req.dstAddr   = device->parentAddr;
   \   000055   12....       LCALL   ?Subroutine18 & 0xFFFF
   1316              req.nwkSecure = TRUE;
   \                     ??CrossCallReturnLabel_181:
   \   000058   12....       LCALL   ?XSTACK_DISP0_8
   \   00005B   7401         MOV     A,#0x1
   \   00005D   F0           MOVX    @DPTR,A
   1317              req.apsSecure = TRUE;
   \   00005E   7409         MOV     A,#0x9
   \   000060   12....       LCALL   ?XSTACK_DISP0_8
   \   000063   7401         MOV     A,#0x1
   \   000065   8015         SJMP    ??ZDSecMgrSendMasterKey_2
   1318            }
   1319            else
   1320            {
   1321              //direct with no security
   1322              req.dstAddr   = device->nwkAddr;
   \                     ??ZDSecMgrSendMasterKey_1:
   \   000067   8E82         MOV     DPL,R6
   \   000069   8F83         MOV     DPH,R7
   \   00006B   12....       LCALL   ??Subroutine88_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_189:
   \   00006E   12....       LCALL   ?Subroutine18 & 0xFFFF
   1323              req.nwkSecure = FALSE;
   \                     ??CrossCallReturnLabel_182:
   \   000071   12....       LCALL   ?XSTACK_DISP0_8
   \   000074   E4           CLR     A
   \   000075   F0           MOVX    @DPTR,A
   1324              req.apsSecure = FALSE;
   \   000076   7409         MOV     A,#0x9
   \   000078   12....       LCALL   ?XSTACK_DISP0_8
   \   00007B   E4           CLR     A
   1325            }
   \                     ??ZDSecMgrSendMasterKey_2:
   \   00007C   12....       LCALL   ??Subroutine80_0 & 0xFFFF
   1326          
   1327            status = APSME_TransportKeyReq( &req );
   1328          
   1329            return status;
   \                     ??CrossCallReturnLabel_153:
   \   00007F   12....       LCALL   `??APSME_TransportKeyReq::?relay`; Banked call to: APSME_TransportKeyReq
   \   000082   02....       LJMP    ?Subroutine2 & 0xFFFF
   1330          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_212:
   \   000008   7406         MOV     A,#0x6
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine84_0
   \   000006                ; // Fall through to label ??Subroutine84_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine60:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine91_0
   \   000002                ; // Fall through to label ??Subroutine91_0
   1331          
   1332          /******************************************************************************
   1333           * @fn          ZDSecMgrSendNwkKey
   1334           *
   1335           * @brief       Send NWK key to device joining network.
   1336           *
   1337           * @param       device - [in] ZDSecMgrDevice_t, device info
   1338           *
   1339           * @return      ZStatus_t
   1340           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1341          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrSendNwkKey:
   1342          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1343            ZStatus_t               status;
   1344            APSME_TransportKeyReq_t req;
   1345            APSDE_FrameTunnel_t     tunnel;
   1346          
   1347            req.dstAddr   = device->nwkAddr;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   12....       LCALL   ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   000015   E8           MOV     A,R0
   \   000016   F0           MOVX    @DPTR,A
   \   000017   A3           INC     DPTR
   \   000018   E9           MOV     A,R1
   \   000019   12....       LCALL   ?Subroutine20 & 0xFFFF
   1348            req.extAddr   = device->extAddr;
   \                     ??CrossCallReturnLabel_3:
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   12....       LCALL   ??Subroutine89_0 & 0xFFFF
   1349          
   1350            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   1351              req.keyType   = KEY_TYPE_NWK_HIGH;
   1352            else
   1353              req.keyType   = KEY_TYPE_NWK;
   \                     ??CrossCallReturnLabel_200:
   \   000022   12....       LCALL   ?XSTACK_DISP0_8
   \   000025   7401         MOV     A,#0x1
   \   000027   F0           MOVX    @DPTR,A
   1354          
   1355            if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   1356                || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   1357            {
   1358              // set values
   1359              req.keySeqNum = _NIB.nwkActiveKey.keySeqNum;
   1360              req.key       = _NIB.nwkActiveKey.key;
   1361              //devtag.pro.security.todo - make sure that if there is no link key the NWK
   1362              //key isn't used to secure the frame at the APS layer -- since the receiving
   1363              //device may not have a NWK key yet
   1364              req.apsSecure = TRUE;
   1365          
   1366              // check if using secure hop to to parent
   1367              if ( device->parentAddr == NLME_GetShortAddr() )
   1368              {
   1369                req.nwkSecure = FALSE;
   1370                req.tunnel    = NULL;
   1371              }
   1372              else
   1373              {
   1374                req.nwkSecure   = TRUE;
   1375                req.tunnel      = &tunnel;
   1376                req.tunnel->tna = device->parentAddr;
   1377                req.tunnel->dea = device->extAddr;
   1378              }
   1379            }
   1380            else
   1381            {
   1382              // default values
   1383              //devtag.0604.verify
   1384              req.nwkSecure = TRUE;
   \   000028   740A         MOV     A,#0xa
   \   00002A   12....       LCALL   ?XSTACK_DISP0_8
   \   00002D   7401         MOV     A,#0x1
   \   00002F   F0           MOVX    @DPTR,A
   1385              req.apsSecure = FALSE;
   \   000030   7409         MOV     A,#0x9
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   E4           CLR     A
   \   000036   F0           MOVX    @DPTR,A
   1386              req.tunnel    = NULL;
   \   000037   740B         MOV     A,#0xb
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   E4           CLR     A
   \   00003D   F0           MOVX    @DPTR,A
   \   00003E   A3           INC     DPTR
   \   00003F   F0           MOVX    @DPTR,A
   1387          
   1388              if ( device->parentAddr != NLME_GetShortAddr() )
   \   000040                ; Setup parameters for call to function NLME_GetShortAddr
   \   000040   12....       LCALL   `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   000043   8A..         MOV     ?V0,R2
   \   000045   8B..         MOV     ?V1,R3
   \   000047   A8..         MOV     R0,?V0
   \   000049   A9..         MOV     R1,?V1
   \   00004B   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   00004E   85..82       MOV     DPL,?V0
   \   000051   F583         MOV     DPH,A
   \   000053   12....       LCALL   ??Subroutine75_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_98:
   \   000056   E8           MOV     A,R0
   \   000057   6A           XRL     A,R2
   \   000058   7002         JNZ     ??ZDSecMgrSendNwkKey_0
   \   00005A   E9           MOV     A,R1
   \   00005B   6B           XRL     A,R3
   \                     ??ZDSecMgrSendNwkKey_0:
   \   00005C   6009         JZ      ??CrossCallReturnLabel_125
   1389              {
   1390                req.dstAddr = device->parentAddr;
   \   00005E   85..82       MOV     DPL,?XSP + 0
   \   000061   85..83       MOV     DPH,?XSP + 1
   \   000064   12....       LCALL   ??Subroutine78_0 & 0xFFFF
   1391              }
   1392          
   1393              // special cases
   1394              //devtag.0604.todo - modify to preconfig flag
   1395              if ( device->secure == FALSE )
   \                     ??CrossCallReturnLabel_125:
   \   000067   8E82         MOV     DPL,R6
   \   000069   8F83         MOV     DPH,R7
   \   00006B   A3           INC     DPTR
   \   00006C   A3           INC     DPTR
   \   00006D   A3           INC     DPTR
   \   00006E   A3           INC     DPTR
   \   00006F   A3           INC     DPTR
   \   000070   A3           INC     DPTR
   \   000071   E0           MOVX    A,@DPTR
   \   000072   7038         JNZ     ??ZDSecMgrSendNwkKey_1
   1396              {
   1397                req.keySeqNum = _NIB.nwkActiveKey.keySeqNum;
   \   000074   90....       MOV     DPTR,#_NIB + 62
   \   000077   E0           MOVX    A,@DPTR
   \   000078   C0E0         PUSH    A
   \   00007A   7403         MOV     A,#0x3
   \   00007C   12....       LCALL   ?XSTACK_DISP0_8
   \   00007F   D0E0         POP     A
   \   000081   F0           MOVX    @DPTR,A
   1398                req.key       = _NIB.nwkActiveKey.key;
   \   000082   7404         MOV     A,#0x4
   \   000084   12....       LCALL   ?XSTACK_DISP0_8
   \   000087   74..         MOV     A,#(_NIB + 63) & 0xff
   \   000089   F0           MOVX    @DPTR,A
   \   00008A   A3           INC     DPTR
   \   00008B   74..         MOV     A,#((_NIB + 63) >> 8) & 0xff
   \   00008D   F0           MOVX    @DPTR,A
   1399          
   1400                // check if using secure hop to to parent
   1401                if ( device->parentAddr == NLME_GetShortAddr() )
   \   00008E                ; Setup parameters for call to function NLME_GetShortAddr
   \   00008E   12....       LCALL   `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   000091   8A..         MOV     ?V2,R2
   \   000093   8B..         MOV     ?V3,R3
   \   000095   A8..         MOV     R0,?V2
   \   000097   A9..         MOV     R1,?V3
   \   000099   85..82       MOV     DPL,?V0
   \   00009C   85..83       MOV     DPH,?V1
   \   00009F   E0           MOVX    A,@DPTR
   \   0000A0   68           XRL     A,R0
   \   0000A1   7003         JNZ     ??ZDSecMgrSendNwkKey_2
   \   0000A3   A3           INC     DPTR
   \   0000A4   E0           MOVX    A,@DPTR
   \   0000A5   69           XRL     A,R1
   \                     ??ZDSecMgrSendNwkKey_2:
   \   0000A6   7014         JNZ     ??ZDSecMgrSendNwkKey_3
   1402                {
   1403                  req.nwkSecure = FALSE;
   \   0000A8   740A         MOV     A,#0xa
   \   0000AA   800B         SJMP    ??ZDSecMgrSendNwkKey_4
   1404                }
   1405              }
   1406              else
   1407              {
   1408                req.key       = NULL;
   \                     ??ZDSecMgrSendNwkKey_1:
   \   0000AC   7404         MOV     A,#0x4
   \   0000AE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B1   E4           CLR     A
   \   0000B2   F0           MOVX    @DPTR,A
   \   0000B3   A3           INC     DPTR
   \   0000B4   F0           MOVX    @DPTR,A
   1409                req.keySeqNum = 0;
   \   0000B5   7403         MOV     A,#0x3
   \                     ??ZDSecMgrSendNwkKey_4:
   \   0000B7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BA   E4           CLR     A
   \   0000BB   F0           MOVX    @DPTR,A
   1410              }
   1411            }
   1412          
   1413            status = APSME_TransportKeyReq( &req );
   1414          
   1415            return status;
   \                     ??ZDSecMgrSendNwkKey_3:
   \   0000BC                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000BC   AA..         MOV     R2,?XSP + 0
   \   0000BE   AB..         MOV     R3,?XSP + 1
   \   0000C0   12....       LCALL   `??APSME_TransportKeyReq::?relay`; Banked call to: APSME_TransportKeyReq
   \   0000C3   740D         MOV     A,#0xd
   \   0000C5   02....       LJMP    ??Subroutine81_0 & 0xFFFF
   1416          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine89_0:
   \   000000   12....       LCALL   ??Subroutine90_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_208:
   \   000003   7402         MOV     A,#0x2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine52:
   \   000000   EE           MOV     A,R6
   \   000001   2404         ADD     A,#0x4
   \   000003   F5..         MOV     ?V0,A
   \   000005   E4           CLR     A
   \   000006   3F           ADDC    A,R7
   \   000007   F5..         MOV     ?V1,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine43:
   \   000000   12....       LCALL   ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine59:
   \   000000   12....       LCALL   ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_215:
   \   000003   85..82       MOV     DPL,?XSP + 0
   \   000006   85..83       MOV     DPH,?XSP + 1
   \   000009   22           RET
   1417          
   1418          /******************************************************************************
   1419           * @fn          ZDSecMgrDeviceEntryRemove
   1420           *
   1421           * @brief       Remove device entry.
   1422           *
   1423           * @param       entry - [in] valid entry
   1424           *
   1425           * @return      none
   1426           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1427          void ZDSecMgrDeviceEntryRemove( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrDeviceEntryRemove:
   \   000000   02....       LJMP    ?Subroutine0 & 0xFFFF
   1428          {
   1429            // terminate device control
   1430            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1431            {
   1432              ZDSecMgrCtrlTerm( entry );
   1433            }
   1434          
   1435            // remove device from entry data
   1436            ZDSecMgrEntryFree( entry );
   1437          
   1438            // remove EXT address
   1439            //ZDSecMgrExtAddrRelease( aiOld );
   1440          }
   1441          
   1442          /******************************************************************************
   1443           * @fn          ZDSecMgrDeviceRemoveByExtAddr
   1444           *
   1445           * @brief       Remove device entry by its ext address.
   1446           *
   1447           * @param       pAddr - pointer to the extended address
   1448           *
   1449           * @return      ZStatus_t
   1450           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1451          ZStatus_t ZDSecMgrDeviceRemoveByExtAddr( uint8 *pAddr )
   \                     ZDSecMgrDeviceRemoveByExtAddr:
   1452          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 2
   \   000004   74FE         MOV     A,#-0x2
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   1453            ZDSecMgrEntry_t *pEntry;
   1454            uint8           retValue;
   1455            
   1456            retValue = (uint8)ZDSecMgrEntryLookupExt( pAddr, &pEntry );
   \   000009                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   000009   AC..         MOV     R4,?XSP + 0
   \   00000B   AD..         MOV     R5,?XSP + 1
   \   00000D   12....       LCALL   `??ZDSecMgrEntryLookupExt::?relay`; Banked call to: ZDSecMgrEntryLookupExt
   \   000010   E9           MOV     A,R1
   \   000011   F9           MOV     R1,A
   1457            
   1458            if( retValue == ZSuccess )
   \   000012   700B         JNZ     ??CrossCallReturnLabel_38
   1459            {
   1460              ZDSecMgrDeviceEntryRemove( pEntry );
   \   000014   85..82       MOV     DPL,?XSP + 0
   \   000017   85..83       MOV     DPH,?XSP + 1
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F8           MOV     R0,A
   \   00001C   12....       LCALL   ?Subroutine45 & 0xFFFF
   1461            }
   1462            
   1463            return retValue;
   \                     ??CrossCallReturnLabel_38:
   \   00001F   02....       LJMP    ?Subroutine8 & 0xFFFF
   1464          }
   1465          
   1466          /******************************************************************************
   1467           * @fn          ZDSecMgrDeviceEntryAdd
   1468           *
   1469           * @brief       Add entry.
   1470           *
   1471           * @param       device - [in] ZDSecMgrDevice_t, device info
   1472           * @param       ami    - [in] Address Manager index
   1473           *
   1474           * @return      ZStatus_t
   1475           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1476          void ZDSecMgrAddrMgrUpdate( uint16 ami, uint16 nwkAddr )
   \                     ZDSecMgrAddrMgrUpdate:
   1477          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   1478            AddrMgrEntry_t entry;
   1479          
   1480            // get the ami data
   1481            entry.user  = ADDRMGR_USER_SECURITY;
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   7402         MOV     A,#0x2
   \   000016   F0           MOVX    @DPTR,A
   1482            entry.index = ami;
   \   000017   740B         MOV     A,#0xb
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   EA           MOV     A,R2
   \   00001D   F0           MOVX    @DPTR,A
   \   00001E   A3           INC     DPTR
   \   00001F   EB           MOV     A,R3
   \   000020   12....       LCALL   ??Subroutine80_0 & 0xFFFF
   1483          
   1484            AddrMgrEntryGet( &entry );
   \                     ??CrossCallReturnLabel_154:
   \   000023   12....       LCALL   `??AddrMgrEntryGet::?relay`; Banked call to: AddrMgrEntryGet
   1485          
   1486            // check if NWK address is same
   1487            if ( entry.nwkAddr != nwkAddr )
   \   000026   7401         MOV     A,#0x1
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   6E           XRL     A,R6
   \   00002D   7003         JNZ     ??ZDSecMgrAddrMgrUpdate_0
   \   00002F   A3           INC     DPTR
   \   000030   E0           MOVX    A,@DPTR
   \   000031   6F           XRL     A,R7
   \                     ??ZDSecMgrAddrMgrUpdate_0:
   \   000032   600F         JZ      ??ZDSecMgrAddrMgrUpdate_1
   1488            {
   1489              // update NWK address
   1490              entry.nwkAddr = nwkAddr;
   \   000034   7401         MOV     A,#0x1
   \   000036   12....       LCALL   ?XSTACK_DISP0_8
   \   000039   EE           MOV     A,R6
   \   00003A   F0           MOVX    @DPTR,A
   \   00003B   A3           INC     DPTR
   \   00003C   EF           MOV     A,R7
   \   00003D   12....       LCALL   ??Subroutine80_0 & 0xFFFF
   1491          
   1492              AddrMgrEntryUpdate( &entry );
   1493            }
   \                     ??CrossCallReturnLabel_155:
   \   000040   12....       LCALL   `??AddrMgrEntryUpdate::?relay`; Banked call to: AddrMgrEntryUpdate
   1494          }
   \                     ??ZDSecMgrAddrMgrUpdate_1:
   \   000043   02....       LJMP    ?Subroutine9 & 0xFFFF
   1495          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine46:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine68_0
   \   000006                ; // Fall through to label ??Subroutine68_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1496          ZStatus_t ZDSecMgrDeviceEntryAdd( ZDSecMgrDevice_t* device, uint16 ami )
   \                     ZDSecMgrDeviceEntryAdd:
   1497          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V2,R2
   \   00000C   8B..         MOV     ?V3,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   1498            ZStatus_t        status;
   1499            ZDSecMgrEntry_t* entry;
   1500          
   1501          
   1502            // initialize as unknown until completion
   1503            status = ZNwkUnknownDevice;
   \   000012   75..C8       MOV     ?V0,#-0x38
   1504          
   1505            device->ctrl = NULL;
   \   000015   8A82         MOV     DPL,R2
   \   000017   8B83         MOV     DPH,R3
   \   000019   A3           INC     DPTR
   \   00001A   A3           INC     DPTR
   \   00001B   A3           INC     DPTR
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   E4           CLR     A
   \   000022   F0           MOVX    @DPTR,A
   \   000023   A3           INC     DPTR
   \   000024   F0           MOVX    @DPTR,A
   1506          
   1507            // make sure not already registered
   1508            if ( ZDSecMgrEntryLookup( device->nwkAddr, &entry ) == ZSuccess )
   \   000025                ; Setup parameters for call to function ZDSecMgrEntryLookup
   \   000025   AC..         MOV     R4,?XSP + 0
   \   000027   AD..         MOV     R5,?XSP + 1
   \   000029   8A82         MOV     DPL,R2
   \   00002B   8B83         MOV     DPH,R3
   \   00002D   12....       LCALL   ??Subroutine75_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_99:
   \   000030   12....       LCALL   `??ZDSecMgrEntryLookup::?relay`; Banked call to: ZDSecMgrEntryLookup
   \   000033   E9           MOV     A,R1
   \   000034   7025         JNZ     ??ZDSecMgrDeviceEntryAdd_0
   1509            {
   1510              // verify that address index is same
   1511              if ( entry->ami != ami )
   \   000036   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_88:
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   6E           XRL     A,R6
   \   00003B   7003         JNZ     ??ZDSecMgrDeviceEntryAdd_1
   \   00003D   A3           INC     DPTR
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   6F           XRL     A,R7
   \                     ??ZDSecMgrDeviceEntryAdd_1:
   \   000040   602D         JZ      ??ZDSecMgrDeviceEntryAdd_2
   1512              {
   1513                // remove conflicting entry
   1514                ZDSecMgrDeviceEntryRemove( entry );
   \   000042   85..82       MOV     DPL,?XSP + 0
   \   000045   85..83       MOV     DPH,?XSP + 1
   \   000048   12....       LCALL   ?Subroutine45 & 0xFFFF
   1515          
   1516                if ( ZDSecMgrEntryLookupAMI( ami, &entry ) == ZSuccess )
   \                     ??CrossCallReturnLabel_39:
   \   00004B                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   00004B   AC..         MOV     R4,?XSP + 0
   \   00004D   AD..         MOV     R5,?XSP + 1
   \   00004F   EE           MOV     A,R6
   \   000050   FA           MOV     R2,A
   \   000051   EF           MOV     A,R7
   \   000052   FB           MOV     R3,A
   \   000053   12....       LCALL   `??ZDSecMgrEntryLookupAMI::?relay`; Banked call to: ZDSecMgrEntryLookupAMI
   \   000056   E9           MOV     A,R1
   \   000057   7016         JNZ     ??ZDSecMgrDeviceEntryAdd_2
   \   000059   800E         SJMP    ??ZDSecMgrDeviceEntryAdd_3
   1517                {
   1518                  // update NWK address
   1519                  ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   1520                }
   1521              }
   1522            }
   1523            else if ( ZDSecMgrEntryLookupAMI( ami, &entry ) == ZSuccess )
   \                     ??ZDSecMgrDeviceEntryAdd_0:
   \   00005B                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   00005B   AC..         MOV     R4,?XSP + 0
   \   00005D   AD..         MOV     R5,?XSP + 1
   \   00005F   EE           MOV     A,R6
   \   000060   FA           MOV     R2,A
   \   000061   EF           MOV     A,R7
   \   000062   FB           MOV     R3,A
   \   000063   12....       LCALL   `??ZDSecMgrEntryLookupAMI::?relay`; Banked call to: ZDSecMgrEntryLookupAMI
   \   000066   E9           MOV     A,R1
   \   000067   7006         JNZ     ??ZDSecMgrDeviceEntryAdd_2
   1524            {
   1525              // update NWK address
   1526              ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   \                     ??ZDSecMgrDeviceEntryAdd_3:
   \   000069                ; Setup parameters for call to function ZDSecMgrAddrMgrUpdate
   \   000069   12....       LCALL   ?Subroutine37 & 0xFFFF
   1527            }
   \                     ??CrossCallReturnLabel_227:
   \   00006C   12....       LCALL   `??ZDSecMgrAddrMgrUpdate::?relay`; Banked call to: ZDSecMgrAddrMgrUpdate
   1528          
   1529            // check if a new entry needs to be created
   1530            if ( entry == NULL )
   \                     ??ZDSecMgrDeviceEntryAdd_2:
   \   00006F   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_175:
   \   000072   7018         JNZ     ??ZDSecMgrDeviceEntryAdd_4
   1531            {
   1532              // get new entry
   1533              if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   \   000074                ; Setup parameters for call to function ZDSecMgrEntryNew
   \   000074   AA..         MOV     R2,?XSP + 0
   \   000076   AB..         MOV     R3,?XSP + 1
   \   000078   12....       LCALL   `??ZDSecMgrEntryNew::?relay`; Banked call to: ZDSecMgrEntryNew
   \   00007B   E9           MOV     A,R1
   \   00007C   7011         JNZ     ??ZDSecMgrDeviceEntryAdd_5
   1534              {
   1535                // reset entry lkd
   1536          
   1537                // finish setting up entry
   1538                entry->ami = ami;
   \   00007E   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_89:
   \   000081   EE           MOV     A,R6
   \   000082   F0           MOVX    @DPTR,A
   \   000083   A3           INC     DPTR
   \   000084   EF           MOV     A,R7
   \   000085   F0           MOVX    @DPTR,A
   1539          
   1540                // update NWK address
   1541                ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   \   000086                ; Setup parameters for call to function ZDSecMgrAddrMgrUpdate
   \   000086   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_228:
   \   000089   12....       LCALL   `??ZDSecMgrAddrMgrUpdate::?relay`; Banked call to: ZDSecMgrAddrMgrUpdate
   1542          
   1543                // enter new device into device control
   1544                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1545                {
   1546                  status = ZDSecMgrCtrlAdd( device, entry );
   1547                }
   1548                else
   1549                {
   1550                  status = ZSuccess;
   1551                }
   1552              }
   1553            }
   1554            else
   1555            {
   1556              // reset entry lkd
   1557          
   1558              // reset entry in entry control
   1559              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1560              {
   1561                status = ZDSecMgrCtrlReset( device, entry );
   1562              }
   1563              else
   1564              {
   1565                status = ZSuccess;
   \                     ??ZDSecMgrDeviceEntryAdd_4:
   \   00008C   75..00       MOV     ?V0,#0x0
   1566              }
   1567            }
   1568          
   1569            return status;
   \                     ??ZDSecMgrDeviceEntryAdd_5:
   \   00008F   A9..         MOV     R1,?V0
   \   000091   02....       LJMP    ?Subroutine4 & 0xFFFF
   1570          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   7402         MOV     A,#0x2
   \   000002                REQUIRE ??Subroutine81_0
   \   000002                ; // Fall through to label ??Subroutine81_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000   85..82       MOV     DPL,?V2
   \   000003   85..83       MOV     DPH,?V3
   \   000006                REQUIRE ??Subroutine94_0
   \   000006                ; // Fall through to label ??Subroutine94_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine94_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FD           MOV     R5,A
   \   000005   EE           MOV     A,R6
   \   000006   FA           MOV     R2,A
   \   000007   EF           MOV     A,R7
   \   000008   FB           MOV     R3,A
   \   000009   22           RET
   1571          
   1572          /******************************************************************************
   1573           * @fn          ZDSecMgrDeviceCtrlHandler
   1574           *
   1575           * @brief       Device control handler.
   1576           *
   1577           * @param       device - [in] ZDSecMgrDevice_t, device info
   1578           *
   1579           * @return      none
   1580           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1581          void ZDSecMgrDeviceCtrlHandler( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceCtrlHandler:
   1582          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   1583            uint8 state;
   1584            uint8 cntr;
   1585          
   1586          
   1587            state = device->ctrl->state;
   \   000005   EA           MOV     A,R2
   \   000006   2408         ADD     A,#0x8
   \   000008   FE           MOV     R6,A
   \   000009   E4           CLR     A
   \   00000A   3B           ADDC    A,R3
   \   00000B   FF           MOV     R7,A
   \   00000C   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   F5..         MOV     ?V0,A
   1588            cntr  = ZDSECMGR_CTRL_BASE_CNTR;
   1589          
   1590            switch ( state )
   \   000012   24FE         ADD     A,#-0x2
   \   000014   600C         JZ      ??ZDSecMgrDeviceCtrlHandler_0
   \   000016   14           DEC     A
   \   000017   6014         JZ      ??ZDSecMgrDeviceCtrlHandler_1
   \   000019   14           DEC     A
   \   00001A   6022         JZ      ??ZDSecMgrDeviceCtrlHandler_2
   \   00001C   24FD         ADD     A,#-0x3
   \   00001E   6018         JZ      ??ZDSecMgrDeviceCtrlHandler_3
   \   000020   8039         SJMP    ??ZDSecMgrDeviceCtrlHandler_4
   1591            {
   1592              case ZDSECMGR_CTRL_TK_MASTER:
   1593                if ( ZDSecMgrSendMasterKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_0:
   \   000022                ; Setup parameters for call to function ZDSecMgrSendMasterKey
   \   000022   12....       LCALL   `??ZDSecMgrSendMasterKey::?relay`; Banked call to: ZDSecMgrSendMasterKey
   \   000025   E9           MOV     A,R1
   \   000026   7016         JNZ     ??ZDSecMgrDeviceCtrlHandler_2
   1594                {
   1595                  state = ZDSECMGR_CTRL_SKKE_INIT;
   \   000028   75..03       MOV     ?V0,#0x3
   1596                  cntr  = ZDSECMGR_CTRL_SKKE_INIT_CNTR;
   \   00002B   8011         SJMP    ??ZDSecMgrDeviceCtrlHandler_2
   1597                }
   1598                break;
   1599          
   1600              case ZDSECMGR_CTRL_SKKE_INIT:
   1601                if ( ZDSecMgrEstablishKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_1:
   \   00002D                ; Setup parameters for call to function ZDSecMgrEstablishKey
   \   00002D   12....       LCALL   `??ZDSecMgrEstablishKey::?relay`; Banked call to: ZDSecMgrEstablishKey
   \   000030   E9           MOV     A,R1
   \   000031   700B         JNZ     ??ZDSecMgrDeviceCtrlHandler_2
   1602                {
   1603                  state = ZDSECMGR_CTRL_SKKE_WAIT;
   \   000033   75..04       MOV     ?V0,#0x4
   \   000036   8006         SJMP    ??ZDSecMgrDeviceCtrlHandler_2
   1604                }
   1605                break;
   1606          
   1607              case ZDSECMGR_CTRL_SKKE_WAIT:
   1608                // continue to wait for SKA control timeout
   1609                break;
   1610          
   1611              case ZDSECMGR_CTRL_TK_NWK:
   1612                if ( ZDSecMgrSendNwkKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_3:
   \   000038                ; Setup parameters for call to function ZDSecMgrSendNwkKey
   \   000038   12....       LCALL   `??ZDSecMgrSendNwkKey::?relay`; Banked call to: ZDSecMgrSendNwkKey
   \   00003B   E9           MOV     A,R1
   \   00003C   601D         JZ      ??ZDSecMgrDeviceCtrlHandler_4
   1613                {
   1614                  state = ZDSECMGR_CTRL_NONE;
   1615                }
   1616                break;
   1617          
   1618              default:
   1619                state = ZDSECMGR_CTRL_NONE;
   1620                break;
   1621            }
   1622          
   1623            if ( state != ZDSECMGR_CTRL_NONE )
   1624            {
   1625              device->ctrl->state = state;
   \                     ??ZDSecMgrDeviceCtrlHandler_2:
   \   00003E   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   000041   E5..         MOV     A,?V0
   \   000043   12....       LCALL   ?Subroutine34 & 0xFFFF
   1626              device->ctrl->cntr  = cntr;
   \                     ??CrossCallReturnLabel_23:
   \   000046   C8           XCH     A,R0
   \   000047   12....       LCALL   ?Subroutine50 & 0xFFFF
   1627          
   1628              osal_start_timerEx(ZDAppTaskID, ZDO_SECMGR_EVENT, 100 );
   \                     ??CrossCallReturnLabel_53:
   \   00004A                ; Setup parameters for call to function osal_start_timerEx
   \   00004A   7C64         MOV     R4,#0x64
   \   00004C   7D00         MOV     R5,#0x0
   \   00004E   7A00         MOV     R2,#0x0
   \   000050   FB           MOV     R3,A
   \   000051   90....       MOV     DPTR,#ZDAppTaskID
   \   000054   E0           MOVX    A,@DPTR
   \   000055   F9           MOV     R1,A
   \   000056   12....       LCALL   `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   000059   8005         SJMP    ??ZDSecMgrDeviceCtrlHandler_5
   1629            }
   1630            else
   1631            {
   1632              ZDSecMgrCtrlRelease( device->ctrl );
   \                     ??ZDSecMgrDeviceCtrlHandler_4:
   \   00005B   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_26:
   \   00005E   E4           CLR     A
   \   00005F   F0           MOVX    @DPTR,A
   1633            }
   1634          }
   \                     ??ZDSecMgrDeviceCtrlHandler_5:
   \   000060   02....       LJMP    ??Subroutine72_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   12....       LCALL   ??Subroutine93_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_220:
   \   000007   F583         MOV     DPH,A
   \   000009   8882         MOV     DPL,R0
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine50:
   \   000000   2406         ADD     A,#0x6
   \   000002   F582         MOV     DPL,A
   \   000004   E4           CLR     A
   \   000005   38           ADDC    A,R0
   \   000006   F583         MOV     DPH,A
   \   000008   7401         MOV     A,#0x1
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   22           RET
   1635          
   1636          /******************************************************************************
   1637           * @fn          ZDSecMgrDeviceCtrlSetup
   1638           *
   1639           * @brief       Setup device control.
   1640           *
   1641           * @param       device - [in] ZDSecMgrDevice_t, device info
   1642           *
   1643           * @return      ZStatus_t
   1644           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1645          void ZDSecMgrDeviceCtrlSetup( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceCtrlSetup:
   1646          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1647            if ( device->ctrl != NULL )
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   12....       LCALL   ??Subroutine83_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_168:
   \   000013   6022         JZ      ??ZDSecMgrDeviceCtrlSetup_0
   1648            {
   1649              if ( device->secure == FALSE )
   \   000015   E8           MOV     A,R0
   \   000016   2405         ADD     A,#0x5
   \   000018   F8           MOV     R0,A
   \   000019   5001         JNC     ??ZDSecMgrDeviceCtrlSetup_1
   \   00001B   09           INC     R1
   \                     ??ZDSecMgrDeviceCtrlSetup_1:
   \   00001C   8A82         MOV     DPL,R2
   \   00001E   8B83         MOV     DPH,R3
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   A3           INC     DPTR
   \   000024   A3           INC     DPTR
   \   000025   A3           INC     DPTR
   \   000026   E0           MOVX    A,@DPTR
   \   000027   8882         MOV     DPL,R0
   \   000029   8983         MOV     DPH,R1
   \   00002B   7004         JNZ     ??ZDSecMgrDeviceCtrlSetup_2
   1650              {
   1651                // send the master key data to the joining device
   1652                device->ctrl->state = ZDSECMGR_CTRL_TK_MASTER;
   \   00002D   7402         MOV     A,#0x2
   \   00002F   8002         SJMP    ??ZDSecMgrDeviceCtrlSetup_3
   1653              }
   1654              else
   1655              {
   1656                // start SKKE
   1657                device->ctrl->state = ZDSECMGR_CTRL_SKKE_INIT;
   \                     ??ZDSecMgrDeviceCtrlSetup_2:
   \   000031   7403         MOV     A,#0x3
   \                     ??ZDSecMgrDeviceCtrlSetup_3:
   \   000033   F0           MOVX    @DPTR,A
   1658              }
   1659          
   1660              ZDSecMgrDeviceCtrlHandler( device );
   \   000034                ; Setup parameters for call to function ZDSecMgrDeviceCtrlHandler
   \   000034   12....       LCALL   `??ZDSecMgrDeviceCtrlHandler::?relay`; Banked call to: ZDSecMgrDeviceCtrlHandler
   1661            }
   1662          }
   \                     ??ZDSecMgrDeviceCtrlSetup_0:
   \   000037   02....       LJMP    ??Subroutine77_0 & 0xFFFF
   1663          
   1664          /******************************************************************************
   1665           * @fn          ZDSecMgrDeviceCtrlUpdate
   1666           *
   1667           * @brief       Update control data.
   1668           *
   1669           * @param       extAddr - [in] EXT address
   1670           * @param       state   - [in] new control state
   1671           *
   1672           * @return      none
   1673           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1674          void ZDSecMgrDeviceCtrlUpdate( uint8* extAddr, uint8 state )
   \                     ZDSecMgrDeviceCtrlUpdate:
   1675          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   1676            ZDSecMgrEntry_t* entry;
   1677            ZDSecMgrCtrl_t*  ctrl;
   1678          
   1679          
   1680            // lookup device entry data
   1681            ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000C                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000C   7402         MOV     A,#0x2
   \   00000E   12....       LCALL   ?XSTACK_DISP102_8
   \   000011   12....       LCALL   `??ZDSecMgrEntryLookupExt::?relay`; Banked call to: ZDSecMgrEntryLookupExt
   1682          
   1683            if ( entry != NULL )
   \   000014   7402         MOV     A,#0x2
   \   000016   12....       LCALL   ?XSTACK_DISP0_8
   \   000019   12....       LCALL   ??Subroutine83_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_169:
   \   00001C   6042         JZ      ??CrossCallReturnLabel_54
   1684            {
   1685              // lookup device control data
   1686              ZDSecMgrCtrlLookup( entry, &ctrl );
   \   00001E                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   00001E   AC..         MOV     R4,?XSP + 0
   \   000020   AD..         MOV     R5,?XSP + 1
   \   000022   7402         MOV     A,#0x2
   \   000024   12....       LCALL   ?XSTACK_DISP0_8
   \   000027   12....       LCALL   ??Subroutine75_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_100:
   \   00002A   12....       LCALL   `??ZDSecMgrCtrlLookup::?relay`; Banked call to: ZDSecMgrCtrlLookup
   1687          
   1688              // make sure control data is valid
   1689              if ( ctrl != NULL )
   \   00002D   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_176:
   \   000030   602E         JZ      ??CrossCallReturnLabel_54
   1690              {
   1691                // possible state transitions
   1692                if ( ctrl->state == ZDSECMGR_CTRL_SKKE_WAIT )
   \   000032   85..82       MOV     DPL,?XSP + 0
   \   000035   85..83       MOV     DPH,?XSP + 1
   \   000038   E0           MOVX    A,@DPTR
   \   000039   2405         ADD     A,#0x5
   \   00003B   F8           MOV     R0,A
   \   00003C   A3           INC     DPTR
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   3400         ADDC    A,#0x0
   \   000040   F9           MOV     R1,A
   \   000041   8882         MOV     DPL,R0
   \   000043   8983         MOV     DPH,R1
   \   000045   E0           MOVX    A,@DPTR
   \   000046   6404         XRL     A,#0x4
   \   000048   7016         JNZ     ??CrossCallReturnLabel_54
   1693                {
   1694                  if ( state == ZDSECMGR_CTRL_SKKE_DONE )
   \   00004A   7405         MOV     A,#0x5
   \   00004C   6E           XRL     A,R6
   \   00004D   7004         JNZ     ??ZDSecMgrDeviceCtrlUpdate_0
   1695                  {
   1696                    // send the network key
   1697                    ctrl->state = ZDSECMGR_CTRL_TK_NWK;
   \   00004F   7407         MOV     A,#0x7
   \   000051   8007         SJMP    ??ZDSecMgrDeviceCtrlUpdate_1
   1698                    ctrl->cntr  = ZDSECMGR_CTRL_TK_NWK_CNTR;
   1699                  }
   1700                  else if ( state == ZDSECMGR_CTRL_SKKE_FAIL )
   \                     ??ZDSecMgrDeviceCtrlUpdate_0:
   \   000053   7406         MOV     A,#0x6
   \   000055   6E           XRL     A,R6
   \   000056   7008         JNZ     ??CrossCallReturnLabel_54
   1701                  {
   1702                    // force default timeout in order to cleanup control logic
   1703                    ctrl->state = ZDSECMGR_CTRL_SKKE_FAIL;
   \   000058   7406         MOV     A,#0x6
   1704                    ctrl->cntr  = ZDSECMGR_CTRL_BASE_CNTR;
   1705                  }
   1706                }
   1707                // timer should be active
   1708              }
   1709            }
   \                     ??ZDSecMgrDeviceCtrlUpdate_1:
   \   00005A   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   00005D   12....       LCALL   ?Subroutine50 & 0xFFFF
   1710          }
   \                     ??CrossCallReturnLabel_54:
   \   000060                REQUIRE ?Subroutine10
   \   000060                ; // Fall through to label ?Subroutine10

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   7404         MOV     A,#0x4
   \   000002   80..         SJMP    ??Subroutine71_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine62:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine93_0
   \   000006                ; // Fall through to label ??Subroutine93_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_223:
   \   000004   C8           XCH     A,R0
   \   000005   22           RET
   1711          
   1712          void APSME_SKA_TimerExpired( uint8 initiator, uint8* partExtAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1713          void APSME_SKA_TimerExpired( uint8 initiator, uint8* partExtAddr )
   \                     APSME_SKA_TimerExpired:
   1714          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1715            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1716            {
   1717              if ( initiator == TRUE )
   1718              {
   1719                ZDSecMgrDeviceCtrlUpdate( partExtAddr, ZDSECMGR_CTRL_SKKE_FAIL );
   1720              }
   1721            }
   1722          }
   \   000000   02....       LJMP    ?BRET
   1723          
   1724          /******************************************************************************
   1725           * @fn          ZDSecMgrDeviceRemove
   1726           *
   1727           * @brief       Remove device from network.
   1728           *
   1729           * @param       device - [in] ZDSecMgrDevice_t, device info
   1730           *
   1731           * @return      none
   1732           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1733          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceRemove:
   1734          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV     A,#-0x9
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1735            APSME_RemoveDeviceReq_t remDevReq;
   1736            NLME_LeaveReq_t         leaveReq;
   1737            associated_devices_t*   assoc;
   1738          
   1739          
   1740            // check if parent, remove the device
   1741            if ( device->parentAddr == NLME_GetShortAddr() )
   \   00000E                ; Setup parameters for call to function NLME_GetShortAddr
   \   00000E   12....       LCALL   `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   000011   8A..         MOV     ?V0,R2
   \   000013   8B..         MOV     ?V1,R3
   \   000015   8E82         MOV     DPL,R6
   \   000017   8F83         MOV     DPH,R7
   \   000019   A3           INC     DPTR
   \   00001A   A3           INC     DPTR
   \   00001B   A3           INC     DPTR
   \   00001C   A3           INC     DPTR
   \   00001D   12....       LCALL   ??Subroutine75_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_101:
   \   000020   EE           MOV     A,R6
   \   000021   2402         ADD     A,#0x2
   \   000023   F8           MOV     R0,A
   \   000024   E4           CLR     A
   \   000025   3F           ADDC    A,R7
   \   000026   F9           MOV     R1,A
   \   000027   E5..         MOV     A,?V0
   \   000029   6A           XRL     A,R2
   \   00002A   7003         JNZ     ??ZDSecMgrDeviceRemove_0
   \   00002C   E5..         MOV     A,?V1
   \   00002E   6B           XRL     A,R3
   \                     ??ZDSecMgrDeviceRemove_0:
   \   00002F   705D         JNZ     ??ZDSecMgrDeviceRemove_1
   1742            {
   1743              // this is the parent of the device
   1744              leaveReq.extAddr        = device->extAddr;
   \   000031   8882         MOV     DPL,R0
   \   000033   8983         MOV     DPH,R1
   \   000035   12....       LCALL   ??Subroutine75_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_102:
   \   000038   12....       LCALL   ?Subroutine26 & 0xFFFF
   1745              leaveReq.removeChildren = FALSE;
   \                     ??CrossCallReturnLabel_90:
   \   00003B   12....       LCALL   ?XSTACK_DISP0_8
   \   00003E   E4           CLR     A
   \   00003F   F0           MOVX    @DPTR,A
   1746              leaveReq.rejoin         = FALSE;
   \   000040   7403         MOV     A,#0x3
   \   000042   12....       LCALL   ?XSTACK_DISP0_8
   \   000045   E4           CLR     A
   \   000046   12....       LCALL   ?Subroutine56 & 0xFFFF
   1747          
   1748              // find child association
   1749              assoc = AssocGetWithExt( device->extAddr );
   \                     ??CrossCallReturnLabel_63:
   \   000049   12....       LCALL   ??Subroutine75_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_103:
   \   00004C   12....       LCALL   `??AssocGetWithExt::?relay`; Banked call to: AssocGetWithExt
   \   00004F   8A..         MOV     ?V0,R2
   \   000051   8B..         MOV     ?V1,R3
   \   000053   A8..         MOV     R0,?V0
   \   000055   A9..         MOV     R1,?V1
   1750          
   1751              if ( ( assoc != NULL                            ) &&
   1752                   ( assoc->nodeRelation >= CHILD_RFD         ) &&
   1753                   ( assoc->nodeRelation <= CHILD_FFD_RX_IDLE )    )
   \   000057   E8           MOV     A,R0
   \   000058   49           ORL     A,R1
   \   000059   604E         JZ      ??ZDSecMgrDeviceRemove_2
   \   00005B   8882         MOV     DPL,R0
   \   00005D   8983         MOV     DPH,R1
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   A3           INC     DPTR
   \   000062   A3           INC     DPTR
   \   000063   E0           MOVX    A,@DPTR
   \   000064   6043         JZ      ??ZDSecMgrDeviceRemove_2
   \   000066   C3           CLR     C
   \   000067   9405         SUBB    A,#0x5
   \   000069   503E         JNC     ??ZDSecMgrDeviceRemove_2
   1754              {
   1755                // check if associated device is authenticated
   1756                if ( assoc->devStatus & DEV_SEC_AUTH_STATUS )
   \   00006B   8882         MOV     DPL,R0
   \   00006D   8983         MOV     DPH,R1
   \   00006F   A3           INC     DPTR
   \   000070   A3           INC     DPTR
   \   000071   A3           INC     DPTR
   \   000072   A3           INC     DPTR
   \   000073   A3           INC     DPTR
   \   000074   E0           MOVX    A,@DPTR
   \   000075   A2E3         MOV     C,0xE0 /* A   */.3
   \   000077   7404         MOV     A,#0x4
   \   000079   5006         JNC     ??ZDSecMgrDeviceRemove_3
   1757                {
   1758                  leaveReq.silent = FALSE;
   \   00007B   12....       LCALL   ?XSTACK_DISP0_8
   \   00007E   E4           CLR     A
   \   00007F   8005         SJMP    ??ZDSecMgrDeviceRemove_4
   1759                }
   1760                else
   1761                {
   1762                  leaveReq.silent = TRUE;
   \                     ??ZDSecMgrDeviceRemove_3:
   \   000081   12....       LCALL   ?XSTACK_DISP0_8
   \   000084   7401         MOV     A,#0x1
   1763                }
   1764          
   1765                NLME_LeaveReq( &leaveReq );
   1766              }
   1767            }
   \                     ??ZDSecMgrDeviceRemove_4:
   \   000086   12....       LCALL   ??Subroutine80_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_156:
   \   000089   12....       LCALL   `??NLME_LeaveReq::?relay`; Banked call to: NLME_LeaveReq
   \   00008C   801B         SJMP    ??ZDSecMgrDeviceRemove_2
   1768            else
   1769            {
   1770              // this is not the parent of the device
   1771              remDevReq.parentAddr   = device->parentAddr;
   \                     ??ZDSecMgrDeviceRemove_1:
   \   00008E   7405         MOV     A,#0x5
   \   000090   12....       LCALL   ?XSTACK_DISP0_8
   \   000093   EA           MOV     A,R2
   \   000094   F0           MOVX    @DPTR,A
   \   000095   A3           INC     DPTR
   \   000096   EB           MOV     A,R3
   \   000097   12....       LCALL   ?Subroutine32 & 0xFFFF
   1772              remDevReq.childExtAddr = device->extAddr;
   1773          
   1774              APSME_RemoveDeviceReq( &remDevReq );
   1775            }
   \                     ??CrossCallReturnLabel_20:
   \   00009A   F9           MOV     R1,A
   \   00009B   7407         MOV     A,#0x7
   \   00009D   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A0   12....       LCALL   ??Subroutine67_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_82:
   \   0000A3   12....       LCALL   ?XSTACK_DISP101_8
   \   0000A6   12....       LCALL   `??APSME_RemoveDeviceReq::?relay`; Banked call to: APSME_RemoveDeviceReq
   1776          }
   \                     ??ZDSecMgrDeviceRemove_2:
   \   0000A9   7409         MOV     A,#0x9
   \   0000AB   02....       LJMP    ??Subroutine85_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine73_0
   \   000006                ; // Fall through to label ??Subroutine73_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine73_0:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004   F0           MOVX    @DPTR,A
   \   000005   7402         MOV     A,#0x2
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   12....       LCALL   ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   000003   12....       LCALL   ??Subroutine93_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_218:
   \   000006   22           RET
   1777          
   1778          /******************************************************************************
   1779           * @fn          ZDSecMgrDeviceValidateSKKE
   1780           *
   1781           * @brief       Decide whether device is allowed for SKKE.
   1782           *
   1783           * @param       device - [in] ZDSecMgrDevice_t, device info
   1784           *
   1785           * @return      ZStatus_t
   1786           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1787          ZStatus_t ZDSecMgrDeviceValidateSKKE( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateSKKE:
   1788          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1789            ZStatus_t status;
   1790            uint16    ami;
   1791            uint8*    key;
   1792          
   1793          
   1794            // get EXT address
   1795            status = ZDSecMgrExtAddrLookup( device->extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   AC..         MOV     R4,?XSP + 0
   \   000010   AD..         MOV     R5,?XSP + 1
   \   000012   8E82         MOV     DPL,R6
   \   000014   8F83         MOV     DPH,R7
   \   000016   A3           INC     DPTR
   \   000017   A3           INC     DPTR
   \   000018   12....       LCALL   ??Subroutine75_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_104:
   \   00001B   12....       LCALL   `??ZDSecMgrExtAddrLookup::?relay`; Banked call to: ZDSecMgrExtAddrLookup
   \   00001E   E9           MOV     A,R1
   \   00001F   F9           MOV     R1,A
   1796          
   1797            if ( status == ZSuccess )
   \   000020   701D         JNZ     ??ZDSecMgrDeviceValidateSKKE_0
   1798            {
   1799              // get MASTER key
   1800              status = ZDSecMgrMasterKeyLookup( ami, &key );
   \   000022                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000022   7402         MOV     A,#0x2
   \   000024   12....       LCALL   ?XSTACK_DISP102_8
   \   000027   12....       LCALL   ??Subroutine74_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_115:
   \   00002A   12....       LCALL   `??ZDSecMgrMasterKeyLookup::?relay`; Banked call to: ZDSecMgrMasterKeyLookup
   \   00002D   E9           MOV     A,R1
   \   00002E   F9           MOV     R1,A
   1801          
   1802              if ( status == ZSuccess )
   \   00002F   700E         JNZ     ??ZDSecMgrDeviceValidateSKKE_0
   1803              {
   1804              //  // check if initiator is Trust Center
   1805              //  if ( device->nwkAddr == APSME_TRUSTCENTER_NWKADDR )
   1806              //  {
   1807              //    // verify NWK key not sent
   1808              //    // devtag.todo
   1809              //    // temporary - add device to internal data
   1810              //    status = ZDSecMgrDeviceEntryAdd( device, ami );
   1811              //  }
   1812              //  else
   1813              //  {
   1814              //    // initiator not Trust Center - End to End SKKE - set policy
   1815              //    // for accepting an SKKE initiation
   1816              //    // temporary - add device to internal data
   1817              //    status = ZDSecMgrDeviceEntryAdd( device, ami );
   1818              //  }
   1819                  status = ZDSecMgrDeviceEntryAdd( device, ami );
   \   000031                ; Setup parameters for call to function ZDSecMgrDeviceEntryAdd
   \   000031   85..82       MOV     DPL,?XSP + 0
   \   000034   85..83       MOV     DPH,?XSP + 1
   \   000037   12....       LCALL   ??Subroutine94_0 & 0xFFFF
   1820              }
   1821            }
   \                     ??CrossCallReturnLabel_224:
   \   00003A   12....       LCALL   `??ZDSecMgrDeviceEntryAdd::?relay`; Banked call to: ZDSecMgrDeviceEntryAdd
   \   00003D   E9           MOV     A,R1
   \   00003E   F9           MOV     R1,A
   1822          
   1823            return status;
   \                     ??ZDSecMgrDeviceValidateSKKE_0:
   \   00003F   02....       LJMP    ?Subroutine10 & 0xFFFF
   1824          }
   1825          
   1826          /******************************************************************************
   1827           * @fn          ZDSecMgrDeviceValidateRM (RESIDENTIAL MODE)
   1828           *
   1829           * @brief       Decide whether device is allowed.
   1830           *
   1831           * @param       device - [in] ZDSecMgrDevice_t, device info
   1832           *
   1833           * @return      ZStatus_t
   1834           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1835          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateRM:
   1836          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1837          
   1838            ZStatus_t status;
   1839            status = ZSuccess;
   \   000004   7900         MOV     R1,#0x0
   1840          
   1841            (void)device;  // Intentionally unreferenced parameter
   1842            
   1843            // For test purpose, turning off the zgSecurePermitJoin flag will force
   1844            // the trust center to reject any newly joining devices by sending
   1845            // Remove-device to the parents.
   1846            if ( zgSecurePermitJoin == false )
   \   000006   90....       MOV     DPTR,#zgSecurePermitJoin
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   7002         JNZ     ??ZDSecMgrDeviceValidateRM_0
   1847            {
   1848              status = ZNwkUnknownDevice;
   \   00000C   79C8         MOV     R1,#-0x38
   1849            }
   1850          
   1851          
   1852          
   1853          #if 0  // Taken out because the following functionality is only used for test
   1854                 // purpose. A more efficient (above) way is used. It can be put
   1855                 // back in if customers request for a white/black list feature.
   1856                 // ZDSecMgrStoredDeviceList[] is defined in ZDSecMgr.c
   1857          
   1858            // The following code processes the device black list (stored device list)
   1859            // If the joining device is not part of the forbidden device list
   1860            // Return ZSuccess. Otherwise, return ZNwkUnknownDevice. The trust center
   1861            // will send Remove-device and ban the device from joining.
   1862          
   1863            uint8     index;
   1864            uint8*    restricted;
   1865          
   1866            // Look through the stored device list - used for restricted devices
   1867            for ( index = 0; index < ZDSECMGR_STORED_DEVICES; index++ )
   1868            {
   1869              restricted = ZDSecMgrStoredDeviceList[index];
   1870          
   1871              if ( AddrMgrExtAddrEqual( restricted, device->extAddr )  == TRUE )
   1872              {
   1873                // return as unknown device in regards to validation
   1874                status = ZNwkUnknownDevice;
   1875          
   1876                // break from loop
   1877                index = ZDSECMGR_STORED_DEVICES;
   1878              }
   1879            }
   1880          
   1881          #endif
   1882          
   1883            return status;
   \                     ??ZDSecMgrDeviceValidateRM_0:
   \   00000E   02....       LJMP    ??Subroutine77_0 & 0xFFFF
   1884          }
   1885          
   1886          /******************************************************************************
   1887           * @fn          ZDSecMgrDeviceValidateCM (COMMERCIAL MODE)
   1888           *
   1889           * @brief       Decide whether device is allowed.
   1890           *
   1891           * @param       device - [in] ZDSecMgrDevice_t, device info
   1892           *
   1893           * @return      ZStatus_t
   1894           */
   1895          //devtag.pro.security

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1896          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateCM:
   1897          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1898            ZStatus_t status;
   1899            uint16    ami;
   1900            uint8*    key;
   1901          
   1902          
   1903          //  // check for pre configured setting
   1904          //  if ( device->secure == TRUE )
   1905          //  {
   1906          //    // get EXT address and MASTER key
   1907          //    status = ZDSecMgrExtAddrLookup( device->extAddr, &ami );
   1908          //
   1909          //    if ( status == ZSuccess )
   1910          //    {
   1911          //      status = ZDSecMgrMasterKeyLookup( ami, &key );
   1912          //    }
   1913          //  }
   1914          //  else
   1915          //  {
   1916              // implement EXT address and MASTER key policy here -- the total number of
   1917              // Security Manager entries should never exceed the number of EXT addresses
   1918              // and MASTER keys available
   1919          
   1920              // set status based on policy
   1921              //status = ZNwkUnknownDevice;
   1922          
   1923              // set status based on policy
   1924              status = ZSuccess; // ZNwkUnknownDevice;
   1925          
   1926              // get key based on policy
   1927              key = ZDSecMgrTCMasterKey;
   1928          
   1929              // if policy, store new EXT address
   1930              status = ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   \   00000E   EE           MOV     A,R6
   \   00000F   2402         ADD     A,#0x2
   \   000011   F5..         MOV     ?V0,A
   \   000013   E4           CLR     A
   \   000014   3F           ADDC    A,R7
   \   000015   F5..         MOV     ?V1,A
   \   000017                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000017   A8..         MOV     R0,?XSP + 0
   \   000019   A9..         MOV     R1,?XSP + 1
   \   00001B   88..         MOV     ?V2,R0
   \   00001D   89..         MOV     ?V3,R1
   \   00001F   78..         MOV     R0,#?V2
   \   000021   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000024   85..82       MOV     DPL,?V0
   \   000027   85..83       MOV     DPH,?V1
   \   00002A   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   00002D   12....       LCALL   ??Subroutine75_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_105:
   \   000030   12....       LCALL   `??ZDSecMgrAddrStore::?relay`; Banked call to: ZDSecMgrAddrStore
   \   000033   7402         MOV     A,#0x2
   \   000035   12....       LCALL   ?DEALLOC_XSTACK8
   \   000038   E9           MOV     A,R1
   \   000039   F5..         MOV     ?V2,A
   1931          
   1932              // set the key
   1933              ZDSecMgrMasterKeyLoad( device->extAddr, key );
   \   00003B                ; Setup parameters for call to function ZDSecMgrMasterKeyLoad
   \   00003B   7C..         MOV     R4,#ZDSecMgrTCMasterKey & 0xff
   \   00003D   7D..         MOV     R5,#(ZDSecMgrTCMasterKey >> 8) & 0xff
   \   00003F   85..82       MOV     DPL,?V0
   \   000042   85..83       MOV     DPH,?V1
   \   000045   12....       LCALL   ??Subroutine75_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_106:
   \   000048   12....       LCALL   `??ZDSecMgrMasterKeyLoad::?relay`; Banked call to: ZDSecMgrMasterKeyLoad
   1934          //  }
   1935          
   1936            // if EXT address and MASTER key available -- add device
   1937            if ( status == ZSuccess )
   \   00004B   E5..         MOV     A,?V2
   \   00004D   700F         JNZ     ??ZDSecMgrDeviceValidateCM_0
   1938            {
   1939              // add device to internal data - with control
   1940              status = ZDSecMgrDeviceEntryAdd( device, ami );
   \   00004F                ; Setup parameters for call to function ZDSecMgrDeviceEntryAdd
   \   00004F   85..82       MOV     DPL,?XSP + 0
   \   000052   85..83       MOV     DPH,?XSP + 1
   \   000055   12....       LCALL   ??Subroutine94_0 & 0xFFFF
   1941            }
   \                     ??CrossCallReturnLabel_225:
   \   000058   12....       LCALL   `??ZDSecMgrDeviceEntryAdd::?relay`; Banked call to: ZDSecMgrDeviceEntryAdd
   \   00005B   E9           MOV     A,R1
   \   00005C   F5..         MOV     ?V2,A
   1942          
   1943            return status;
   \                     ??ZDSecMgrDeviceValidateCM_0:
   \   00005E   A9..         MOV     R1,?V2
   \   000060   02....       LJMP    ?Subroutine4 & 0xFFFF
   1944          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine48:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FD           MOV     R5,A
   \   000005   8E82         MOV     DPL,R6
   \   000007   8F83         MOV     DPH,R7
   \   000009   22           RET
   1945          //devtag.pro.security
   1946          #if 0
   1947          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device )
   1948          {
   1949            ZStatus_t status;
   1950            uint16    ami;
   1951            uint8*    key;
   1952          
   1953          
   1954            // check for pre configured setting
   1955            if ( device->secure == TRUE )
   1956            {
   1957              // get EXT address and MASTER key
   1958              status = ZDSecMgrExtAddrLookup( device->extAddr, &ami );
   1959          
   1960              if ( status == ZSuccess )
   1961              {
   1962                status = ZDSecMgrMasterKeyLookup( ami, &key );
   1963              }
   1964            }
   1965            else
   1966            {
   1967              // implement EXT address and MASTER key policy here -- the total number of
   1968              // Security Manager entries should never exceed the number of EXT addresses
   1969              // and MASTER keys available
   1970          
   1971              // set status based on policy
   1972              status = ZSuccess; // ZNwkUnknownDevice;
   1973          
   1974              // get the address index
   1975              if ( ZDSecMgrExtAddrLookup( device->extAddr, &ami ) != ZSuccess )
   1976              {
   1977                // if policy, store new EXT address
   1978                status = ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   1979              }
   1980          
   1981              // get the address index
   1982              if ( ZDSecMgrMasterKeyLookup( ami, &key ) != ZSuccess )
   1983              {
   1984                // if policy, store new key -- NULL will zero key
   1985                status = ZDSecMgrMasterKeyStore( ami, NULL );
   1986              }
   1987            }
   1988          
   1989            // if EXT address and MASTER key available -- add device
   1990            if ( status == ZSuccess )
   1991            {
   1992              // add device to internal data - with control
   1993              status = ZDSecMgrDeviceEntryAdd( device, ami );
   1994            }
   1995          
   1996            return status;
   1997          }
   1998          #endif
   1999          
   2000          /******************************************************************************
   2001           * @fn          ZDSecMgrDeviceValidate
   2002           *
   2003           * @brief       Decide whether device is allowed.
   2004           *
   2005           * @param       device - [in] ZDSecMgrDevice_t, device info
   2006           *
   2007           * @return      ZStatus_t
   2008           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2009          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidate:
   2010          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2011            ZStatus_t status;
   2012          
   2013          
   2014            if ( ZDSecMgrPermitJoiningEnabled == TRUE )
   \   000004   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6401         XRL     A,#0x1
   \   00000A   7020         JNZ     ??ZDSecMgrDeviceValidate_0
   2015            {
   2016              // device may be joining with a secure flag but it is ultimately the Trust
   2017              // Center that decides -- check if expected pre configured device --
   2018              // override settings
   2019              if ( zgPreConfigKeys == TRUE )
   \   00000C   EA           MOV     A,R2
   \   00000D   2406         ADD     A,#0x6
   \   00000F   F8           MOV     R0,A
   \   000010   E4           CLR     A
   \   000011   3B           ADDC    A,R3
   \   000012   F9           MOV     R1,A
   \   000013   90....       MOV     DPTR,#zgPreConfigKeys
   \   000016   E0           MOVX    A,@DPTR
   \   000017   6401         XRL     A,#0x1
   \   000019   8882         MOV     DPL,R0
   \   00001B   8983         MOV     DPH,R1
   \   00001D   7004         JNZ     ??ZDSecMgrDeviceValidate_1
   2020              {
   2021                device->secure = TRUE;
   \   00001F   7401         MOV     A,#0x1
   \   000021   8001         SJMP    ??ZDSecMgrDeviceValidate_2
   2022              }
   2023              else
   2024              {
   2025                device->secure = FALSE;
   \                     ??ZDSecMgrDeviceValidate_1:
   \   000023   E4           CLR     A
   \                     ??ZDSecMgrDeviceValidate_2:
   \   000024   F0           MOVX    @DPTR,A
   2026              }
   2027          
   2028              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2029              {
   2030                status = ZDSecMgrDeviceValidateCM( device );
   2031              }
   2032              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2033              {
   2034                status = ZDSecMgrDeviceValidateRM( device );
   \   000025                ; Setup parameters for call to function ZDSecMgrDeviceValidateRM
   \   000025   12....       LCALL   `??ZDSecMgrDeviceValidateRM::?relay`; Banked call to: ZDSecMgrDeviceValidateRM
   \   000028   E9           MOV     A,R1
   \   000029   F9           MOV     R1,A
   \   00002A   8002         SJMP    ??ZDSecMgrDeviceValidate_3
   2035              }
   2036            }
   2037            else
   2038            {
   2039              status = ZNwkUnknownDevice;
   \                     ??ZDSecMgrDeviceValidate_0:
   \   00002C   79C8         MOV     R1,#-0x38
   2040            }
   2041          
   2042            return status;
   \                     ??ZDSecMgrDeviceValidate_3:
   \   00002E   02....       LJMP    ??Subroutine77_0 & 0xFFFF
   2043          }
   2044          
   2045          /******************************************************************************
   2046           * @fn          ZDSecMgrDeviceJoin
   2047           *
   2048           * @brief       Try to join this device.
   2049           *
   2050           * @param       device - [in] ZDSecMgrDevice_t, device info
   2051           *
   2052           * @return      ZStatus_t
   2053           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2054          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoin:
   2055          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2056            ZStatus_t status;
   2057            uint16    ami;
   2058          
   2059            // attempt to validate device
   2060            status = ZDSecMgrDeviceValidate( device );
   \   00000E                ; Setup parameters for call to function ZDSecMgrDeviceValidate
   \   00000E   12....       LCALL   `??ZDSecMgrDeviceValidate::?relay`; Banked call to: ZDSecMgrDeviceValidate
   \   000011   E9           MOV     A,R1
   \   000012   F5..         MOV     ?V0,A
   2061          
   2062            if ( status == ZSuccess )
   \   000014   702D         JNZ     ??ZDSecMgrDeviceJoin_0
   2063            {
   2064              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2065              {
   2066                ZDSecMgrDeviceCtrlSetup( device );
   2067              }
   2068              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2069              {
   2070                // Add the device to the address manager
   2071                ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   \   000016                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000016   A8..         MOV     R0,?XSP + 0
   \   000018   A9..         MOV     R1,?XSP + 1
   \   00001A   88..         MOV     ?V0,R0
   \   00001C   89..         MOV     ?V1,R1
   \   00001E   78..         MOV     R0,#?V0
   \   000020   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000023   8E82         MOV     DPL,R6
   \   000025   8F83         MOV     DPH,R7
   \   000027   A3           INC     DPTR
   \   000028   A3           INC     DPTR
   \   000029   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   00002C   12....       LCALL   ??Subroutine75_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_107:
   \   00002F   12....       LCALL   `??ZDSecMgrAddrStore::?relay`; Banked call to: ZDSecMgrAddrStore
   \   000032   7402         MOV     A,#0x2
   \   000034   12....       LCALL   ?DEALLOC_XSTACK8
   2072                //send the nwk key data to the joining device
   2073                status = ZDSecMgrSendNwkKey( device );
   \   000037                ; Setup parameters for call to function ZDSecMgrSendNwkKey
   \   000037   EE           MOV     A,R6
   \   000038   FA           MOV     R2,A
   \   000039   EF           MOV     A,R7
   \   00003A   FB           MOV     R3,A
   \   00003B   12....       LCALL   `??ZDSecMgrSendNwkKey::?relay`; Banked call to: ZDSecMgrSendNwkKey
   \   00003E   E9           MOV     A,R1
   \   00003F   F5..         MOV     ?V0,A
   \   000041   8007         SJMP    ??ZDSecMgrDeviceJoin_1
   2074              }
   2075            }
   2076            else
   2077            {
   2078              // not allowed, remove the device
   2079              ZDSecMgrDeviceRemove( device );
   \                     ??ZDSecMgrDeviceJoin_0:
   \   000043                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000043   EE           MOV     A,R6
   \   000044   FA           MOV     R2,A
   \   000045   EF           MOV     A,R7
   \   000046   FB           MOV     R3,A
   \   000047   12....       LCALL   `??ZDSecMgrDeviceRemove::?relay`; Banked call to: ZDSecMgrDeviceRemove
   2080            }
   2081          
   2082            return status;
   \                     ??ZDSecMgrDeviceJoin_1:
   \   00004A   A9..         MOV     R1,?V0
   \   00004C   02....       LJMP    ?Subroutine12 & 0xFFFF
   2083          }
   2084          
   2085          /******************************************************************************
   2086           * @fn          ZDSecMgrDeviceJoinDirect
   2087           *
   2088           * @brief       Try to join this device as a direct child.
   2089           *
   2090           * @param       device - [in] ZDSecMgrDevice_t, device info
   2091           *
   2092           * @return      ZStatus_t
   2093           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2094          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinDirect:
   2095          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2096            ZStatus_t status;
   2097          
   2098            status = ZDSecMgrDeviceJoin( device );
   \   000009                ; Setup parameters for call to function ZDSecMgrDeviceJoin
   \   000009   12....       LCALL   `??ZDSecMgrDeviceJoin::?relay`; Banked call to: ZDSecMgrDeviceJoin
   \   00000C   E9           MOV     A,R1
   \   00000D   F5..         MOV     ?V0,A
   2099          
   2100            if ( status == ZSuccess )
   \   00000F   700D         JNZ     ??ZDSecMgrDeviceJoinDirect_0
   2101            {
   2102              // set association status to authenticated
   2103              ZDSecMgrAssocDeviceAuth( AssocGetWithShort( device->nwkAddr ) );
   \   000011                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   000011                ; Setup parameters for call to function AssocGetWithShort
   \   000011   8E82         MOV     DPL,R6
   \   000013   8F83         MOV     DPH,R7
   \   000015   12....       LCALL   ??Subroutine75_0 & 0xFFFF
   2104            }
   \                     ??CrossCallReturnLabel_108:
   \   000018   12....       LCALL   `??AssocGetWithShort::?relay`; Banked call to: AssocGetWithShort
   \   00001B   12....       LCALL   `??ZDSecMgrAssocDeviceAuth::?relay`; Banked call to: ZDSecMgrAssocDeviceAuth
   2105          
   2106            return status;
   \                     ??ZDSecMgrDeviceJoinDirect_0:
   \   00001E   A9..         MOV     R1,?V0
   \   000020   02....       LJMP    ??Subroutine72_0 & 0xFFFF
   2107          }
   2108          
   2109          /******************************************************************************
   2110           * @fn          ZDSecMgrDeviceJoinFwd
   2111           *
   2112           * @brief       Forward join to Trust Center.
   2113           *
   2114           * @param       device - [in] ZDSecMgrDevice_t, device info
   2115           *
   2116           * @return      ZStatus_t
   2117           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2118          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinFwd:
   2119          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 8
   \   000004   74F8         MOV     A,#-0x8
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   2120            ZStatus_t               status;
   2121            APSME_UpdateDeviceReq_t req;
   2122          
   2123          
   2124            // forward any joining device to the Trust Center -- the Trust Center will
   2125            // decide if the device is allowed to join
   2126            status = ZSuccess;
   2127          
   2128            // forward authorization to the Trust Center
   2129            req.dstAddr    = APSME_TRUSTCENTER_NWKADDR;
   \   000009   85..82       MOV     DPL,?XSP + 0
   \   00000C   85..83       MOV     DPH,?XSP + 1
   \   00000F   E4           CLR     A
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   F0           MOVX    @DPTR,A
   2130            req.devAddr    = device->nwkAddr;
   \   000013   8A82         MOV     DPL,R2
   \   000015   8B83         MOV     DPH,R3
   \   000017   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   00001A   12....       LCALL   ?XSTACK_DISP0_8
   \   00001D   12....       LCALL   ?Subroutine19 & 0xFFFF
   2131            req.devExtAddr = device->extAddr;
   \                     ??CrossCallReturnLabel_0:
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   12....       LCALL   ??Subroutine79_0 & 0xFFFF
   2132          
   2133            // set security status, option for router to reject if policy set
   2134            if ( (device->devStatus & DEV_HIGH_SEC_STATUS) )
   \                     ??CrossCallReturnLabel_138:
   \   000026   EA           MOV     A,R2
   \   000027   2407         ADD     A,#0x7
   \   000029   F582         MOV     DPL,A
   \   00002B   E4           CLR     A
   \   00002C   3B           ADDC    A,R3
   \   00002D   F583         MOV     DPH,A
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   A2E7         MOV     C,0xE0 /* A   */.7
   \   000032   502E         JNC     ??ZDSecMgrDeviceJoinFwd_0
   2135            {
   2136              if ( device->devStatus & DEV_REJOIN_STATUS )
   \   000034   A2E6         MOV     C,0xE0 /* A   */.6
   \   000036   5021         JNC     ??ZDSecMgrDeviceJoinFwd_1
   2137              {
   2138                if ( device->secure == TRUE )
   \   000038   8A82         MOV     DPL,R2
   \   00003A   8B83         MOV     DPH,R3
   \   00003C   A3           INC     DPTR
   \   00003D   A3           INC     DPTR
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   E0           MOVX    A,@DPTR
   \   000043   6401         XRL     A,#0x1
   \   000045   7009         JNZ     ??ZDSecMgrDeviceJoinFwd_2
   2139                  req.status = APSME_UD_HIGH_SECURED_REJOIN;
   \   000047   7406         MOV     A,#0x6
   \   000049   12....       LCALL   ?XSTACK_DISP0_8
   \   00004C   7404         MOV     A,#0x4
   \   00004E   803D         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2140                else
   2141                  req.status = APSME_UD_HIGH_UNSECURED_REJOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_2:
   \   000050   7406         MOV     A,#0x6
   \   000052   12....       LCALL   ?XSTACK_DISP0_8
   \   000055   7407         MOV     A,#0x7
   \   000057   8034         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2142              }
   2143              else
   2144                req.status = APSME_UD_HIGH_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_1:
   \   000059   7406         MOV     A,#0x6
   \   00005B   12....       LCALL   ?XSTACK_DISP0_8
   \   00005E   7405         MOV     A,#0x5
   \   000060   802B         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2145            }
   2146            else
   2147            {
   2148              if ( device->devStatus & DEV_REJOIN_STATUS )
   \                     ??ZDSecMgrDeviceJoinFwd_0:
   \   000062   A2E6         MOV     C,0xE0 /* A   */.6
   \   000064   5020         JNC     ??ZDSecMgrDeviceJoinFwd_4
   2149              {
   2150                if ( device->secure == TRUE )
   \   000066   8A82         MOV     DPL,R2
   \   000068   8B83         MOV     DPH,R3
   \   00006A   A3           INC     DPTR
   \   00006B   A3           INC     DPTR
   \   00006C   A3           INC     DPTR
   \   00006D   A3           INC     DPTR
   \   00006E   A3           INC     DPTR
   \   00006F   A3           INC     DPTR
   \   000070   E0           MOVX    A,@DPTR
   \   000071   6401         XRL     A,#0x1
   \   000073   7008         JNZ     ??ZDSecMgrDeviceJoinFwd_5
   2151                  req.status = APSME_UD_STANDARD_SECURED_REJOIN;
   \   000075   7406         MOV     A,#0x6
   \   000077   12....       LCALL   ?XSTACK_DISP0_8
   \   00007A   E4           CLR     A
   \   00007B   8010         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2152                else
   2153                  req.status = APSME_UD_STANDARD_UNSECURED_REJOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_5:
   \   00007D   7406         MOV     A,#0x6
   \   00007F   12....       LCALL   ?XSTACK_DISP0_8
   \   000082   7403         MOV     A,#0x3
   \   000084   8007         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2154              }
   2155              else
   2156                req.status = APSME_UD_STANDARD_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_4:
   \   000086   7406         MOV     A,#0x6
   \   000088   12....       LCALL   ?XSTACK_DISP0_8
   \   00008B   7401         MOV     A,#0x1
   \                     ??ZDSecMgrDeviceJoinFwd_3:
   \   00008D   F0           MOVX    @DPTR,A
   2157            }
   2158          
   2159            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2160              req.apsSecure = TRUE;
   2161            else
   2162              req.apsSecure = FALSE;
   \   00008E   7407         MOV     A,#0x7
   \   000090   12....       LCALL   ?XSTACK_DISP0_8
   \   000093   E4           CLR     A
   \   000094   12....       LCALL   ??Subroutine80_0 & 0xFFFF
   2163          
   2164            // send and APSME_UPDATE_DEVICE request to the trust center
   2165            status = APSME_UpdateDeviceReq( &req );
   2166          
   2167            return status;
   \                     ??CrossCallReturnLabel_157:
   \   000097   12....       LCALL   `??APSME_UpdateDeviceReq::?relay`; Banked call to: APSME_UpdateDeviceReq
   \   00009A   7408         MOV     A,#0x8
   \   00009C   02....       LJMP    ??Subroutine92_0 & 0xFFFF
   2168          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   12....       LCALL   ??Subroutine90_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_201:
   \   000003   8A82         MOV     DPL,R2
   \   000005   8B83         MOV     DPH,R3
   \   000007   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_211:
   \   00000A   7404         MOV     A,#0x4
   \   00000C   22           RET
   2169          
   2170          /******************************************************************************
   2171           * @fn          ZDSecMgrDeviceNew
   2172           *
   2173           * @brief       Process a new device.
   2174           *
   2175           * @param       device - [in] ZDSecMgrDevice_t, device info
   2176           *
   2177           * @return      ZStatus_t
   2178           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2179          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* joiner )
   \                     ZDSecMgrDeviceNew:
   2180          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2181            ZStatus_t status;
   2182          
   2183            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2184            {
   2185              // try to join this device
   2186              status = ZDSecMgrDeviceJoinDirect( joiner );
   2187            }
   2188            else
   2189            {
   2190              status = ZDSecMgrDeviceJoinFwd( joiner );
   2191            }
   2192          
   2193            return status;
   \   000004                ; Setup parameters for call to function ZDSecMgrDeviceJoinFwd
   \   000004   12....       LCALL   `??ZDSecMgrDeviceJoinFwd::?relay`; Banked call to: ZDSecMgrDeviceJoinFwd
   \   000007   80..         SJMP    ??Subroutine77_0
   2194          }
   2195          
   2196          /******************************************************************************
   2197           * @fn          ZDSecMgrAssocDeviceAuth
   2198           *
   2199           * @brief       Set associated device status to authenticated
   2200           *
   2201           * @param       assoc - [in, out] associated_devices_t
   2202           *
   2203           * @return      none
   2204           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2205          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc )
   \                     ZDSecMgrAssocDeviceAuth:
   2206          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2207            if ( assoc != NULL )
   \   000004   EA           MOV     A,R2
   \   000005   4B           ORL     A,R3
   \   000006   600D         JZ      ??ZDSecMgrAssocDeviceAuth_0
   2208            {
   2209              assoc->devStatus |= DEV_SEC_AUTH_STATUS;
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   D2E3         SETB    0xE0 /* A   */.3
   \   000014   F0           MOVX    @DPTR,A
   2210            }
   2211          }
   \                     ??ZDSecMgrAssocDeviceAuth_0:
   \   000015   80..         SJMP    ??Subroutine77_0
   2212          
   2213          /******************************************************************************
   2214           * @fn          ZDSecMgrAuthInitiate
   2215           *
   2216           * @brief       Initiate entity authentication
   2217           *
   2218           * @param       responder - [in] responder EXT address
   2219           *
   2220           * @return      none
   2221           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2222          void ZDSecMgrAuthInitiate( uint8* responder )
   \                     ZDSecMgrAuthInitiate:
   2223          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV     A,#-0x7
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2224            APSME_AuthenticateReq_t req;
   2225          
   2226          
   2227            // make sure NWK address is available
   2228            if ( APSME_LookupNwkAddr( responder, &req.nwkAddr ) )
   \   00000E                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   00000E   AC..         MOV     R4,?XSP + 0
   \   000010   AD..         MOV     R5,?XSP + 1
   \   000012   12....       LCALL   `??APSME_LookupNwkAddr::?relay`; Banked call to: APSME_LookupNwkAddr
   \   000015   E9           MOV     A,R1
   \   000016   601F         JZ      ??ZDSecMgrAuthInitiate_0
   2229            {
   2230              // set request fields
   2231              req.extAddr   = responder;
   \   000018   7402         MOV     A,#0x2
   \   00001A   12....       LCALL   ?XSTACK_DISP0_8
   \   00001D   EE           MOV     A,R6
   \   00001E   F0           MOVX    @DPTR,A
   \   00001F   A3           INC     DPTR
   \   000020   EF           MOV     A,R7
   \   000021   F0           MOVX    @DPTR,A
   2232              req.action    = APSME_EA_INITIATE;
   \   000022   7406         MOV     A,#0x6
   \   000024   12....       LCALL   ?XSTACK_DISP0_8
   \   000027   E4           CLR     A
   \   000028   F0           MOVX    @DPTR,A
   2233              req.challenge = NULL;
   \   000029   7404         MOV     A,#0x4
   \   00002B   12....       LCALL   ?XSTACK_DISP0_8
   \   00002E   E4           CLR     A
   \   00002F   F0           MOVX    @DPTR,A
   \   000030   A3           INC     DPTR
   \   000031   12....       LCALL   ??Subroutine80_0 & 0xFFFF
   2234          
   2235              // start EA processing
   2236              APSME_AuthenticateReq( &req );
   2237            }
   \                     ??CrossCallReturnLabel_158:
   \   000034   12....       LCALL   `??APSME_AuthenticateReq::?relay`; Banked call to: APSME_AuthenticateReq
   2238          }
   \                     ??ZDSecMgrAuthInitiate_0:
   \   000037   7407         MOV     A,#0x7
   \   000039   02....       LJMP    ??Subroutine71_0 & 0xFFFF
   2239          
   2240          /******************************************************************************
   2241           * @fn          ZDSecMgrAuthNwkKey
   2242           *
   2243           * @brief       Handle next step in authentication process
   2244           *
   2245           * @param       none
   2246           *
   2247           * @return      none
   2248           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2249          void ZDSecMgrAuthNwkKey()
   \                     ZDSecMgrAuthNwkKey:
   2250          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2251            if ( devState == DEV_END_DEVICE_UNAUTH )
   \   000004   90....       MOV     DPTR,#devState
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6405         XRL     A,#0x5
   \   00000A   700C         JNZ     ??ZDSecMgrAuthNwkKey_0
   2252            {
   2253              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2254              {
   2255                uint8 parent[Z_EXTADDR_LEN];
   2256          
   2257                // get parent's EXT address
   2258                NLME_GetCoordExtAddr( parent );
   2259          
   2260                // begin entity authentication with parent
   2261                ZDSecMgrAuthInitiate( parent );
   2262              }
   2263              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2264              {
   2265                // inform ZDO that device has been authenticated
   2266                osal_set_event ( ZDAppTaskID, ZDO_DEVICE_AUTH );
   \   00000C                ; Setup parameters for call to function osal_set_event
   \   00000C   7A80         MOV     R2,#-0x80
   \   00000E   7B00         MOV     R3,#0x0
   \   000010   90....       MOV     DPTR,#ZDAppTaskID
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F9           MOV     R1,A
   \   000015   12....       LCALL   `??osal_set_event::?relay`; Banked call to: osal_set_event
   2267              }
   2268            }
   2269          }
   \                     ??ZDSecMgrAuthNwkKey_0:
   \   000018   80..         SJMP    ??Subroutine77_0
   2270          
   2271          /******************************************************************************
   2272           * PUBLIC FUNCTIONS
   2273           */
   2274          /******************************************************************************
   2275           * @fn          ZDSecMgrInit
   2276           *
   2277           * @brief       Initialize ZigBee Device Security Manager.
   2278           *
   2279           * @param       state - device initialization state
   2280           *
   2281           * @return      none
   2282           */
   2283          #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2284          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
   2285          void ZDSecMgrAddrMgrCB( uint8           update,
   2286                                  AddrMgrEntry_t* newEntry,
   2287                                  AddrMgrEntry_t* oldEntry )
   2288          {
   2289            (void)update;
   2290            (void)newEntry;
   2291            (void)oldEntry;
   2292          }
   2293          #endif // ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2294          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2295          void ZDSecMgrInit(uint8 state)
   \                     ZDSecMgrInit:
   \   000000                REQUIRE ?Subroutine7
   \   000000                ; // Fall through to label ?Subroutine7

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   2296          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2297            if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   2298                || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   2299            {
   2300              // initialize sub modules
   2301              ZDSecMgrMasterKeyInit();
   2302              ZDSecMgrEntryInit(state);
   2303          
   2304              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2305              {
   2306                ZDSecMgrCtrlInit();
   2307              }
   2308          
   2309              // register with Address Manager
   2310              #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2311              AddrMgrRegister( ADDRMGR_REG_SECURITY, ZDSecMgrAddrMgrCB );
   2312              #endif
   2313            }
   2314          
   2315            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2316            {
   2317              // configure SKA slot data
   2318              APSME_SKA_SlotInit( ZDSECMGR_SKA_SLOT_MAX );
   2319            }
   2320            else if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   2321            {
   2322              APSME_TCLinkKeyInit();  
   2323              APSME_TCAddrSetup( zgTrustCenterAddr );    
   2324            
   2325            }
   2326          
   2327            if ( ZG_SECURE_ENABLED )
   2328            {
   2329              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2330              {
   2331                // setup joining permissions
   2332                ZDSecMgrPermitJoiningEnabled = TRUE;
   2333                ZDSecMgrPermitJoiningTimed   = FALSE;
   2334              }
   2335            }
   2336          
   2337            // configure security based on security mode and type of device
   2338            ZDSecMgrConfig();
   \   000004                ; Setup parameters for call to function APSME_SecurityNM
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004                ; Setup parameters for call to function APSME_SecurityNM
   \   000004   12....       LCALL   `??APSME_SecurityNM::?relay`; Banked call to: APSME_SecurityNM
   2339          }
   \   000007   80..         SJMP    ??Subroutine77_0
   2340          
   2341          /******************************************************************************
   2342           * @fn          ZDSecMgrConfig
   2343           *
   2344           * @brief       Configure ZigBee Device Security Manager.
   2345           *
   2346           * @param       none
   2347           *
   2348           * @return      none
   2349           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2350          void ZDSecMgrConfig( void )
   \                     ZDSecMgrConfig:
   \   000000   80..         SJMP    ?Subroutine7
   2351          {
   2352            if ( ZG_SECURE_ENABLED )
   2353            {
   2354              SSP_Init();
   2355          
   2356              if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   2357                  || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   2358              {
   2359                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2360                {
   2361                  // COMMERCIAL MODE - COORDINATOR DEVICE
   2362                  APSME_SecurityCM_CD();
   2363                }
   2364                else if ( ZSTACK_ROUTER_BUILD )
   2365                {
   2366                  // COMMERCIAL MODE - ROUTER DEVICE
   2367                  APSME_SecurityCM_RD();
   2368                }
   2369                else
   2370                {
   2371                  // COMMERCIAL MODE - END DEVICE
   2372                  APSME_SecurityCM_ED();
   2373                }
   2374              }
   2375              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2376              {
   2377                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2378                {
   2379                  // RESIDENTIAL MODE - COORDINATOR DEVICE
   2380                  APSME_SecurityRM_CD();
   2381                }
   2382                else if ( ZSTACK_ROUTER_BUILD )
   2383                {
   2384                  // RESIDENTIAL MODE - ROUTER DEVICE
   2385                  APSME_SecurityRM_RD();
   2386                }
   2387                else
   2388                {
   2389                  // RESIDENTIAL MODE - END DEVICE
   2390                  APSME_SecurityRM_ED();
   2391                }
   2392              }
   2393            }
   2394            else
   2395            {
   2396              // NO SECURITY
   2397              APSME_SecurityNM();
   2398            }
   2399          }
   2400          
   2401          /******************************************************************************
   2402           * @fn          ZDSecMgrPermitJoining
   2403           *
   2404           * @brief       Process request to change joining permissions.
   2405           *
   2406           * @param       duration - [in] timed duration for join in seconds
   2407           *                         - 0x00 not allowed
   2408           *                         - 0xFF allowed without timeout
   2409           *
   2410           * @return      uint8 - success(TRUE:FALSE)
   2411           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2412          uint8 ZDSecMgrPermitJoining( uint8 duration )
   \                     ZDSecMgrPermitJoining:
   2413          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   \   000005   F8           MOV     R0,A
   2414            uint8 accept;
   2415          
   2416          
   2417            ZDSecMgrPermitJoiningTimed = FALSE;
   \   000006   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000009   E4           CLR     A
   \   00000A   F0           MOVX    @DPTR,A
   2418          
   2419            if ( duration > 0 )
   \   00000B   E8           MOV     A,R0
   \   00000C   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00000F   600F         JZ      ??ZDSecMgrPermitJoining_0
   2420            {
   2421              ZDSecMgrPermitJoiningEnabled = TRUE;
   \   000011   7401         MOV     A,#0x1
   \   000013   F0           MOVX    @DPTR,A
   2422          
   2423              if ( duration != 0xFF )
   \   000014   74FF         MOV     A,#-0x1
   \   000016   68           XRL     A,R0
   \   000017   6009         JZ      ??ZDSecMgrPermitJoining_1
   2424              {
   2425                ZDSecMgrPermitJoiningTimed = TRUE;
   \   000019   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   00001C   7401         MOV     A,#0x1
   \   00001E   8001         SJMP    ??ZDSecMgrPermitJoining_2
   2426              }
   2427            }
   2428            else
   2429            {
   2430              ZDSecMgrPermitJoiningEnabled = FALSE;
   \                     ??ZDSecMgrPermitJoining_0:
   \   000020   E4           CLR     A
   \                     ??ZDSecMgrPermitJoining_2:
   \   000021   F0           MOVX    @DPTR,A
   2431            }
   2432          
   2433            accept = TRUE;
   2434          
   2435            return accept;
   \                     ??ZDSecMgrPermitJoining_1:
   \   000022   7901         MOV     R1,#0x1
   \   000024   02....       LJMP    ??Subroutine77_0 & 0xFFFF
   2436          }
   2437          
   2438          /******************************************************************************
   2439           * @fn          ZDSecMgrPermitJoiningTimeout
   2440           *
   2441           * @brief       Process permit joining timeout
   2442           *
   2443           * @param       none
   2444           *
   2445           * @return      none
   2446           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2447          void ZDSecMgrPermitJoiningTimeout( void )
   \                     ZDSecMgrPermitJoiningTimeout:
   2448          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2449            if ( ZDSecMgrPermitJoiningTimed == TRUE )
   \   000004   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6401         XRL     A,#0x1
   \   00000A   7009         JNZ     ??ZDSecMgrPermitJoiningTimeout_0
   2450            {
   2451              ZDSecMgrPermitJoiningEnabled = FALSE;
   \   00000C   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00000F   E4           CLR     A
   \   000010   F0           MOVX    @DPTR,A
   2452              ZDSecMgrPermitJoiningTimed   = FALSE;
   \   000011   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000014   F0           MOVX    @DPTR,A
   2453            }
   2454          }
   \                     ??ZDSecMgrPermitJoiningTimeout_0:
   \   000015   02....       LJMP    ??Subroutine77_0 & 0xFFFF
   2455          
   2456          /******************************************************************************
   2457           * @fn          ZDSecMgrNewDeviceEvent
   2458           *
   2459           * @brief       Process a the new device event, if found reset new device
   2460           *              event/timer.
   2461           *
   2462           * @param       none
   2463           *
   2464           * @return      uint8 - found(TRUE:FALSE)
   2465           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2466          uint8 ZDSecMgrNewDeviceEvent( void )
   \                     ZDSecMgrNewDeviceEvent:
   2467          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 23
   \   000005   74E9         MOV     A,#-0x17
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2468            uint8                 found;
   2469            ZDSecMgrDevice_t      device;
   2470            AddrMgrEntry_t        addrEntry;
   2471            associated_devices_t* assoc;
   2472            ZStatus_t             status;
   2473          
   2474            // initialize return results
   2475            found = FALSE;
   \   00000A   75..00       MOV     ?V0,#0x0
   2476          
   2477            // look for device in the security init state
   2478            assoc = AssocMatchDeviceStatus( DEV_SEC_INIT_STATUS );
   \   00000D                ; Setup parameters for call to function AssocMatchDeviceStatus
   \   00000D   7904         MOV     R1,#0x4
   \   00000F   12....       LCALL   `??AssocMatchDeviceStatus::?relay`; Banked call to: AssocMatchDeviceStatus
   \   000012   8A..         MOV     ?V2,R2
   \   000014   8B..         MOV     ?V3,R3
   \   000016   AE..         MOV     R6,?V2
   \   000018   AF..         MOV     R7,?V3
   2479          
   2480            if ( assoc != NULL )
   \   00001A   EE           MOV     A,R6
   \   00001B   4F           ORL     A,R7
   \   00001C   7003         JNZ     $+5
   \   00001E   02....       LJMP    ??ZDSecMgrNewDeviceEvent_0 & 0xFFFF
   2481            {
   2482              // device found
   2483              found = TRUE;
   \   000021   75..01       MOV     ?V0,#0x1
   2484          
   2485              // check for preconfigured security
   2486              if ( zgPreConfigKeys == TRUE )
   \   000024   90....       MOV     DPTR,#zgPreConfigKeys
   \   000027   E0           MOVX    A,@DPTR
   \   000028   6401         XRL     A,#0x1
   \   00002A   7003         JNZ     ??ZDSecMgrNewDeviceEvent_1
   2487              {
   2488                // set association status to authenticated
   2489                ZDSecMgrAssocDeviceAuth( assoc );
   \   00002C                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   00002C   12....       LCALL   `??ZDSecMgrAssocDeviceAuth::?relay`; Banked call to: ZDSecMgrAssocDeviceAuth
   2490              }
   2491          
   2492              // set up device info
   2493              addrEntry.user  = ADDRMGR_USER_DEFAULT;
   \                     ??ZDSecMgrNewDeviceEvent_1:
   \   00002F   740A         MOV     A,#0xa
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   E4           CLR     A
   \   000035   F0           MOVX    @DPTR,A
   2494              addrEntry.index = assoc->addrIdx;
   \   000036   8E82         MOV     DPL,R6
   \   000038   8F83         MOV     DPH,R7
   \   00003A   12....       LCALL   ??Subroutine87_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_195:
   \   00003D   7415         MOV     A,#0x15
   \   00003F   12....       LCALL   ?XSTACK_DISP0_8
   \   000042   12....       LCALL   ??Subroutine84_0 & 0xFFFF
   2495              AddrMgrEntryGet( &addrEntry );
   \                     ??CrossCallReturnLabel_184:
   \   000045   12....       LCALL   ?XSTACK_DISP101_8
   \   000048   12....       LCALL   `??AddrMgrEntryGet::?relay`; Banked call to: AddrMgrEntryGet
   2496          
   2497              device.nwkAddr    = assoc->shortAddr;
   \   00004B   8E82         MOV     DPL,R6
   \   00004D   8F83         MOV     DPH,R7
   \   00004F   12....       LCALL   ?Subroutine31 & 0xFFFF
   2498              device.extAddr    = addrEntry.extAddr;
   \                     ??CrossCallReturnLabel_143:
   \   000052   740D         MOV     A,#0xd
   \   000054   12....       LCALL   ?XSTACK_DISP0_8
   \   000057   A882         MOV     R0,DPL
   \   000059   A983         MOV     R1,DPH
   \   00005B   7402         MOV     A,#0x2
   \   00005D   12....       LCALL   ?XSTACK_DISP0_8
   \   000060   12....       LCALL   ??Subroutine79_0 & 0xFFFF
   2499              device.parentAddr = NLME_GetShortAddr();
   \                     ??CrossCallReturnLabel_139:
   \   000063                ; Setup parameters for call to function NLME_GetShortAddr
   \   000063   12....       LCALL   `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   000066   7404         MOV     A,#0x4
   \   000068   12....       LCALL   ?XSTACK_DISP0_8
   \   00006B   12....       LCALL   ??Subroutine78_0 & 0xFFFF
   2500              device.secure     = FALSE;
   \                     ??CrossCallReturnLabel_126:
   \   00006E   7406         MOV     A,#0x6
   \   000070   12....       LCALL   ?XSTACK_DISP0_8
   \   000073   E4           CLR     A
   \   000074   F0           MOVX    @DPTR,A
   2501              device.devStatus  = assoc->devStatus;
   \   000075   EE           MOV     A,R6
   \   000076   2405         ADD     A,#0x5
   \   000078   FE           MOV     R6,A
   \   000079   5001         JNC     ??ZDSecMgrNewDeviceEvent_2
   \   00007B   0F           INC     R7
   \                     ??ZDSecMgrNewDeviceEvent_2:
   \   00007C   8E82         MOV     DPL,R6
   \   00007E   8F83         MOV     DPH,R7
   \   000080   E0           MOVX    A,@DPTR
   \   000081   C0E0         PUSH    A
   \   000083   7407         MOV     A,#0x7
   \   000085   12....       LCALL   ?XSTACK_DISP0_8
   \   000088   D0E0         POP     A
   \   00008A   12....       LCALL   ??Subroutine80_0 & 0xFFFF
   2502          
   2503              // process new device
   2504              status = ZDSecMgrDeviceNew( &device );
   \                     ??CrossCallReturnLabel_159:
   \   00008D   12....       LCALL   `??ZDSecMgrDeviceNew::?relay`; Banked call to: ZDSecMgrDeviceNew
   \   000090   E9           MOV     A,R1
   \   000091   F8           MOV     R0,A
   2505          
   2506              if ( status == ZSuccess )
   \   000092   700A         JNZ     ??ZDSecMgrNewDeviceEvent_3
   2507              {
   2508                assoc->devStatus &= ~DEV_SEC_INIT_STATUS;
   \   000094   8E82         MOV     DPL,R6
   \   000096   8F83         MOV     DPH,R7
   \   000098   E0           MOVX    A,@DPTR
   \   000099   C2E2         CLR     0xE0 /* A   */.2
   \   00009B   F0           MOVX    @DPTR,A
   \   00009C   8011         SJMP    ??ZDSecMgrNewDeviceEvent_0
   2509              }
   2510              else if ( status == ZNwkUnknownDevice )
   \                     ??ZDSecMgrNewDeviceEvent_3:
   \   00009E   74C8         MOV     A,#-0x38
   \   0000A0   68           XRL     A,R0
   \   0000A1   700C         JNZ     ??ZDSecMgrNewDeviceEvent_0
   2511              {
   2512                AssocRemove( addrEntry.extAddr );
   \   0000A3                ; Setup parameters for call to function AssocRemove
   \   0000A3   740D         MOV     A,#0xd
   \   0000A5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A8   AA82         MOV     R2,DPL
   \   0000AA   AB83         MOV     R3,DPH
   \   0000AC   12....       LCALL   `??AssocRemove::?relay`; Banked call to: AssocRemove
   2513              }
   2514            }
   2515          
   2516            return found;
   \                     ??ZDSecMgrNewDeviceEvent_0:
   \   0000AF   A9..         MOV     R1,?V0
   \   0000B1   7417         MOV     A,#0x17
   \   0000B3   80..         SJMP    ??Subroutine81_0
   2517          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   12....       LCALL   ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   000003                REQUIRE ??Subroutine79_0
   \   000003                ; // Fall through to label ??Subroutine79_0
   2518          
   2519          /******************************************************************************
   2520           * @fn          ZDSecMgrEvent
   2521           *
   2522           * @brief       Handle ZDO Security Manager event/timer(ZDO_SECMGR_EVENT).
   2523           *
   2524           * @param       none
   2525           *
   2526           * @return      none
   2527           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004                REQUIRE ??Subroutine80_0
   \   000004                ; // Fall through to label ??Subroutine80_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2528          void ZDSecMgrEvent( void )
   \                     ZDSecMgrEvent:
   2529          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 23
   \   000005   74E9         MOV     A,#-0x17
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2530            uint8            action;
   2531            uint8            restart;
   2532            uint16           index;
   2533            AddrMgrEntry_t   entry;
   2534            ZDSecMgrDevice_t device;
   2535          
   2536          
   2537            // verify data is available
   2538            if ( ZDSecMgrCtrlData != NULL )
   \   00000A   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00000D   12....       LCALL   ??Subroutine83_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_170:
   \   000010   7003         JNZ     $+5
   \   000012   02....       LJMP    ??ZDSecMgrEvent_0 & 0xFFFF
   2539            {
   2540              action  = FALSE;
   \   000015   75..00       MOV     ?V1,#0x0
   2541              restart = FALSE;
   \   000018   75..00       MOV     ?V0,#0x0
   2542          
   2543              // update all the counters
   2544              for ( index = 0; index < ZDSECMGR_ENTRY_MAX; index++ )
   \   00001B   7E00         MOV     R6,#0x0
   \   00001D   7F00         MOV     R7,#0x0
   2545              {
   2546                if ( ZDSecMgrCtrlData[index].state !=  ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrEvent_1:
   \   00001F   EE           MOV     A,R6
   \   000020   F8           MOV     R0,A
   \   000021   EF           MOV     A,R7
   \   000022   F9           MOV     R1,A
   \   000023   E8           MOV     A,R0
   \   000024   75F007       MOV     B,#0x7
   \   000027   A4           MUL     AB
   \   000028   F8           MOV     R0,A
   \   000029   AAF0         MOV     R2,B
   \   00002B   75F007       MOV     B,#0x7
   \   00002E   E9           MOV     A,R1
   \   00002F   A4           MUL     AB
   \   000030   2A           ADD     A,R2
   \   000031   F9           MOV     R1,A
   \   000032   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000035   E0           MOVX    A,@DPTR
   \   000036   28           ADD     A,R0
   \   000037   FA           MOV     R2,A
   \   000038   A3           INC     DPTR
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   39           ADDC    A,R1
   \   00003B   FB           MOV     R3,A
   \   00003C   8A82         MOV     DPL,R2
   \   00003E   8B83         MOV     DPH,R3
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   E0           MOVX    A,@DPTR
   \   000046   7003         JNZ     $+5
   \   000048   02....       LJMP    ??ZDSecMgrEvent_2 & 0xFFFF
   2547                {
   2548                  if ( ZDSecMgrCtrlData[index].cntr != 0 )
   \   00004B   EA           MOV     A,R2
   \   00004C   2406         ADD     A,#0x6
   \   00004E   F582         MOV     DPL,A
   \   000050   E4           CLR     A
   \   000051   3B           ADDC    A,R3
   \   000052   F583         MOV     DPH,A
   \   000054   E0           MOVX    A,@DPTR
   \   000055   6002         JZ      ??ZDSecMgrEvent_3
   2549                  {
   2550                    ZDSecMgrCtrlData[index].cntr--;
   \   000057   14           DEC     A
   \   000058   F0           MOVX    @DPTR,A
   2551                  }
   2552          
   2553                  if ( ( action == FALSE ) && ( ZDSecMgrCtrlData[index].cntr == 0 ) )
   \                     ??ZDSecMgrEvent_3:
   \   000059   E5..         MOV     A,?V1
   \   00005B   A2E0         MOV     C,0xE0 /* A   */.0
   \   00005D   5003         JNC     $+5
   \   00005F   02....       LJMP    ??ZDSecMgrEvent_4 & 0xFFFF
   \   000062   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000065   E0           MOVX    A,@DPTR
   \   000066   28           ADD     A,R0
   \   000067   F8           MOV     R0,A
   \   000068   A3           INC     DPTR
   \   000069   E0           MOVX    A,@DPTR
   \   00006A   39           ADDC    A,R1
   \   00006B   F9           MOV     R1,A
   \   00006C   8882         MOV     DPL,R0
   \   00006E   8983         MOV     DPH,R1
   \   000070   A3           INC     DPTR
   \   000071   A3           INC     DPTR
   \   000072   A3           INC     DPTR
   \   000073   A3           INC     DPTR
   \   000074   A3           INC     DPTR
   \   000075   A3           INC     DPTR
   \   000076   E0           MOVX    A,@DPTR
   \   000077   706A         JNZ     ??ZDSecMgrEvent_4
   2554                  {
   2555                    action = TRUE;
   \   000079   75..01       MOV     ?V1,#0x1
   2556          
   2557                    // update from control data
   2558                    device.parentAddr = ZDSecMgrCtrlData[index].parentAddr;
   \   00007C   8882         MOV     DPL,R0
   \   00007E   8983         MOV     DPH,R1
   \   000080   A3           INC     DPTR
   \   000081   A3           INC     DPTR
   \   000082   12....       LCALL   ??Subroutine75_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_109:
   \   000085   7404         MOV     A,#0x4
   \   000087   12....       LCALL   ?XSTACK_DISP0_8
   \   00008A   12....       LCALL   ??Subroutine78_0 & 0xFFFF
   2559                    device.secure     = ZDSecMgrCtrlData[index].secure;
   \                     ??CrossCallReturnLabel_127:
   \   00008D   8882         MOV     DPL,R0
   \   00008F   8983         MOV     DPH,R1
   \   000091   A3           INC     DPTR
   \   000092   A3           INC     DPTR
   \   000093   A3           INC     DPTR
   \   000094   A3           INC     DPTR
   \   000095   E0           MOVX    A,@DPTR
   \   000096   C0E0         PUSH    A
   \   000098   7406         MOV     A,#0x6
   \   00009A   12....       LCALL   ?XSTACK_DISP0_8
   \   00009D   D0E0         POP     A
   \   00009F   F0           MOVX    @DPTR,A
   2560                    device.ctrl       = &ZDSecMgrCtrlData[index];
   \   0000A0   7408         MOV     A,#0x8
   \   0000A2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A5   12....       LCALL   ??Subroutine84_0 & 0xFFFF
   2561          
   2562                    // set the user and address index
   2563                    entry.user  = ADDRMGR_USER_SECURITY;
   \                     ??CrossCallReturnLabel_185:
   \   0000A8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AB   7402         MOV     A,#0x2
   \   0000AD   12....       LCALL   ?Subroutine32 & 0xFFFF
   2564                    entry.index = ZDSecMgrCtrlData[index].entry->ami;
   \                     ??CrossCallReturnLabel_21:
   \   0000B0   F583         MOV     DPH,A
   \   0000B2   8882         MOV     DPL,R0
   \   0000B4   12....       LCALL   ??Subroutine88_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_190:
   \   0000B7   7415         MOV     A,#0x15
   \   0000B9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BC   12....       LCALL   ??Subroutine84_0 & 0xFFFF
   2565          
   2566                    // get the address data
   2567                    AddrMgrEntryGet( &entry );
   \                     ??CrossCallReturnLabel_186:
   \   0000BF   12....       LCALL   ?XSTACK_DISP101_8
   \   0000C2   12....       LCALL   `??AddrMgrEntryGet::?relay`; Banked call to: AddrMgrEntryGet
   2568          
   2569                    // set device address data
   2570                    device.nwkAddr = entry.nwkAddr;
   \   0000C5   740B         MOV     A,#0xb
   \   0000C7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CA   12....       LCALL   ?Subroutine31 & 0xFFFF
   2571                    device.extAddr = entry.extAddr;
   \                     ??CrossCallReturnLabel_144:
   \   0000CD   740D         MOV     A,#0xd
   \   0000CF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D2   A882         MOV     R0,DPL
   \   0000D4   A983         MOV     R1,DPH
   \   0000D6   7402         MOV     A,#0x2
   \   0000D8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DB   12....       LCALL   ?Subroutine15 & 0xFFFF
   2572          
   2573                    // update from entry data
   2574                    ZDSecMgrDeviceCtrlHandler( &device );
   2575                  }
   \                     ??CrossCallReturnLabel_146:
   \   0000DE   12....       LCALL   `??ZDSecMgrDeviceCtrlHandler::?relay`; Banked call to: ZDSecMgrDeviceCtrlHandler
   \   0000E1   8003         SJMP    ??ZDSecMgrEvent_2
   2576                  else
   2577                  {
   2578                    restart = TRUE;
   \                     ??ZDSecMgrEvent_4:
   \   0000E3   75..01       MOV     ?V0,#0x1
   2579                  }
   2580                }
   2581              }
   \                     ??ZDSecMgrEvent_2:
   \   0000E6   0E           INC     R6
   \   0000E7   EE           MOV     A,R6
   \   0000E8   7001         JNZ     ??ZDSecMgrEvent_5
   \   0000EA   0F           INC     R7
   \                     ??ZDSecMgrEvent_5:
   \   0000EB   C3           CLR     C
   \   0000EC   9403         SUBB    A,#0x3
   \   0000EE   EF           MOV     A,R7
   \   0000EF   9400         SUBB    A,#0x0
   \   0000F1   5003         JNC     $+5
   \   0000F3   02....       LJMP    ??ZDSecMgrEvent_1 & 0xFFFF
   2582          
   2583              // check for timer restart
   2584              if ( restart == TRUE )
   \   0000F6   E5..         MOV     A,?V0
   \   0000F8   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000FA   5010         JNC     ??ZDSecMgrEvent_0
   2585              {
   2586                osal_start_timerEx(ZDAppTaskID, ZDO_SECMGR_EVENT, 100 );
   \   0000FC                ; Setup parameters for call to function osal_start_timerEx
   \   0000FC   7C64         MOV     R4,#0x64
   \   0000FE   7D00         MOV     R5,#0x0
   \   000100   7A00         MOV     R2,#0x0
   \   000102   7B01         MOV     R3,#0x1
   \   000104   90....       MOV     DPTR,#ZDAppTaskID
   \   000107   E0           MOVX    A,@DPTR
   \   000108   F9           MOV     R1,A
   \   000109   12....       LCALL   `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   2587              }
   2588            }
   2589          }
   \                     ??ZDSecMgrEvent_0:
   \   00010C   7417         MOV     A,#0x17
   \   00010E   02....       LJMP    ??Subroutine85_0 & 0xFFFF
   2590          
   2591          /******************************************************************************
   2592           * @fn          ZDSecMgrEstablishKeyCfm
   2593           *
   2594           * @brief       Process the ZDO_EstablishKeyCfm_t message.
   2595           *
   2596           * @param       cfm - [in] ZDO_EstablishKeyCfm_t confirmation
   2597           *
   2598           * @return      none
   2599           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2600          void ZDSecMgrEstablishKeyCfm( ZDO_EstablishKeyCfm_t* cfm )
   \                     ZDSecMgrEstablishKeyCfm:
   2601          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2602            // send the NWK key
   2603            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2604            {
   2605              // update control for specified EXT address
   2606              ZDSecMgrDeviceCtrlUpdate( cfm->partExtAddr, ZDSECMGR_CTRL_SKKE_DONE );
   2607            }
   2608            else
   2609            {
   2610              // this should be done when receiving the NWK key
   2611              // if devState ==
   2612              //if ( devState == DEV_END_DEVICE_UNAUTH )
   2613                  //osal_set_event( ZDAppTaskID, ZDO_DEVICE_AUTH );
   2614          
   2615              // if not in joining state -- this should trigger an event for an
   2616              // end point that requested SKKE
   2617              // if ( devState == DEV_END_DEVICE )
   2618             //       devState == DEV_ROUTER;
   2619          
   2620            }
   2621          }
   \   000000   02....       LJMP    ?BRET
   2622          
   2623          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2624          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr )
   \                     ZDSecMgrTCExtAddrCheck:
   2625          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2626            uint8  match;
   2627            uint8  lookup[Z_EXTADDR_LEN];
   2628          
   2629            match = FALSE;
   \   00000E   75..00       MOV     ?V0,#0x0
   2630          
   2631            if ( AddrMgrExtAddrLookup( APSME_TRUSTCENTER_NWKADDR, lookup ) )
   \   000011                ; Setup parameters for call to function AddrMgrExtAddrLookup
   \   000011   AC..         MOV     R4,?XSP + 0
   \   000013   AD..         MOV     R5,?XSP + 1
   \   000015   7A00         MOV     R2,#0x0
   \   000017   7B00         MOV     R3,#0x0
   \   000019   12....       LCALL   `??AddrMgrExtAddrLookup::?relay`; Banked call to: AddrMgrExtAddrLookup
   \   00001C   E9           MOV     A,R1
   \   00001D   600E         JZ      ??ZDSecMgrTCExtAddrCheck_0
   2632            {
   2633              match = AddrMgrExtAddrEqual( lookup, extAddr );
   \   00001F                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   00001F   EE           MOV     A,R6
   \   000020   FC           MOV     R4,A
   \   000021   EF           MOV     A,R7
   \   000022   FD           MOV     R5,A
   \   000023   AA..         MOV     R2,?XSP + 0
   \   000025   AB..         MOV     R3,?XSP + 1
   \   000027   12....       LCALL   `??AddrMgrExtAddrEqual::?relay`; Banked call to: AddrMgrExtAddrEqual
   \   00002A   E9           MOV     A,R1
   \   00002B   F5..         MOV     ?V0,A
   2634            }
   2635          
   2636            return match;
   \                     ??ZDSecMgrTCExtAddrCheck_0:
   \   00002D   A9..         MOV     R1,?V0
   \   00002F   7408         MOV     A,#0x8
   \   000031   02....       LJMP    ??Subroutine71_0 & 0xFFFF
   2637          }
   2638          
   2639          void ZDSecMgrTCDataLoad( uint8* extAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2640          void ZDSecMgrTCDataLoad( uint8* extAddr )
   \                     ZDSecMgrTCDataLoad:
   2641          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2642            uint16 ami;
   2643            uint8* key;
   2644          
   2645            if ( !ZDSecMgrTCDataLoaded )
   \   00000A   90....       MOV     DPTR,#ZDSecMgrTCDataLoaded
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   7046         JNZ     ??ZDSecMgrTCDataLoad_0
   2646            {
   2647              if ( ZDSecMgrAddrStore( APSME_TRUSTCENTER_NWKADDR, extAddr, &ami ) == ZSuccess )
   \   000010                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000010   A8..         MOV     R0,?XSP + 0
   \   000012   A9..         MOV     R1,?XSP + 1
   \   000014   88..         MOV     ?V0,R0
   \   000016   89..         MOV     ?V1,R1
   \   000018   78..         MOV     R0,#?V0
   \   00001A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001D   EA           MOV     A,R2
   \   00001E   FC           MOV     R4,A
   \   00001F   EB           MOV     A,R3
   \   000020   FD           MOV     R5,A
   \   000021   7A00         MOV     R2,#0x0
   \   000023   7B00         MOV     R3,#0x0
   \   000025   12....       LCALL   `??ZDSecMgrAddrStore::?relay`; Banked call to: ZDSecMgrAddrStore
   \   000028   7402         MOV     A,#0x2
   \   00002A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00002D   E9           MOV     A,R1
   \   00002E   7020         JNZ     ??ZDSecMgrTCDataLoad_1
   2648              {
   2649                // if preconfigured load key
   2650                if ( zgPreConfigKeys == TRUE )
   \   000030   90....       MOV     DPTR,#zgPreConfigKeys
   \   000033   E0           MOVX    A,@DPTR
   \   000034   6401         XRL     A,#0x1
   \   000036   7018         JNZ     ??ZDSecMgrTCDataLoad_1
   2651                {
   2652                  if ( ZDSecMgrMasterKeyLookup( ami, &key ) != ZSuccess )
   \   000038                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000038   7402         MOV     A,#0x2
   \   00003A   12....       LCALL   ?XSTACK_DISP102_8
   \   00003D   12....       LCALL   ??Subroutine74_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_116:
   \   000040   12....       LCALL   `??ZDSecMgrMasterKeyLookup::?relay`; Banked call to: ZDSecMgrMasterKeyLookup
   \   000043   E9           MOV     A,R1
   \   000044   600A         JZ      ??ZDSecMgrTCDataLoad_1
   2653                  {
   2654                    ZDSecMgrMasterKeyStore( ami, ZDSecMgrTCMasterKey );
   \   000046                ; Setup parameters for call to function ZDSecMgrMasterKeyStore
   \   000046   7C..         MOV     R4,#ZDSecMgrTCMasterKey & 0xff
   \   000048   7D..         MOV     R5,#(ZDSecMgrTCMasterKey >> 8) & 0xff
   \   00004A   12....       LCALL   ??Subroutine74_0 & 0xFFFF
   2655                  }
   2656                }
   2657              }
   \                     ??CrossCallReturnLabel_117:
   \   00004D   12....       LCALL   `??ZDSecMgrMasterKeyStore::?relay`; Banked call to: ZDSecMgrMasterKeyStore
   2658          
   2659              ZDSecMgrTCDataLoaded = TRUE;
   \                     ??ZDSecMgrTCDataLoad_1:
   \   000050   90....       MOV     DPTR,#ZDSecMgrTCDataLoaded
   \   000053   7401         MOV     A,#0x1
   \   000055   F0           MOVX    @DPTR,A
   2660            }
   2661          }
   \                     ??ZDSecMgrTCDataLoad_0:
   \   000056                REQUIRE ?Subroutine13
   \   000056                ; // Fall through to label ?Subroutine13

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   7404         MOV     A,#0x4
   \   000002   80..         SJMP    ??Subroutine85_0
   2662          
   2663          /******************************************************************************
   2664           * @fn          ZDSecMgrEstablishKeyInd
   2665           *
   2666           * @brief       Process the ZDO_EstablishKeyInd_t message.
   2667           *
   2668           * @param       ind - [in] ZDO_EstablishKeyInd_t indication
   2669           *
   2670           * @return      none
   2671           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2672          void ZDSecMgrEstablishKeyInd( ZDO_EstablishKeyInd_t* ind )
   \                     ZDSecMgrEstablishKeyInd:
   2673          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 17
   \   000005   74EF         MOV     A,#-0x11
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0,R2
   \   00000C   8B..         MOV     ?V1,R3
   2674            ZDSecMgrDevice_t        device;
   2675            APSME_EstablishKeyRsp_t rsp;
   2676          
   2677          
   2678            // load Trust Center data if needed
   2679            ZDSecMgrTCDataLoad( ind->initExtAddr );
   \   00000E   EA           MOV     A,R2
   \   00000F   2404         ADD     A,#0x4
   \   000011   FE           MOV     R6,A
   \   000012   E4           CLR     A
   \   000013   35..         ADDC    A,?V1
   \   000015   FF           MOV     R7,A
   \   000016                ; Setup parameters for call to function ZDSecMgrTCDataLoad
   \   000016   EE           MOV     A,R6
   \   000017   FA           MOV     R2,A
   \   000018   EF           MOV     A,R7
   \   000019   FB           MOV     R3,A
   \   00001A   12....       LCALL   `??ZDSecMgrTCDataLoad::?relay`; Banked call to: ZDSecMgrTCDataLoad
   2680          
   2681            if ( ZDSecMgrTCExtAddrCheck( ind->initExtAddr ) )
   \   00001D   E5..         MOV     A,?V0
   \   00001F   2402         ADD     A,#0x2
   \   000021   F5..         MOV     ?V2,A
   \   000023   E4           CLR     A
   \   000024   35..         ADDC    A,?V1
   \   000026   F5..         MOV     ?V3,A
   \   000028                ; Setup parameters for call to function ZDSecMgrTCExtAddrCheck
   \   000028   EE           MOV     A,R6
   \   000029   FA           MOV     R2,A
   \   00002A   EF           MOV     A,R7
   \   00002B   FB           MOV     R3,A
   \   00002C   12....       LCALL   `??ZDSecMgrTCExtAddrCheck::?relay`; Banked call to: ZDSecMgrTCExtAddrCheck
   \   00002F   E9           MOV     A,R1
   \   000030   6016         JZ      ??ZDSecMgrEstablishKeyInd_0
   2682            {
   2683              //IF (ind->srcAddr == APSME_TRUSTCENTER_NWKADDR)
   2684              //OR
   2685              //!ZDSecMgrTCAuthenticated
   2686              //devtag.0604.critical
   2687                  //how is the parentAddr used here
   2688          
   2689              // initial SKKE from Trust Center via parent
   2690              device.nwkAddr    = APSME_TRUSTCENTER_NWKADDR;
   \   000032   7407         MOV     A,#0x7
   \   000034   12....       LCALL   ?XSTACK_DISP0_8
   \   000037   E4           CLR     A
   \   000038   F0           MOVX    @DPTR,A
   \   000039   A3           INC     DPTR
   \   00003A   12....       LCALL   ?Subroutine21 & 0xFFFF
   2691              device.parentAddr = ind->srcAddr;
   2692            }
   \                     ??CrossCallReturnLabel_4:
   \   00003D   740B         MOV     A,#0xb
   \   00003F   12....       LCALL   ?XSTACK_DISP0_8
   \   000042   E8           MOV     A,R0
   \   000043   F0           MOVX    @DPTR,A
   \   000044   A3           INC     DPTR
   \   000045   E9           MOV     A,R1
   \   000046   801B         SJMP    ??ZDSecMgrEstablishKeyInd_1
   2693            else
   2694            {
   2695              // Trust Center direct or E2E SKKE
   2696              device.nwkAddr    = ind->srcAddr;
   \                     ??ZDSecMgrEstablishKeyInd_0:
   \   000048   85..82       MOV     DPL,?V2
   \   00004B   85..83       MOV     DPH,?V3
   \   00004E   12....       LCALL   ??Subroutine88_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_191:
   \   000051   7407         MOV     A,#0x7
   \   000053   12....       LCALL   ?XSTACK_DISP0_8
   \   000056   12....       LCALL   ??Subroutine79_0 & 0xFFFF
   2697              device.parentAddr = INVALID_NODE_ADDR;
   \                     ??CrossCallReturnLabel_140:
   \   000059   740B         MOV     A,#0xb
   \   00005B   12....       LCALL   ?XSTACK_DISP0_8
   \   00005E   74FE         MOV     A,#-0x2
   \   000060   F0           MOVX    @DPTR,A
   \   000061   A3           INC     DPTR
   \   000062   04           INC     A
   \                     ??ZDSecMgrEstablishKeyInd_1:
   \   000063   F0           MOVX    @DPTR,A
   2698            }
   2699          
   2700            device.extAddr = ind->initExtAddr;
   \   000064   7409         MOV     A,#0x9
   \   000066   12....       LCALL   ?XSTACK_DISP0_8
   \   000069   EE           MOV     A,R6
   \   00006A   F0           MOVX    @DPTR,A
   \   00006B   A3           INC     DPTR
   \   00006C   EF           MOV     A,R7
   \   00006D   F0           MOVX    @DPTR,A
   2701            //devtag.pro.security.0724.todo - verify usage
   2702            device.secure  = ind->nwkSecure;
   \   00006E   E5..         MOV     A,?V0
   \   000070   240E         ADD     A,#0xe
   \   000072   F5..         MOV     ?V4,A
   \   000074   E4           CLR     A
   \   000075   35..         ADDC    A,?V1
   \   000077   F5..         MOV     ?V5,A
   \   000079   85..82       MOV     DPL,?V4
   \   00007C   F583         MOV     DPH,A
   \   00007E   E0           MOVX    A,@DPTR
   \   00007F   C0E0         PUSH    A
   \   000081   740D         MOV     A,#0xd
   \   000083   12....       LCALL   ?XSTACK_DISP0_8
   \   000086   D0E0         POP     A
   \   000088   F0           MOVX    @DPTR,A
   2703          
   2704            // validate device for SKKE
   2705            if ( ZDSecMgrDeviceValidateSKKE( &device ) == ZSuccess )
   \   000089                ; Setup parameters for call to function ZDSecMgrDeviceValidateSKKE
   \   000089   7407         MOV     A,#0x7
   \   00008B   12....       LCALL   ?XSTACK_DISP101_8
   \   00008E   12....       LCALL   `??ZDSecMgrDeviceValidateSKKE::?relay`; Banked call to: ZDSecMgrDeviceValidateSKKE
   \   000091   E9           MOV     A,R1
   \   000092   7009         JNZ     ??ZDSecMgrEstablishKeyInd_2
   2706            {
   2707              rsp.accept = TRUE;
   \   000094   7404         MOV     A,#0x4
   \   000096   12....       LCALL   ?XSTACK_DISP0_8
   \   000099   7401         MOV     A,#0x1
   \   00009B   8006         SJMP    ??ZDSecMgrEstablishKeyInd_3
   2708            }
   2709            else
   2710            {
   2711              rsp.accept = FALSE;
   \                     ??ZDSecMgrEstablishKeyInd_2:
   \   00009D   7404         MOV     A,#0x4
   \   00009F   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A2   E4           CLR     A
   2712            }
   \                     ??ZDSecMgrEstablishKeyInd_3:
   \   0000A3   12....       LCALL   ?Subroutine21 & 0xFFFF
   2713          
   2714            rsp.dstAddr     = ind->srcAddr;
   \                     ??CrossCallReturnLabel_5:
   \   0000A6   12....       LCALL   ?Subroutine30 & 0xFFFF
   2715            rsp.initExtAddr = &ind->initExtAddr[0];
   \                     ??CrossCallReturnLabel_198:
   \   0000A9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AC   EE           MOV     A,R6
   \   0000AD   F0           MOVX    @DPTR,A
   \   0000AE   A3           INC     DPTR
   \   0000AF   EF           MOV     A,R7
   \   0000B0   F0           MOVX    @DPTR,A
   2716            //devtag.0604.todo - remove obsolete
   2717            rsp.apsSecure   = ind->apsSecure;
   \   0000B1   E5..         MOV     A,?V0
   \   0000B3   240D         ADD     A,#0xd
   \   0000B5   F582         MOV     DPL,A
   \   0000B7   E4           CLR     A
   \   0000B8   35..         ADDC    A,?V1
   \   0000BA   F583         MOV     DPH,A
   \   0000BC   E0           MOVX    A,@DPTR
   \   0000BD   C0E0         PUSH    A
   \   0000BF   7405         MOV     A,#0x5
   \   0000C1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C4   D0E0         POP     A
   \   0000C6   F0           MOVX    @DPTR,A
   2718            rsp.nwkSecure   = ind->nwkSecure;
   \   0000C7   85..82       MOV     DPL,?V4
   \   0000CA   85..83       MOV     DPH,?V5
   \   0000CD   E0           MOVX    A,@DPTR
   \   0000CE   C0E0         PUSH    A
   \   0000D0   7406         MOV     A,#0x6
   \   0000D2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D5   D0E0         POP     A
   \   0000D7   12....       LCALL   ??Subroutine80_0 & 0xFFFF
   2719          
   2720            APSME_EstablishKeyRsp( &rsp );
   \                     ??CrossCallReturnLabel_160:
   \   0000DA   12....       LCALL   `??APSME_EstablishKeyRsp::?relay`; Banked call to: APSME_EstablishKeyRsp
   2721          }
   \   0000DD   7411         MOV     A,#0x11
   \   0000DF   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E2   02....       LJMP    ?Subroutine3 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine89_0
   \   000006                ; // Fall through to label ??Subroutine89_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?V2
   \   000004   85..83       MOV     DPH,?V3
   \   000007   12....       LCALL   ??Subroutine91_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_209:
   \   00000A   22           RET
   2722          //devtag.pro.security
   2723          #if 0
   2724          void ZDSecMgrEstablishKeyInd( ZDO_EstablishKeyInd_t* ind )
   2725          {
   2726            ZDSecMgrDevice_t        device;
   2727            APSME_EstablishKeyRsp_t rsp;
   2728          
   2729          
   2730            device.extAddr = ind->initExtAddr;
   2731            device.secure  = ind->secure;
   2732          
   2733            if ( ind->secure == FALSE )
   2734            {
   2735              // SKKE from Trust Center is not secured between child and parent
   2736              device.nwkAddr    = APSME_TRUSTCENTER_NWKADDR;
   2737              device.parentAddr = ind->srcAddr;
   2738            }
   2739            else
   2740            {
   2741              // SKKE from initiator should be secured
   2742              device.nwkAddr    = ind->srcAddr;
   2743              device.parentAddr = INVALID_NODE_ADDR;
   2744            }
   2745          
   2746            rsp.dstAddr     = ind->srcAddr;
   2747            rsp.initExtAddr = &ind->initExtAddr[0];
   2748            rsp.secure      = ind->secure;
   2749          
   2750            // validate device for SKKE
   2751            if ( ZDSecMgrDeviceValidateSKKE( &device ) == ZSuccess )
   2752            {
   2753              rsp.accept = TRUE;
   2754            }
   2755            else
   2756            {
   2757              rsp.accept = FALSE;
   2758            }
   2759          
   2760            APSME_EstablishKeyRsp( &rsp );
   2761          }
   2762          #endif
   2763          
   2764          /******************************************************************************
   2765           * @fn          ZDSecMgrTransportKeyInd
   2766           *
   2767           * @brief       Process the ZDO_TransportKeyInd_t message.
   2768           *
   2769           * @param       ind - [in] ZDO_TransportKeyInd_t indication
   2770           *
   2771           * @return      none
   2772           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2773          void ZDSecMgrTransportKeyInd( ZDO_TransportKeyInd_t* ind )
   \                     ZDSecMgrTransportKeyInd:
   2774          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2775            uint8 index;
   2776          
   2777            // load Trust Center data if needed
   2778            ZDSecMgrTCDataLoad( ind->srcExtAddr );
   \   000009                ; Setup parameters for call to function ZDSecMgrTCDataLoad
   \   000009   EE           MOV     A,R6
   \   00000A   2416         ADD     A,#0x16
   \   00000C   FA           MOV     R2,A
   \   00000D   E4           CLR     A
   \   00000E   3F           ADDC    A,R7
   \   00000F   FB           MOV     R3,A
   \   000010   12....       LCALL   `??ZDSecMgrTCDataLoad::?relay`; Banked call to: ZDSecMgrTCDataLoad
   2779          
   2780            if ( ind->keyType == KEY_TYPE_TC_MASTER )
   \   000013   8E82         MOV     DPL,R6
   \   000015   8F83         MOV     DPH,R7
   \   000017   A3           INC     DPTR
   \   000018   A3           INC     DPTR
   \   000019   A3           INC     DPTR
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F8           MOV     R0,A
   \   00001D   606B         JZ      ??ZDSecMgrTransportKeyInd_0
   2781            {
   2782              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2783              //ZDSecMgrTCMasterKey( ind );
   2784              {
   2785                if ( zgPreConfigKeys != TRUE )
   2786                {
   2787                  // devtag.pro.security.todo - check if Trust Center address is configured and correct
   2788                  ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2789                }
   2790                else
   2791                {
   2792                  // error condition - reject key
   2793                }
   2794              }
   2795            }
   2796            else if ( ( ind->keyType == KEY_TYPE_NWK      ) ||
   2797                      ( ind->keyType == 6                 ) ||
   2798                      ( ind->keyType == KEY_TYPE_NWK_HIGH )    )
   \   00001F   7401         MOV     A,#0x1
   \   000021   68           XRL     A,R0
   \   000022   600A         JZ      ??ZDSecMgrTransportKeyInd_1
   \   000024   7406         MOV     A,#0x6
   \   000026   68           XRL     A,R0
   \   000027   6005         JZ      ??ZDSecMgrTransportKeyInd_1
   \   000029   7405         MOV     A,#0x5
   \   00002B   68           XRL     A,R0
   \   00002C   705C         JNZ     ??ZDSecMgrTransportKeyInd_0
   2799            {
   2800              // check for dummy NWK key (all zeros)
   2801              for ( index = 0;
   \                     ??ZDSecMgrTransportKeyInd_1:
   \   00002E   7A00         MOV     R2,#0x0
   \                     ??ZDSecMgrTransportKeyInd_2:
   \   000030   EA           MOV     A,R2
   \   000031   F8           MOV     R0,A
   \   000032   EE           MOV     A,R6
   \   000033   28           ADD     A,R0
   \   000034   F582         MOV     DPL,A
   \   000036   E4           CLR     A
   \   000037   3F           ADDC    A,R7
   \   000038   F583         MOV     DPH,A
   \   00003A   A3           INC     DPTR
   \   00003B   A3           INC     DPTR
   \   00003C   A3           INC     DPTR
   \   00003D   A3           INC     DPTR
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   E0           MOVX    A,@DPTR
   \   000041   7007         JNZ     ??ZDSecMgrTransportKeyInd_3
   2802                    ( (index < SEC_KEY_LEN) && (ind->key[index] == 0) );
   2803                    index++ );
   \   000043   0A           INC     R2
   \   000044   EA           MOV     A,R2
   \   000045   C3           CLR     C
   \   000046   9410         SUBB    A,#0x10
   \   000048   40E6         JC      ??ZDSecMgrTransportKeyInd_2
   2804          
   2805              if ( index == SEC_KEY_LEN )
   \                     ??ZDSecMgrTransportKeyInd_3:
   \   00004A   7410         MOV     A,#0x10
   \   00004C   6A           XRL     A,R2
   \   00004D   7013         JNZ     ??ZDSecMgrTransportKeyInd_4
   2806              {
   2807                // load preconfigured key - once!!
   2808                if ( !_NIB.nwkKeyLoaded )
   \   00004F   90....       MOV     DPTR,#_NIB + 61
   \   000052   E0           MOVX    A,@DPTR
   \   000053   7032         JNZ     ??ZDSecMgrTransportKeyInd_5
   2809                {
   2810                  SSP_UpdateNwkKey( (byte*)zgPreConfigKey, 0 );
   \   000055                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   000055   7900         MOV     R1,#0x0
   \   000057   7A..         MOV     R2,#zgPreConfigKey & 0xff
   \   000059   7B..         MOV     R3,#(zgPreConfigKey >> 8) & 0xff
   \   00005B   12....       LCALL   `??SSP_UpdateNwkKey::?relay`; Banked call to: SSP_UpdateNwkKey
   2811                  SSP_SwitchNwkKey( 0 );
   \   00005E                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   00005E   7900         MOV     R1,#0x0
   \   000060   8022         SJMP    ??ZDSecMgrTransportKeyInd_6
   2812                }
   2813              }
   2814              else
   2815              {
   2816                SSP_UpdateNwkKey( ind->key, ind->keySeqNum );
   \                     ??ZDSecMgrTransportKeyInd_4:
   \   000062   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   000065                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   000065   85..82       MOV     DPL,?V0
   \   000068   F583         MOV     DPH,A
   \   00006A   E0           MOVX    A,@DPTR
   \   00006B   F9           MOV     R1,A
   \   00006C   EE           MOV     A,R6
   \   00006D   2406         ADD     A,#0x6
   \   00006F   FA           MOV     R2,A
   \   000070   E4           CLR     A
   \   000071   3F           ADDC    A,R7
   \   000072   FB           MOV     R3,A
   \   000073   12....       LCALL   `??SSP_UpdateNwkKey::?relay`; Banked call to: SSP_UpdateNwkKey
   2817                if ( !_NIB.nwkKeyLoaded )
   \   000076   90....       MOV     DPTR,#_NIB + 61
   \   000079   E0           MOVX    A,@DPTR
   \   00007A   700B         JNZ     ??ZDSecMgrTransportKeyInd_5
   2818                {
   2819                  SSP_SwitchNwkKey( ind->keySeqNum );
   \   00007C                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   00007C   85..82       MOV     DPL,?V0
   \   00007F   85..83       MOV     DPH,?V1
   \   000082   E0           MOVX    A,@DPTR
   \   000083   F9           MOV     R1,A
   \                     ??ZDSecMgrTransportKeyInd_6:
   \   000084   12....       LCALL   `??SSP_SwitchNwkKey::?relay`; Banked call to: SSP_SwitchNwkKey
   2820                }
   2821              }
   2822          
   2823              // handle next step in authentication process
   2824              ZDSecMgrAuthNwkKey();
   \                     ??ZDSecMgrTransportKeyInd_5:
   \   000087                ; Setup parameters for call to function ZDSecMgrAuthNwkKey
   \   000087   12....       LCALL   `??ZDSecMgrAuthNwkKey::?relay`; Banked call to: ZDSecMgrAuthNwkKey
   2825            }
   2826            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   2827            {
   2828              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2829              {
   2830                //ZDSecMgrTCLinkKey( ind );
   2831              }
   2832            }
   2833            else if ( ind->keyType == KEY_TYPE_APP_MASTER )
   2834            {
   2835              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2836              {
   2837                uint16           ami;
   2838                AddrMgrEntry_t   entry;
   2839                ZDSecMgrEntry_t* entryZD;
   2840          
   2841                ZDSecMgrExtAddrLookup( ind->srcExtAddr, &ami );
   2842          
   2843                if ( ind->initiator == TRUE )
   2844                {
   2845                  // get the ami data
   2846                  entry.user  = ADDRMGR_USER_SECURITY;
   2847                  entry.index = ami;
   2848                  AddrMgrEntryGet( &entry );
   2849          
   2850                  if ( entry.nwkAddr != INVALID_NODE_ADDR )
   2851                  {
   2852                    APSME_EstablishKeyReq_t req;
   2853                    ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2854          
   2855                    ZDSecMgrEntryLookupAMI( ami, &entryZD );
   2856          
   2857                    if ( entryZD == NULL )
   2858                    {
   2859                      // get new entry
   2860                      if ( ZDSecMgrEntryNew( &entryZD ) == ZSuccess )
   2861                      {
   2862                        // finish setting up entry
   2863                        entryZD->ami = ami;
   2864                      }
   2865                    }
   2866          
   2867                    req.respExtAddr = ind->srcExtAddr;
   2868                    req.method      = APSME_SKKE_METHOD;
   2869                    req.dstAddr     = entry.nwkAddr;
   2870                    //devtag.0604.todo - remove obsolete
   2871                    req.apsSecure   = FALSE;
   2872                    req.nwkSecure   = TRUE;
   2873                    APSME_EstablishKeyReq( &req );
   2874                  }
   2875                }
   2876                else
   2877                {
   2878                  if ( ami == INVALID_NODE_ADDR )
   2879                  {
   2880                    // store new EXT address
   2881                    ZDSecMgrAddrStore( INVALID_NODE_ADDR, ind->srcExtAddr, &ami );
   2882                  }
   2883          
   2884                  ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2885                }
   2886          
   2887                //if ( entry.nwkAddr == INVALID_NODE_ADDR )
   2888                //{
   2889                //  ZDP_NwkAddrReq( ind->srcExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   2890                //}
   2891              }
   2892            }
   2893            else if ( ind->keyType == KEY_TYPE_APP_LINK )
   2894            {
   2895              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2896              {
   2897                uint16           ami;
   2898                ZDSecMgrEntry_t* entry;
   2899          
   2900                // get the address index
   2901                if ( ZDSecMgrExtAddrLookup( ind->srcExtAddr, &ami ) != ZSuccess )
   2902                {
   2903                  // store new EXT address
   2904                  ZDSecMgrAddrStore( INVALID_NODE_ADDR, ind->srcExtAddr, &ami );
   2905                  ZDP_NwkAddrReq( ind->srcExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   2906                }
   2907          
   2908                ZDSecMgrEntryLookupAMI( ami, &entry );
   2909          
   2910                if ( entry == NULL )
   2911                {
   2912                  // get new entry
   2913                  if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   2914                  {
   2915                    // finish setting up entry
   2916                    entry->ami = ami;
   2917                  }
   2918                }
   2919          
   2920                ZDSecMgrLinkKeySet( ind->srcExtAddr, ind->key );
   2921              }
   2922            }
   2923          }
   \                     ??ZDSecMgrTransportKeyInd_0:
   \   00008A   02....       LJMP    ??Subroutine86_0 & 0xFFFF
   2924          
   2925          /******************************************************************************
   2926           * @fn          ZDSecMgrUpdateDeviceInd
   2927           *
   2928           * @brief       Process the ZDO_UpdateDeviceInd_t message.
   2929           *
   2930           * @param       ind - [in] ZDO_UpdateDeviceInd_t indication
   2931           *
   2932           * @return      none
   2933           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2934          void ZDSecMgrUpdateDeviceInd( ZDO_UpdateDeviceInd_t* ind )
   \                     ZDSecMgrUpdateDeviceInd:
   2935          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 10
   \   000004   74F6         MOV     A,#-0xa
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   2936            ZDSecMgrDevice_t device;
   2937          
   2938          
   2939            device.nwkAddr    = ind->devAddr;
   \   000009   EA           MOV     A,R2
   \   00000A   240C         ADD     A,#0xc
   \   00000C   F582         MOV     DPL,A
   \   00000E   E4           CLR     A
   \   00000F   3B           ADDC    A,R3
   \   000010   F583         MOV     DPH,A
   \   000012   12....       LCALL   ?Subroutine31 & 0xFFFF
   2940            device.extAddr    = ind->devExtAddr;
   \                     ??CrossCallReturnLabel_145:
   \   000015   EA           MOV     A,R2
   \   000016   2404         ADD     A,#0x4
   \   000018   F8           MOV     R0,A
   \   000019   E4           CLR     A
   \   00001A   3B           ADDC    A,R3
   \   00001B   F9           MOV     R1,A
   \   00001C   7402         MOV     A,#0x2
   \   00001E   12....       LCALL   ?XSTACK_DISP0_8
   \   000021   12....       LCALL   ?Subroutine19 & 0xFFFF
   2941            device.parentAddr = ind->srcAddr;
   \                     ??CrossCallReturnLabel_1:
   \   000024   12....       LCALL   ?XSTACK_DISP0_8
   \   000027   12....       LCALL   ?Subroutine15 & 0xFFFF
   2942          
   2943            //if ( ( ind->status == APSME_UD_SECURED_JOIN   ) ||
   2944            //     ( ind->status == APSME_UD_UNSECURED_JOIN )   )
   2945            //{
   2946            //  if ( ind->status == APSME_UD_SECURED_JOIN )
   2947            //  {
   2948            //    device.secure = TRUE;
   2949            //  }
   2950            //  else
   2951            //  {
   2952            //    device.secure = FALSE;
   2953            //  }
   2954          
   2955              // try to join this device
   2956              ZDSecMgrDeviceJoin( &device );
   \                     ??CrossCallReturnLabel_147:
   \   00002A   12....       LCALL   `??ZDSecMgrDeviceJoin::?relay`; Banked call to: ZDSecMgrDeviceJoin
   2957            //}
   2958          }
   \   00002D                REQUIRE ?Subroutine14
   \   00002D                ; // Fall through to label ?Subroutine14

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   740A         MOV     A,#0xa
   \   000002   80..         SJMP    ??Subroutine92_0
   2959          
   2960          /******************************************************************************
   2961           * @fn          ZDSecMgrRemoveDeviceInd
   2962           *
   2963           * @brief       Process the ZDO_RemoveDeviceInd_t message.
   2964           *
   2965           * @param       ind - [in] ZDO_RemoveDeviceInd_t indication
   2966           *
   2967           * @return      none
   2968           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2969          void ZDSecMgrRemoveDeviceInd( ZDO_RemoveDeviceInd_t* ind )
   \                     ZDSecMgrRemoveDeviceInd:
   2970          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2971            ZDSecMgrDevice_t device;
   2972          
   2973          
   2974            // only accept from Trust Center
   2975            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   00000A   8A82         MOV     DPL,R2
   \   00000C   8B83         MOV     DPH,R3
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   12....       LCALL   ??Subroutine83_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_171:
   \   000013   702F         JNZ     ??ZDSecMgrRemoveDeviceInd_0
   2976            {
   2977              // look up NWK address
   2978              if ( APSME_LookupNwkAddr( ind->childExtAddr, &device.nwkAddr ) == TRUE )
   \   000015   EA           MOV     A,R2
   \   000016   2404         ADD     A,#0x4
   \   000018   FE           MOV     R6,A
   \   000019   E4           CLR     A
   \   00001A   3B           ADDC    A,R3
   \   00001B   FF           MOV     R7,A
   \   00001C                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   00001C   AC..         MOV     R4,?XSP + 0
   \   00001E   AD..         MOV     R5,?XSP + 1
   \   000020   EE           MOV     A,R6
   \   000021   FA           MOV     R2,A
   \   000022   EF           MOV     A,R7
   \   000023   FB           MOV     R3,A
   \   000024   12....       LCALL   `??APSME_LookupNwkAddr::?relay`; Banked call to: APSME_LookupNwkAddr
   \   000027   E9           MOV     A,R1
   \   000028   6401         XRL     A,#0x1
   \   00002A   7018         JNZ     ??ZDSecMgrRemoveDeviceInd_0
   2979              {
   2980                device.parentAddr = NLME_GetShortAddr();
   \   00002C                ; Setup parameters for call to function NLME_GetShortAddr
   \   00002C   12....       LCALL   `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   00002F   7404         MOV     A,#0x4
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   12....       LCALL   ??Subroutine73_0 & 0xFFFF
   2981                device.extAddr    = ind->childExtAddr;
   2982          
   2983                // remove device
   2984                ZDSecMgrDeviceRemove( &device );
   2985              }
   2986            }
   \                     ??CrossCallReturnLabel_92:
   \   000037   12....       LCALL   ?XSTACK_DISP0_8
   \   00003A   EE           MOV     A,R6
   \   00003B   F0           MOVX    @DPTR,A
   \   00003C   A3           INC     DPTR
   \   00003D   EF           MOV     A,R7
   \   00003E   12....       LCALL   ??Subroutine80_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_161:
   \   000041   12....       LCALL   `??ZDSecMgrDeviceRemove::?relay`; Banked call to: ZDSecMgrDeviceRemove
   2987          }
   \                     ??ZDSecMgrRemoveDeviceInd_0:
   \   000044   740A         MOV     A,#0xa
   \   000046   02....       LJMP    ??Subroutine71_0 & 0xFFFF
   2988          
   2989          /******************************************************************************
   2990           * @fn          ZDSecMgrRequestKeyInd
   2991           *
   2992           * @brief       Process the ZDO_RequestKeyInd_t message.
   2993           *
   2994           * @param       ind - [in] ZDO_RequestKeyInd_t indication
   2995           *
   2996           * @return      none
   2997           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2998          void ZDSecMgrRequestKeyInd( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrRequestKeyInd:
   2999          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3000            if ( ind->keyType == KEY_TYPE_NWK )
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F8           MOV     R0,A
   \   00000E   7401         MOV     A,#0x1
   \   000010   68           XRL     A,R0
   \   000011   6008         JZ      ??ZDSecMgrRequestKeyInd_0
   3001            {
   3002            }
   3003            else if ( ind->keyType == KEY_TYPE_APP_MASTER )
   \   000013   7402         MOV     A,#0x2
   \   000015   68           XRL     A,R0
   \   000016   7003         JNZ     ??ZDSecMgrRequestKeyInd_0
   3004            {
   3005              ZDSecMgrAppKeyReq( ind );
   \   000018                ; Setup parameters for call to function ZDSecMgrAppKeyReq
   \   000018   12....       LCALL   `??ZDSecMgrAppKeyReq::?relay`; Banked call to: ZDSecMgrAppKeyReq
   3006            }
   3007            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   3008            {
   3009            }
   3010            //else ignore
   3011          }
   \                     ??ZDSecMgrRequestKeyInd_0:
   \   00001B   02....       LJMP    ??Subroutine77_0 & 0xFFFF
   3012          
   3013          /******************************************************************************
   3014           * @fn          ZDSecMgrSwitchKeyInd
   3015           *
   3016           * @brief       Process the ZDO_SwitchKeyInd_t message.
   3017           *
   3018           * @param       ind - [in] ZDO_SwitchKeyInd_t indication
   3019           *
   3020           * @return      none
   3021           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3022          void ZDSecMgrSwitchKeyInd( ZDO_SwitchKeyInd_t* ind )
   \                     ZDSecMgrSwitchKeyInd:
   3023          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3024            SSP_SwitchNwkKey( ind->keySeqNum );
   \   000004                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F9           MOV     R1,A
   \   00000E   12....       LCALL   `??SSP_SwitchNwkKey::?relay`; Banked call to: SSP_SwitchNwkKey
   3025          
   3026            // Save if nv
   3027            ZDApp_NVUpdate();
   \   000011                ; Setup parameters for call to function ZDApp_NVUpdate
   \   000011   12....       LCALL   `??ZDApp_NVUpdate::?relay`; Banked call to: ZDApp_NVUpdate
   3028          }
   \   000014   02....       LJMP    ??Subroutine77_0 & 0xFFFF
   3029          
   3030          /******************************************************************************
   3031           * @fn          ZDSecMgrAuthenticateInd
   3032           *
   3033           * @brief       Process the ZDO_AuthenticateInd_t message.
   3034           *
   3035           * @param       ind - [in] ZDO_AuthenticateInd_t indication
   3036           *
   3037           * @return      none
   3038           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3039          void ZDSecMgrAuthenticateInd( ZDO_AuthenticateInd_t* ind )
   \                     ZDSecMgrAuthenticateInd:
   3040          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 20
   \   000005   74EC         MOV     A,#-0x14
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   3041            APSME_AuthenticateReq_t req;
   3042            AddrMgrEntry_t          entry;
   3043          
   3044          
   3045            // update the address manager
   3046            //---------------------------------------------------------------------------
   3047            // note:
   3048            // required for EA processing, but ultimately EA logic could also use the
   3049            // neighbor table to look up addresses -- also(IF using EA) the neighbor
   3050            // table is supposed to have authentication states for neighbors
   3051            //---------------------------------------------------------------------------
   3052            entry.user    = ADDRMGR_USER_SECURITY;
   \   00000E   7407         MOV     A,#0x7
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   7402         MOV     A,#0x2
   \   000015   F0           MOVX    @DPTR,A
   3053            entry.nwkAddr = ind->aps.initNwkAddr;
   \   000016   EE           MOV     A,R6
   \   000017   2402         ADD     A,#0x2
   \   000019   F5..         MOV     ?V2,A
   \   00001B   E4           CLR     A
   \   00001C   3F           ADDC    A,R7
   \   00001D   F5..         MOV     ?V3,A
   \   00001F   85..82       MOV     DPL,?V2
   \   000022   F583         MOV     DPH,A
   \   000024   12....       LCALL   ??Subroutine88_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_192:
   \   000027   7408         MOV     A,#0x8
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   12....       LCALL   ??Subroutine79_0 & 0xFFFF
   3054            AddrMgrExtAddrSet( entry.extAddr, ind->aps.initExtAddr );
   \                     ??CrossCallReturnLabel_141:
   \   00002F   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   000032                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000032   AC..         MOV     R4,?V0
   \   000034   FD           MOV     R5,A
   \   000035   740A         MOV     A,#0xa
   \   000037   12....       LCALL   ?XSTACK_DISP0_8
   \   00003A   AA82         MOV     R2,DPL
   \   00003C   AB83         MOV     R3,DPH
   \   00003E   12....       LCALL   `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
   3055          
   3056            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   000041                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000041   7407         MOV     A,#0x7
   \   000043   12....       LCALL   ?XSTACK_DISP101_8
   \   000046   12....       LCALL   `??AddrMgrEntryUpdate::?relay`; Banked call to: AddrMgrEntryUpdate
   \   000049   E9           MOV     A,R1
   \   00004A   6401         XRL     A,#0x1
   \   00004C   7030         JNZ     ??ZDSecMgrAuthenticateInd_0
   3057            {
   3058              // set request fields
   3059              req.nwkAddr   = ind->aps.initNwkAddr;
   \   00004E   85..82       MOV     DPL,?V2
   \   000051   85..83       MOV     DPH,?V3
   \   000054   12....       LCALL   ??Subroutine88_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_193:
   \   000057   12....       LCALL   ?Subroutine30 & 0xFFFF
   3060              req.extAddr   = ind->aps.initExtAddr;
   \                     ??CrossCallReturnLabel_199:
   \   00005A   12....       LCALL   ?XSTACK_DISP0_8
   \   00005D   E5..         MOV     A,?V0
   \   00005F   F0           MOVX    @DPTR,A
   \   000060   A3           INC     DPTR
   \   000061   E5..         MOV     A,?V1
   \   000063   F0           MOVX    @DPTR,A
   3061              req.action    = APSME_EA_ACCEPT;
   \   000064   7406         MOV     A,#0x6
   \   000066   12....       LCALL   ?XSTACK_DISP0_8
   \   000069   7401         MOV     A,#0x1
   \   00006B   F0           MOVX    @DPTR,A
   3062              req.challenge = ind->aps.challenge;
   \   00006C   EE           MOV     A,R6
   \   00006D   240C         ADD     A,#0xc
   \   00006F   F8           MOV     R0,A
   \   000070   E4           CLR     A
   \   000071   3F           ADDC    A,R7
   \   000072   F9           MOV     R1,A
   \   000073   7404         MOV     A,#0x4
   \   000075   12....       LCALL   ?XSTACK_DISP0_8
   \   000078   12....       LCALL   ?Subroutine15 & 0xFFFF
   3063          
   3064              // start EA processing
   3065              APSME_AuthenticateReq( &req );
   3066            }
   \                     ??CrossCallReturnLabel_148:
   \   00007B   12....       LCALL   `??APSME_AuthenticateReq::?relay`; Banked call to: APSME_AuthenticateReq
   3067          }
   \                     ??ZDSecMgrAuthenticateInd_0:
   \   00007E   7414         MOV     A,#0x14
   \   000080   02....       LJMP    ??Subroutine81_0 & 0xFFFF
   3068          
   3069          /******************************************************************************
   3070           * @fn          ZDSecMgrAuthenticateCfm
   3071           *
   3072           * @brief       Process the ZDO_AuthenticateCfm_t message.
   3073           *
   3074           * @param       cfm - [in] ZDO_AuthenticateCfm_t confirmation
   3075           *
   3076           * @return      none
   3077           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3078          void ZDSecMgrAuthenticateCfm( ZDO_AuthenticateCfm_t* cfm )
   \                     ZDSecMgrAuthenticateCfm:
   3079          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3080            if ( cfm->aps.status == ZSuccess )
   \   000004   EA           MOV     A,R2
   \   000005   240B         ADD     A,#0xb
   \   000007   F582         MOV     DPL,A
   \   000009   E4           CLR     A
   \   00000A   3B           ADDC    A,R3
   \   00000B   F583         MOV     DPH,A
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   701F         JNZ     ??ZDSecMgrAuthenticateCfm_0
   3081            {
   3082              if ( ( cfm->aps.initiator == TRUE ) && ( devState == DEV_END_DEVICE_UNAUTH ) )
   \   000010   8A82         MOV     DPL,R2
   \   000012   8B83         MOV     DPH,R3
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   6401         XRL     A,#0x1
   \   000019   7014         JNZ     ??ZDSecMgrAuthenticateCfm_0
   \   00001B   90....       MOV     DPTR,#devState
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   6405         XRL     A,#0x5
   \   000021   700C         JNZ     ??ZDSecMgrAuthenticateCfm_0
   3083              {
   3084                // inform ZDO that device has been authenticated
   3085                osal_set_event ( ZDAppTaskID, ZDO_DEVICE_AUTH );
   \   000023                ; Setup parameters for call to function osal_set_event
   \   000023   7A80         MOV     R2,#-0x80
   \   000025   7B00         MOV     R3,#0x0
   \   000027   90....       MOV     DPTR,#ZDAppTaskID
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F9           MOV     R1,A
   \   00002C   12....       LCALL   `??osal_set_event::?relay`; Banked call to: osal_set_event
   3086              }
   3087            }
   3088          }
   \                     ??ZDSecMgrAuthenticateCfm_0:
   \   00002F   02....       LJMP    ??Subroutine77_0 & 0xFFFF
   3089          
   3090          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3091          /******************************************************************************
   3092           * @fn          ZDSecMgrUpdateNwkKey
   3093           *
   3094           * @brief       Load a new NWK key and trigger a network wide update.
   3095           *
   3096           * @param       key       - [in] new NWK key
   3097           * @param       keySeqNum - [in] new NWK key sequence number
   3098           *
   3099           * @return      ZStatus_t
   3100           */
   3101          ZStatus_t ZDSecMgrUpdateNwkKey( uint8* key, uint8 keySeqNum, uint16 dstAddr )
   3102          {
   3103            ZStatus_t               status;
   3104            APSME_TransportKeyReq_t req;
   3105          
   3106            // initialize common elements of local variables
   3107            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3108              req.keyType   = KEY_TYPE_NWK_HIGH;
   3109            else
   3110              req.keyType   = KEY_TYPE_NWK;
   3111          
   3112            req.dstAddr   = dstAddr;
   3113            req.keySeqNum = keySeqNum;
   3114            req.key       = key;
   3115            req.extAddr   = NULL;
   3116            req.nwkSecure = TRUE;
   3117            req.apsSecure = TRUE;
   3118            req.tunnel    = NULL;
   3119          
   3120            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3121            {
   3122              ZDSecMgrEntry_t*        entry;
   3123              uint16                  index;
   3124              AddrMgrEntry_t          addrEntry;
   3125          
   3126              addrEntry.user = ADDRMGR_USER_SECURITY;
   3127          
   3128              status = ZFailure;
   3129          
   3130              // verify data is available
   3131              if ( ZDSecMgrEntries != NULL )
   3132              {
   3133                // find available entry
   3134                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   3135                {
   3136                  if ( ZDSecMgrEntries[index].ami != INVALID_NODE_ADDR )
   3137                  {
   3138                    // return successful result
   3139                    entry = &ZDSecMgrEntries[index];
   3140          
   3141                    // get NWK address
   3142                    addrEntry.index = entry->ami;
   3143                    if ( AddrMgrEntryGet( &addrEntry ) == TRUE )
   3144                    {
   3145                      req.dstAddr = addrEntry.nwkAddr;
   3146                      req.extAddr = addrEntry.extAddr;
   3147                      status = APSME_TransportKeyReq( &req );
   3148                    }
   3149                  }
   3150                }
   3151              }
   3152            }
   3153            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   3154            {
   3155              status = APSME_TransportKeyReq( &req );
   3156            }
   3157          
   3158            SSP_UpdateNwkKey( key, keySeqNum );
   3159          
   3160            // Save if nv
   3161            ZDApp_NVUpdate();
   3162          
   3163            return status;
   3164          }
   3165          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   3166          
   3167          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3168          /******************************************************************************
   3169           * @fn          ZDSecMgrSwitchNwkKey
   3170           *
   3171           * @brief       Causes the NWK key to switch via a network wide command.
   3172           *
   3173           * @param       keySeqNum - [in] new NWK key sequence number
   3174           *
   3175           * @return      ZStatus_t
   3176           */
   3177          ZStatus_t ZDSecMgrSwitchNwkKey( uint8 keySeqNum, uint16 dstAddr )
   3178          {
   3179            ZStatus_t            status;
   3180            APSME_SwitchKeyReq_t req;
   3181          
   3182            // initialize common elements of local variables
   3183            req.dstAddr = dstAddr;
   3184            req.keySeqNum = keySeqNum;
   3185          
   3186            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3187            {
   3188              ZDSecMgrEntry_t*     entry;
   3189              uint16               index;
   3190              AddrMgrEntry_t       addrEntry;
   3191          
   3192              addrEntry.user = ADDRMGR_USER_SECURITY;
   3193          
   3194              status = ZFailure;
   3195          
   3196              // verify data is available
   3197              if ( ZDSecMgrEntries != NULL )
   3198              {
   3199                // find available entry
   3200                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   3201                {
   3202                  if ( ZDSecMgrEntries[index].ami != INVALID_NODE_ADDR )
   3203                  {
   3204                    // return successful result
   3205                    entry = &ZDSecMgrEntries[index];
   3206          
   3207                    // get NWK address
   3208                    addrEntry.index = entry->ami;
   3209          
   3210                    if ( AddrMgrEntryGet( &addrEntry ) == TRUE )
   3211                    {
   3212                      req.dstAddr = addrEntry.nwkAddr;
   3213                      status = APSME_SwitchKeyReq( &req );
   3214                    }
   3215                  }
   3216                }
   3217              }
   3218            }
   3219            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   3220            {
   3221              status = APSME_SwitchKeyReq( &req );
   3222            }
   3223          
   3224            SSP_SwitchNwkKey( keySeqNum );
   3225          
   3226            // Save if nv
   3227            ZDApp_NVUpdate();
   3228          
   3229            return status;
   3230          }
   3231          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   3232          
   3233          #if ( ZG_BUILD_JOINING_TYPE )
   3234          /******************************************************************************
   3235           * @fn          ZDSecMgrRequestAppKey
   3236           *
   3237           * @brief       Request an application key with partner.
   3238           *
   3239           * @param       partNwkAddr - [in] partner network address
   3240           *
   3241           * @return      ZStatus_t
   3242           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3243          ZStatus_t ZDSecMgrRequestAppKey( uint16 partNwkAddr )
   \                     ZDSecMgrRequestAppKey:
   3244          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 12
   \   000004   74F4         MOV     A,#-0xc
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   3245            ZStatus_t             status;
   3246            APSME_RequestKeyReq_t req;
   3247            uint8                 partExtAddr[Z_EXTADDR_LEN];
   3248          
   3249          
   3250            if ( AddrMgrExtAddrLookup( partNwkAddr, partExtAddr ) )
   \   000009                ; Setup parameters for call to function AddrMgrExtAddrLookup
   \   000009   7404         MOV     A,#0x4
   \   00000B   12....       LCALL   ?XSTACK_DISP102_8
   \   00000E   12....       LCALL   `??AddrMgrExtAddrLookup::?relay`; Banked call to: AddrMgrExtAddrLookup
   \   000011   E9           MOV     A,R1
   \   000012   6023         JZ      ??ZDSecMgrRequestAppKey_0
   3251            {
   3252              req.dstAddr = 0;
   \   000014   85..82       MOV     DPL,?XSP + 0
   \   000017   85..83       MOV     DPH,?XSP + 1
   \   00001A   E4           CLR     A
   \   00001B   F0           MOVX    @DPTR,A
   3253              req.keyType = KEY_TYPE_APP_MASTER;
   \   00001C   04           INC     A
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   7402         MOV     A,#0x2
   \   000022   F0           MOVX    @DPTR,A
   3254              req.partExtAddr = partExtAddr;
   \   000023   7404         MOV     A,#0x4
   \   000025   12....       LCALL   ?XSTACK_DISP100_8
   \   000028   7402         MOV     A,#0x2
   \   00002A   12....       LCALL   ?XSTACK_DISP0_8
   \   00002D   12....       LCALL   ?Subroutine15 & 0xFFFF
   3255              status = APSME_RequestKeyReq( &req );
   3256            }
   \                     ??CrossCallReturnLabel_149:
   \   000030   12....       LCALL   `??APSME_RequestKeyReq::?relay`; Banked call to: APSME_RequestKeyReq
   \   000033   E9           MOV     A,R1
   \   000034   F9           MOV     R1,A
   \   000035   8002         SJMP    ??ZDSecMgrRequestAppKey_1
   3257            else
   3258            {
   3259              status = ZFailure;
   \                     ??ZDSecMgrRequestAppKey_0:
   \   000037   7901         MOV     R1,#0x1
   3260            }
   3261          
   3262            return status;
   \                     ??ZDSecMgrRequestAppKey_1:
   \   000039   740C         MOV     A,#0xc
   \   00003B   02....       LJMP    ??Subroutine92_0 & 0xFFFF
   3263          }
   3264          #endif // ( ZG_BUILD_JOINING_TYPE )
   3265          
   3266          #if ( ZG_BUILD_JOINING_TYPE )
   3267          /******************************************************************************
   3268           * @fn          ZDSecMgrSetupPartner
   3269           *
   3270           * @brief       Setup for application key partner.
   3271           *
   3272           * @param       partNwkAddr - [in] partner network address
   3273           *
   3274           * @return      ZStatus_t
   3275           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3276          ZStatus_t ZDSecMgrSetupPartner( uint16 partNwkAddr, uint8* partExtAddr )
   \                     ZDSecMgrSetupPartner:
   3277          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   8C..         MOV     ?V0,R4
   \   000010   8D..         MOV     ?V1,R5
   3278            AddrMgrEntry_t entry;
   3279            ZStatus_t      status;
   3280          
   3281            status = ZFailure;
   \   000012   75..01       MOV     ?V2,#0x1
   3282          
   3283            // update the address manager
   3284            entry.user    = ADDRMGR_USER_SECURITY;
   \   000015   85..82       MOV     DPL,?XSP + 0
   \   000018   85..83       MOV     DPH,?XSP + 1
   \   00001B   7402         MOV     A,#0x2
   \   00001D   F0           MOVX    @DPTR,A
   3285            entry.nwkAddr = partNwkAddr;
   \   00001E   14           DEC     A
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   EE           MOV     A,R6
   \   000023   F0           MOVX    @DPTR,A
   \   000024   A3           INC     DPTR
   \   000025   EF           MOV     A,R7
   \   000026   F0           MOVX    @DPTR,A
   3286            AddrMgrExtAddrSet( entry.extAddr, partExtAddr );
   \   000027                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000027   7403         MOV     A,#0x3
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   AA82         MOV     R2,DPL
   \   00002E   AB83         MOV     R3,DPH
   \   000030   12....       LCALL   `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
   3287          
   3288            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   000033                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000033   AA..         MOV     R2,?XSP + 0
   \   000035   AB..         MOV     R3,?XSP + 1
   \   000037   12....       LCALL   `??AddrMgrEntryUpdate::?relay`; Banked call to: AddrMgrEntryUpdate
   \   00003A   E9           MOV     A,R1
   \   00003B   6401         XRL     A,#0x1
   \   00003D   7036         JNZ     ??ZDSecMgrSetupPartner_0
   3289            {
   3290              status = ZSuccess;
   \   00003F   75..00       MOV     ?V2,#0x0
   3291          
   3292              // check for address discovery
   3293              if ( partNwkAddr == INVALID_NODE_ADDR )
   \   000042   74FE         MOV     A,#-0x2
   \   000044   6E           XRL     A,R6
   \   000045   7003         JNZ     ??ZDSecMgrSetupPartner_1
   \   000047   74FF         MOV     A,#-0x1
   \   000049   6F           XRL     A,R7
   \                     ??ZDSecMgrSetupPartner_1:
   \   00004A   700F         JNZ     ??ZDSecMgrSetupPartner_2
   3294              {
   3295                status = ZDP_NwkAddrReq( partExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   \   00004C                ; Setup parameters for call to function ZDP_NwkAddrReq
   \   00004C   7D00         MOV     R5,#0x0
   \   00004E   7C00         MOV     R4,#0x0
   \   000050   7900         MOV     R1,#0x0
   \   000052   AA..         MOV     R2,?V0
   \   000054   AB..         MOV     R3,?V1
   \   000056   12....       LCALL   `??ZDP_NwkAddrReq::?relay`; Banked call to: ZDP_NwkAddrReq
   \   000059   8017         SJMP    ??ZDSecMgrSetupPartner_3
   3296              }
   3297              else if ( !AddrMgrExtAddrValid( partExtAddr ) )
   \                     ??ZDSecMgrSetupPartner_2:
   \   00005B                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   00005B   AA..         MOV     R2,?V0
   \   00005D   AB..         MOV     R3,?V1
   \   00005F   12....       LCALL   `??AddrMgrExtAddrValid::?relay`; Banked call to: AddrMgrExtAddrValid
   \   000062   E9           MOV     A,R1
   \   000063   7010         JNZ     ??ZDSecMgrSetupPartner_0
   3298              {
   3299                status = ZDP_IEEEAddrReq( partNwkAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   \   000065                ; Setup parameters for call to function ZDP_IEEEAddrReq
   \   000065   7D00         MOV     R5,#0x0
   \   000067   7C00         MOV     R4,#0x0
   \   000069   7900         MOV     R1,#0x0
   \   00006B   EE           MOV     A,R6
   \   00006C   FA           MOV     R2,A
   \   00006D   EF           MOV     A,R7
   \   00006E   FB           MOV     R3,A
   \   00006F   12....       LCALL   `??ZDP_IEEEAddrReq::?relay`; Banked call to: ZDP_IEEEAddrReq
   \                     ??ZDSecMgrSetupPartner_3:
   \   000072   E9           MOV     A,R1
   \   000073   F5..         MOV     ?V2,A
   3300              }
   3301            }
   3302          
   3303            return status;
   \                     ??ZDSecMgrSetupPartner_0:
   \   000075   A9..         MOV     R1,?V2
   \   000077   740D         MOV     A,#0xd
   \   000079                REQUIRE ?Subroutine6
   \   000079                ; // Fall through to label ?Subroutine6
   3304          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F03         MOV     R7,#0x3
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA
   3305          #endif // ( ZG_BUILD_JOINING_TYPE )
   3306          
   3307          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3308          /******************************************************************************
   3309           * @fn          ZDSecMgrAppKeyTypeSet
   3310           *
   3311           * @brief       Set application key type.
   3312           *
   3313           * @param       keyType - [in] application key type (KEY_TYPE_APP_MASTER@2 or
   3314           *                                                   KEY_TYPE_APP_LINK@3
   3315           *
   3316           * @return      ZStatus_t
   3317           */
   3318          ZStatus_t ZDSecMgrAppKeyTypeSet( uint8 keyType )
   3319          {
   3320            if ( keyType == KEY_TYPE_APP_LINK )
   3321            {
   3322              ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;
   3323            }
   3324            else
   3325            {
   3326              ZDSecMgrAppKeyType = KEY_TYPE_APP_MASTER;
   3327            }
   3328          
   3329            return ZSuccess;
   3330          }
   3331          #endif
   3332          
   3333          /******************************************************************************
   3334           * ZigBee Device Security Manager - Stub Implementations
   3335           */
   3336          /******************************************************************************
   3337           * @fn          ZDSecMgrMasterKeyGet (stubs APSME_MasterKeyGet)
   3338           *
   3339           * @brief       Get MASTER key for specified EXT address.
   3340           *
   3341           * @param       extAddr - [in] EXT address
   3342           * @param       key     - [out] MASTER key
   3343           *
   3344           * @return      ZStatus_t
   3345           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3346          ZStatus_t ZDSecMgrMasterKeyGet( uint8* extAddr, uint8** key )
   \                     APSME_MasterKeyGet:
   3347          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   3348            ZStatus_t status;
   3349            uint16    ami;
   3350          
   3351          
   3352            // lookup entry for specified EXT address
   3353            status = ZDSecMgrExtAddrLookup( extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   AC..         MOV     R4,?XSP + 0
   \   000010   AD..         MOV     R5,?XSP + 1
   \   000012   12....       LCALL   `??ZDSecMgrExtAddrLookup::?relay`; Banked call to: ZDSecMgrExtAddrLookup
   \   000015   E9           MOV     A,R1
   \   000016   F5..         MOV     ?V0,A
   3354            //status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   3355          
   3356            if ( status == ZSuccess )
   \   000018   7008         JNZ     ??APSME_MasterKeyGet_0
   3357            {
   3358              ZDSecMgrMasterKeyLookup( ami, key );
   \   00001A                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   00001A   12....       LCALL   ?Subroutine36 & 0xFFFF
   3359            }
   \                     ??CrossCallReturnLabel_120:
   \   00001D   12....       LCALL   `??ZDSecMgrMasterKeyLookup::?relay`; Banked call to: ZDSecMgrMasterKeyLookup
   \   000020   8008         SJMP    ??APSME_MasterKeyGet_1
   3360            else
   3361            {
   3362              *key = NULL;
   \                     ??APSME_MasterKeyGet_0:
   \   000022   8E82         MOV     DPL,R6
   \   000024   8F83         MOV     DPH,R7
   \   000026   E4           CLR     A
   \   000027   F0           MOVX    @DPTR,A
   \   000028   A3           INC     DPTR
   \   000029   F0           MOVX    @DPTR,A
   3363            }
   3364          
   3365            return status;
   \                     ??APSME_MasterKeyGet_1:
   \   00002A   02....       LJMP    ?Subroutine1 & 0xFFFF
   3366          }
   3367          
   3368          /******************************************************************************
   3369           * @fn          ZDSecMgrLinkKeySet (stubs APSME_LinkKeySet)
   3370           *
   3371           * @brief       Set <APSME_LinkKeyData_t> for specified NWK address.
   3372           *
   3373           * @param       extAddr - [in] EXT address
   3374           * @param       data    - [in] APSME_LinkKeyData_t
   3375           *
   3376           * @return      ZStatus_t
   3377           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3378          ZStatus_t ZDSecMgrLinkKeySet( uint8* extAddr, uint8* key )
   \                     APSME_LinkKeySet:
   3379          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   3380            ZStatus_t        status;
   3381            ZDSecMgrEntry_t* entry;
   3382          
   3383          
   3384            // lookup entry index for specified EXT address
   3385            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000E                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000E   AC..         MOV     R4,?XSP + 0
   \   000010   AD..         MOV     R5,?XSP + 1
   \   000012   12....       LCALL   `??ZDSecMgrEntryLookupExt::?relay`; Banked call to: ZDSecMgrEntryLookupExt
   \   000015   E9           MOV     A,R1
   \   000016   F5..         MOV     ?V0,A
   3386          
   3387            if ( status == ZSuccess )
   \   000018   7038         JNZ     ??APSME_LinkKeySet_0
   3388            {
   3389              // setup the link key data reference
   3390              osal_memcpy( entry->lkd.key, key, SEC_KEY_LEN );
   \   00001A                ; Setup parameters for call to function osal_memcpy
   \   00001A   8E..         MOV     ?V4,R6
   \   00001C   8F..         MOV     ?V5,R7
   \   00001E   75..00       MOV     ?V6,#0x0
   \   000021   78..         MOV     R0,#?V4
   \   000023   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000026   7C10         MOV     R4,#0x10
   \   000028   7D00         MOV     R5,#0x0
   \   00002A   7403         MOV     A,#0x3
   \   00002C   12....       LCALL   ?XSTACK_DISP0_8
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   2402         ADD     A,#0x2
   \   000032   FA           MOV     R2,A
   \   000033   A3           INC     DPTR
   \   000034   E0           MOVX    A,@DPTR
   \   000035   3400         ADDC    A,#0x0
   \   000037   FB           MOV     R3,A
   \   000038   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   00003B   7403         MOV     A,#0x3
   \   00003D   12....       LCALL   ?DEALLOC_XSTACK8
   3391          
   3392              entry->lkd.apsmelkd.rxFrmCntr = 0;
   \   000040   12....       LCALL   ?Subroutine62 & 0xFFFF
   3393              entry->lkd.apsmelkd.txFrmCntr = 0;
   3394            }
   \                     ??CrossCallReturnLabel_221:
   \   000043   C8           XCH     A,R0
   \   000044   2418         ADD     A,#0x18
   \   000046   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   000049   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   00004C   2414         ADD     A,#0x14
   \   00004E   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   000051   F0           MOVX    @DPTR,A
   3395          
   3396            return status;
   \                     ??APSME_LinkKeySet_0:
   \   000052   A9..         MOV     R1,?V0
   \   000054   7402         MOV     A,#0x2
   \   000056   02....       LJMP    ?Subroutine5 & 0xFFFF
   3397          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine53:
   \   000000   F582         MOV     DPL,A
   \   000002   E4           CLR     A
   \   000003   38           ADDC    A,R0
   \   000004   F583         MOV     DPH,A
   \   000006   E4           CLR     A
   \   000007   F0           MOVX    @DPTR,A
   \   000008   A3           INC     DPTR
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   A3           INC     DPTR
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   A3           INC     DPTR
   \   00000D   22           RET
   3398          
   3399          /******************************************************************************
   3400           * @fn          ZDSecMgrAuthenticationSet
   3401           *
   3402           * @brief       Mark the specific device as authenticated or not
   3403           *
   3404           * @param       extAddr - [in] EXT address
   3405           * @param       option  - [in] authenticated or not
   3406           *
   3407           * @return      ZStatus_t
   3408           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3409          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option )
   \                     ZDSecMgrAuthenticationSet:
   3410          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   3411            ZStatus_t        status;
   3412            ZDSecMgrEntry_t* entry;
   3413          
   3414          
   3415            // lookup entry index for specified EXT address
   3416            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000C                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000C   AC..         MOV     R4,?XSP + 0
   \   00000E   AD..         MOV     R5,?XSP + 1
   \   000010   12....       LCALL   `??ZDSecMgrEntryLookupExt::?relay`; Banked call to: ZDSecMgrEntryLookupExt
   \   000013   E9           MOV     A,R1
   \   000014   F9           MOV     R1,A
   3417          
   3418            if ( status == ZSuccess )
   \   000015   700E         JNZ     ??ZDSecMgrAuthenticationSet_0
   3419            {
   3420              entry->authenticateOption = option;
   \   000017   12....       LCALL   ?Subroutine62 & 0xFFFF
   3421            }
   \                     ??CrossCallReturnLabel_222:
   \   00001A   C8           XCH     A,R0
   \   00001B   241C         ADD     A,#0x1c
   \   00001D   F582         MOV     DPL,A
   \   00001F   E4           CLR     A
   \   000020   38           ADDC    A,R0
   \   000021   F583         MOV     DPH,A
   \   000023   EE           MOV     A,R6
   \   000024   F0           MOVX    @DPTR,A
   3422          
   3423            return status;
   \                     ??ZDSecMgrAuthenticationSet_0:
   \   000025   02....       LJMP    ??Subroutine70_0 & 0xFFFF
   3424          }
   3425          
   3426          /******************************************************************************
   3427           * @fn          ZDSecMgrAuthenticationCheck
   3428           *
   3429           * @brief       Check if the specific device has been authenticated or not
   3430           *              For non-trust center device, always return true
   3431           *
   3432           * @param       shortAddr - [in] short address
   3433           *
   3434           * @return      TRUE @ authenticated with CBKE
   3435           *              FALSE @ not authenticated
   3436           */
   3437          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3438          uint8 ZDSecMgrAuthenticationCheck( uint16 shortAddr )
   \                     ZDSecMgrAuthenticationCheck:
   3439          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   3440          #if defined (TC_LINKKEY_JOIN)
   3441          
   3442            ZDSecMgrEntry_t* entry;
   3443            uint8 extAddr[Z_EXTADDR_LEN];
   3444          
   3445            // If the local device is not the trust center, always return TRUE
   3446            if ( NLME_GetShortAddr() != TCshortAddr )
   3447            {
   3448              return TRUE;
   3449            }
   3450            // Otherwise, check the authentication option
   3451            else if ( AddrMgrExtAddrLookup( shortAddr, extAddr ) )
   3452            {
   3453              // lookup entry index for specified EXT address
   3454              if ( ZDSecMgrEntryLookupExt( extAddr, &entry ) == ZSuccess )
   3455              {
   3456                if ( entry->authenticateOption != ZDSecMgr_Not_Authenticated )
   3457                {
   3458                  return TRUE;
   3459                }
   3460                else
   3461                {
   3462                  return FALSE;
   3463                }
   3464              }
   3465            }
   3466            return FALSE;
   3467          
   3468          #else
   3469            (void)shortAddr;  // Intentionally unreferenced parameter
   3470            
   3471            // For non AMI/SE Profile, perform no check and always return true.
   3472            return TRUE;
   \   000000   7901         MOV     R1,#0x1
   \   000002   02....       LJMP    ?BRET
   3473          
   3474          #endif // TC_LINKKEY_JOIN
   3475          }
   3476          
   3477          
   3478          /******************************************************************************
   3479           * @fn          ZDSecMgrLinkKeyDataGet (stubs APSME_LinkKeyDataGet)
   3480           *
   3481           * @brief       Get <APSME_LinkKeyData_t> for specified NWK address.
   3482           *
   3483           * @param       extAddr - [in] EXT address
   3484           * @param       data    - [out] APSME_LinkKeyData_t
   3485           *
   3486           * @return      ZStatus_t
   3487           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3488          ZStatus_t ZDSecMgrLinkKeyDataGet(uint8* extAddr, APSME_LinkKeyData_t** data)
   \                     APSME_LinkKeyDataGet:
   3489          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   3490            ZStatus_t        status;
   3491            ZDSecMgrEntry_t* entry;
   3492          
   3493          
   3494            // lookup entry index for specified NWK address
   3495            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000E                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000E   AC..         MOV     R4,?XSP + 0
   \   000010   AD..         MOV     R5,?XSP + 1
   \   000012   12....       LCALL   `??ZDSecMgrEntryLookupExt::?relay`; Banked call to: ZDSecMgrEntryLookupExt
   \   000015   E9           MOV     A,R1
   \   000016   F9           MOV     R1,A
   3496          
   3497            if ( status == ZSuccess )
   \   000017   702A         JNZ     ??APSME_LinkKeyDataGet_0
   3498            {
   3499              // setup the link key data reference
   3500              (*data) = &entry->lkd.apsmelkd;
   \   000019   85..82       MOV     DPL,?XSP + 0
   \   00001C   85..83       MOV     DPH,?XSP + 1
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   2412         ADD     A,#0x12
   \   000022   FA           MOV     R2,A
   \   000023   A3           INC     DPTR
   \   000024   E0           MOVX    A,@DPTR
   \   000025   3400         ADDC    A,#0x0
   \   000027   12....       LCALL   ?Subroutine33 & 0xFFFF
   3501              (*data)->key = entry->lkd.key;
   \                     ??CrossCallReturnLabel_130:
   \   00002A   85..82       MOV     DPL,?XSP + 0
   \   00002D   85..83       MOV     DPH,?XSP + 1
   \   000030   E0           MOVX    A,@DPTR
   \   000031   2402         ADD     A,#0x2
   \   000033   FC           MOV     R4,A
   \   000034   A3           INC     DPTR
   \   000035   E0           MOVX    A,@DPTR
   \   000036   3400         ADDC    A,#0x0
   \   000038   FD           MOV     R5,A
   \   000039   8A82         MOV     DPL,R2
   \   00003B   8B83         MOV     DPH,R3
   \   00003D   EC           MOV     A,R4
   \   00003E   F0           MOVX    @DPTR,A
   \   00003F   A3           INC     DPTR
   \   000040   ED           MOV     A,R5
   \   000041   8007         SJMP    ??APSME_LinkKeyDataGet_1
   3502            }
   3503            else
   3504            {
   3505              *data = NULL;
   \                     ??APSME_LinkKeyDataGet_0:
   \   000043   8E82         MOV     DPL,R6
   \   000045   8F83         MOV     DPH,R7
   \   000047   E4           CLR     A
   \   000048   F0           MOVX    @DPTR,A
   \   000049   A3           INC     DPTR
   \                     ??APSME_LinkKeyDataGet_1:
   \   00004A   F0           MOVX    @DPTR,A
   3506            }
   3507          
   3508            return status;
   \   00004B   02....       LJMP    ??Subroutine70_0 & 0xFFFF
   3509          }
   3510          
   3511          /******************************************************************************
   3512           * @fn          ZDSecMgrKeyFwdToChild (stubs APSME_KeyFwdToChild)
   3513           *
   3514           * @brief       Verify and process key transportation to child.
   3515           *
   3516           * @param       ind - [in] APSME_TransportKeyInd_t
   3517           *
   3518           * @return      uint8 - success(TRUE:FALSE)
   3519           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3520          uint8 ZDSecMgrKeyFwdToChild( APSME_TransportKeyInd_t* ind )
   \                     APSME_KeyFwdToChild:
   3521          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   3522            uint8 success;
   3523          
   3524            success = FALSE;
   \   000005   7E00         MOV     R6,#0x0
   3525          
   3526            // verify from Trust Center
   3527            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   000007   8A82         MOV     DPL,R2
   \   000009   8B83         MOV     DPH,R3
   \   00000B   12....       LCALL   ??Subroutine83_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_172:
   \   00000E   702B         JNZ     ??APSME_KeyFwdToChild_0
   3528            {
   3529              success = TRUE;
   \   000010   7E01         MOV     R6,#0x1
   3530          
   3531              // check for initial NWK key
   3532              if ( ( ind->keyType == KEY_TYPE_NWK      ) ||
   3533                   ( ind->keyType == 6                 ) ||
   3534                   ( ind->keyType == KEY_TYPE_NWK_HIGH )    )
   \   000012   8A82         MOV     DPL,R2
   \   000014   8B83         MOV     DPH,R3
   \   000016   A3           INC     DPTR
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   F8           MOV     R0,A
   \   00001A   EE           MOV     A,R6
   \   00001B   68           XRL     A,R0
   \   00001C   600A         JZ      ??APSME_KeyFwdToChild_1
   \   00001E   7406         MOV     A,#0x6
   \   000020   68           XRL     A,R0
   \   000021   6005         JZ      ??APSME_KeyFwdToChild_1
   \   000023   7405         MOV     A,#0x5
   \   000025   68           XRL     A,R0
   \   000026   7013         JNZ     ??APSME_KeyFwdToChild_0
   3535              {
   3536                // set association status to authenticated
   3537                ZDSecMgrAssocDeviceAuth( AssocGetWithExt( ind->dstExtAddr ) );
   \                     ??APSME_KeyFwdToChild_1:
   \   000028                ; Setup parameters for call to function AssocGetWithExt
   \   000028   8A82         MOV     DPL,R2
   \   00002A   8B83         MOV     DPH,R3
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   A3           INC     DPTR
   \   000032   12....       LCALL   ??Subroutine75_0 & 0xFFFF
   3538              }
   3539            }
   \                     ??CrossCallReturnLabel_110:
   \   000035   12....       LCALL   `??AssocGetWithExt::?relay`; Banked call to: AssocGetWithExt
   \   000038                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   000038   12....       LCALL   `??ZDSecMgrAssocDeviceAuth::?relay`; Banked call to: ZDSecMgrAssocDeviceAuth
   3540          
   3541            return success;
   \                     ??APSME_KeyFwdToChild_0:
   \   00003B   EE           MOV     A,R6
   \   00003C   F9           MOV     R1,A
   \   00003D   02....       LJMP    ??Subroutine86_0 & 0xFFFF
   3542          }
   3543          
   3544          /******************************************************************************
   3545           * @fn          ZDSecMgrAddLinkKey
   3546           *
   3547           * @brief       Add the application link key to ZDSecMgr. Also mark the device
   3548           *              as authenticated in the authenticateOption. Note that this function
   3549           *              is hardwared to CBKE right now.
   3550           *
   3551           * @param       shortAddr - short address of the partner device
   3552           * @param       extAddr - extended address of the partner device
   3553           * @param       key - link key
   3554           *
   3555           * @return      ZStatus_t
   3556           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3557          ZStatus_t ZDSecMgrAddLinkKey( uint16 shortAddr, uint8 *extAddr, uint8 *key)
   \                     ZDSecMgrAddLinkKey:
   3558          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   3559            uint16           ami;
   3560            ZDSecMgrEntry_t* entry;
   3561          
   3562            /* Store the device address in the addr manager */
   3563            if( ZDSecMgrAddrStore( shortAddr, extAddr, &ami ) != ZSuccess )
   \   00000E                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   00000E   7402         MOV     A,#0x2
   \   000010   12....       LCALL   ?XSTACK_DISP100_8
   \   000013   88..         MOV     ?V0,R0
   \   000015   89..         MOV     ?V1,R1
   \   000017   78..         MOV     R0,#?V0
   \   000019   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001C   12....       LCALL   `??ZDSecMgrAddrStore::?relay`; Banked call to: ZDSecMgrAddrStore
   \   00001F   7402         MOV     A,#0x2
   \   000021   12....       LCALL   ?DEALLOC_XSTACK8
   \   000024   E9           MOV     A,R1
   \   000025   6004         JZ      ??ZDSecMgrAddLinkKey_0
   3564            {
   3565              /* Adding to Addr Manager fails */
   3566              return ZFailure;
   \   000027   7901         MOV     R1,#0x1
   \   000029   803E         SJMP    ??ZDSecMgrAddLinkKey_1
   3567            }
   3568          
   3569            /* Lookup entry using specified address index */
   3570            ZDSecMgrEntryLookupAMI( ami, &entry );
   \                     ??ZDSecMgrAddLinkKey_0:
   \   00002B                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   00002B   AC..         MOV     R4,?XSP + 0
   \   00002D   AD..         MOV     R5,?XSP + 1
   \   00002F   7402         MOV     A,#0x2
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   12....       LCALL   ??Subroutine75_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_111:
   \   000037   12....       LCALL   `??ZDSecMgrEntryLookupAMI::?relay`; Banked call to: ZDSecMgrEntryLookupAMI
   3571          
   3572            // If no existing entry, create one
   3573            if ( entry == NULL )
   \   00003A   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_177:
   \   00003D   701D         JNZ     ??CrossCallReturnLabel_142
   3574            {
   3575              if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   \   00003F                ; Setup parameters for call to function ZDSecMgrEntryNew
   \   00003F   AA..         MOV     R2,?XSP + 0
   \   000041   AB..         MOV     R3,?XSP + 1
   \   000043   12....       LCALL   `??ZDSecMgrEntryNew::?relay`; Banked call to: ZDSecMgrEntryNew
   \   000046   E9           MOV     A,R1
   \   000047   7023         JNZ     ??ZDSecMgrAddLinkKey_2
   3576              {
   3577                entry->ami = ami;
   \   000049   7402         MOV     A,#0x2
   \   00004B   12....       LCALL   ?XSTACK_DISP0_8
   \   00004E   12....       LCALL   ?Subroutine43 & 0xFFFF
   3578              }
   \                     ??CrossCallReturnLabel_37:
   \   000051   E0           MOVX    A,@DPTR
   \   000052   FA           MOV     R2,A
   \   000053   A3           INC     DPTR
   \   000054   E0           MOVX    A,@DPTR
   \   000055   F583         MOV     DPH,A
   \   000057   8A82         MOV     DPL,R2
   \   000059   12....       LCALL   ??Subroutine79_0 & 0xFFFF
   3579              else
   3580              {
   3581                /* Security Manager full */
   3582                return ZBufferFull;
   3583              }
   3584            }
   3585            // Write the link key
   3586            APSME_LinkKeySet( extAddr, key );
   \                     ??CrossCallReturnLabel_142:
   \   00005C                ; Setup parameters for call to function APSME_LinkKeySet
   \   00005C   740E         MOV     A,#0xe
   \   00005E   12....       LCALL   ?XSTACK_DISP0_8
   \   000061   12....       LCALL   ??Subroutine94_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_226:
   \   000064   12....       LCALL   `??APSME_LinkKeySet::?relay`; Banked call to: APSME_LinkKeySet
   3587          
   3588          #if defined (TC_LINKKEY_JOIN)
   3589            // Mark the device as authenticated.
   3590            ZDSecMgrAuthenticationSet( extAddr, ZDSecMgr_Authenticated_CBCK );
   3591          #endif
   3592          
   3593          #if defined NV_RESTORE
   3594            ZDSecMgrWriteNV();  // Write the new established link key to NV.
   3595          #endif
   3596            
   3597            return ZSuccess;
   \   000067   7900         MOV     R1,#0x0
   \                     ??ZDSecMgrAddLinkKey_1:
   \   000069   02....       LJMP    ?Subroutine13 & 0xFFFF
   \                     ??ZDSecMgrAddLinkKey_2:
   \   00006C   7911         MOV     R1,#0x11
   \   00006E   80F9         SJMP    ??ZDSecMgrAddLinkKey_1
   3598          }
   3599          
   3600          #if defined ( NV_RESTORE )
   3601          /******************************************************************************
   3602           * @fn          ZDSecMgrInitNV
   3603           *
   3604           * @brief       Initialize the SecMgr entry data in NV.
   3605           *
   3606           * @param       none
   3607           *
   3608           * @return      uint8 - <osal_nv_item_init> return codes
   3609           */
   3610          uint8 ZDSecMgrInitNV(void)
   3611          {
   3612            uint8 rtrn = osal_nv_item_init(ZCD_NV_APS_LINK_KEY_TABLE, 
   3613                          (sizeof(nvDeviceListHdr_t) + (sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX)), NULL);
   3614            if (rtrn != ZSUCCESS)  // If the item does not already exist.
   3615            {
   3616              nvDeviceListHdr_t hdr;
   3617              hdr.numRecs = 0;
   3618              osal_nv_write(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr);
   3619            }
   3620          
   3621            return rtrn;
   3622          }
   3623          #endif // NV_RESTORE
   3624          
   3625          #if defined ( NV_RESTORE )
   3626          /*********************************************************************
   3627           * @fn      ZDSecMgrWriteNV()
   3628           *
   3629           * @brief   Save off the link key list to NV
   3630           *
   3631           * @param   none
   3632           *
   3633           * @return  none
   3634           */
   3635          static void ZDSecMgrWriteNV( void )
   3636          {
   3637            uint16 i;
   3638            nvDeviceListHdr_t hdr;
   3639          
   3640            hdr.numRecs = 0;
   3641          
   3642            if (ZDSecMgrEntries != NULL)
   3643            {
   3644              for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   3645              {
   3646                if ( ZDSecMgrEntries[i].ami != INVALID_NODE_ADDR )
   3647                {
   3648                  // Save off the record
   3649                  osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   3650                          (uint16)((sizeof(nvDeviceListHdr_t)) + (hdr.numRecs * sizeof(ZDSecMgrEntry_t))),
   3651                                  sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[i] );
   3652                  hdr.numRecs++;
   3653                }
   3654              }
   3655            }
   3656          
   3657            // Save off the header
   3658            osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof( nvDeviceListHdr_t ), &hdr );
   3659          }
   3660          #endif // NV_RESTORE
   3661          
   3662          #if defined ( NV_RESTORE )
   3663          /******************************************************************************
   3664           * @fn          ZDSecMgrRestoreFromNV
   3665           *
   3666           * @brief       Restore the SecMgr entry data from NV.
   3667           *
   3668           * @param       none
   3669           *
   3670           * @return      None.
   3671           */
   3672          static void ZDSecMgrRestoreFromNV( void )
   3673          {
   3674            nvDeviceListHdr_t hdr;
   3675          
   3676            if ((osal_nv_read(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr) == ZSUCCESS) &&
   3677                (hdr.numRecs <= ZDSECMGR_ENTRY_MAX))
   3678            {
   3679              uint8 x;
   3680          
   3681              for (x = 0; x < hdr.numRecs; x++)
   3682              {
   3683                if ( osal_nv_read( ZCD_NV_APS_LINK_KEY_TABLE,
   3684                          (uint16)(sizeof(nvDeviceListHdr_t) + (x * sizeof(ZDSecMgrEntry_t))),
   3685                                sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[x] ) == ZSUCCESS )
   3686                {
   3687                  ZDSecMgrEntries[x].lkd.apsmelkd.txFrmCntr += ( MAX_APS_FRAMECOUNTER_CHANGES + 1 );
   3688                }
   3689              }
   3690            }
   3691          }
   3692          #endif // NV_RESTORE
   3693          
   3694          /******************************************************************************
   3695           * @fn          ZDSecMgrAPSRemove
   3696           *
   3697           * @brief       Remove device from network.
   3698           *
   3699           * @param       nwkAddr - device's NWK address
   3700           * @param       extAddr - device's Extended address
   3701           * @param       parentAddr - parent's NWK address
   3702           *
   3703           * @return      ZStatus_t
   3704           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3705          ZStatus_t ZDSecMgrAPSRemove( uint16 nwkAddr, uint8 *extAddr, uint16 parentAddr )
   \                     ZDSecMgrAPSRemove:
   3706          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 10
   \   000004   74F6         MOV     A,#-0xa
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   3707            ZDSecMgrDevice_t device;
   3708          
   3709            if ( ( nwkAddr == INVALID_NODE_ADDR ) ||
   3710                 ( extAddr == NULL )              ||
   3711                 ( parentAddr == INVALID_NODE_ADDR ) )
   \   000009   74FE         MOV     A,#-0x2
   \   00000B   6A           XRL     A,R2
   \   00000C   7003         JNZ     ??ZDSecMgrAPSRemove_0
   \   00000E   74FF         MOV     A,#-0x1
   \   000010   6B           XRL     A,R3
   \                     ??ZDSecMgrAPSRemove_0:
   \   000011   6016         JZ      ??ZDSecMgrAPSRemove_1
   \   000013   EC           MOV     A,R4
   \   000014   4D           ORL     A,R5
   \   000015   6012         JZ      ??ZDSecMgrAPSRemove_1
   \   000017   740A         MOV     A,#0xa
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   12....       LCALL   ??Subroutine88_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_194:
   \   00001F   74FE         MOV     A,#-0x2
   \   000021   68           XRL     A,R0
   \   000022   7003         JNZ     ??ZDSecMgrAPSRemove_2
   \   000024   74FF         MOV     A,#-0x1
   \   000026   69           XRL     A,R1
   \                     ??ZDSecMgrAPSRemove_2:
   \   000027   7004         JNZ     ??ZDSecMgrAPSRemove_3
   3712            {
   3713              return ( ZFailure );
   \                     ??ZDSecMgrAPSRemove_1:
   \   000029   7901         MOV     R1,#0x1
   \   00002B   8018         SJMP    ??ZDSecMgrAPSRemove_4
   3714            }
   3715          
   3716            device.nwkAddr = nwkAddr;
   \                     ??ZDSecMgrAPSRemove_3:
   \   00002D   12....       LCALL   ?Subroutine26 & 0xFFFF
   3717            device.extAddr = extAddr;
   \                     ??CrossCallReturnLabel_91:
   \   000030   12....       LCALL   ?XSTACK_DISP0_8
   \   000033   EC           MOV     A,R4
   \   000034   F0           MOVX    @DPTR,A
   \   000035   A3           INC     DPTR
   \   000036   ED           MOV     A,R5
   \   000037   F0           MOVX    @DPTR,A
   3718            device.parentAddr = parentAddr;
   \   000038   7404         MOV     A,#0x4
   \   00003A   12....       LCALL   ?XSTACK_DISP0_8
   \   00003D   12....       LCALL   ?Subroutine15 & 0xFFFF
   3719          
   3720            // remove device
   3721            ZDSecMgrDeviceRemove( &device );
   \                     ??CrossCallReturnLabel_150:
   \   000040   12....       LCALL   `??ZDSecMgrDeviceRemove::?relay`; Banked call to: ZDSecMgrDeviceRemove
   3722          
   3723            return ( ZSuccess );
   \   000043   7900         MOV     R1,#0x0
   \                     ??ZDSecMgrAPSRemove_4:
   \   000045   02....       LJMP    ?Subroutine14 & 0xFFFF
   3724          }
   3725          
   3726          /******************************************************************************
   3727           * @fn          APSME_TCLinkKeyInit
   3728           *
   3729           * @brief       Initialize the NV table for preconfigured TC link key
   3730           *               
   3731           *              When zgUseDefaultTCL is set to TRUE, the default preconfig
   3732           *              Trust Center Link Key is written to NV. A single tclk is used   
   3733           *              by all devices joining the network.
   3734           *              
   3735           * @param       none
   3736           *
   3737           * @return      none
   3738           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3739          void APSME_TCLinkKeyInit(void)
   \                     APSME_TCLinkKeyInit:
   3740          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 32
   \   000005   74E0         MOV     A,#-0x20
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   3741            uint8             i;
   3742            APSME_TCLinkKey_t tcLinkKey;
   3743            
   3744            // Initialize all NV items for preconfigured tclk with 
   3745            // extended address all zero, if not exist already.
   3746            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \   00000A                ; Setup parameters for call to function osal_memset
   \   00000A   7C20         MOV     R4,#0x20
   \   00000C   7D00         MOV     R5,#0x0
   \   00000E   7900         MOV     R1,#0x0
   \   000010   AA..         MOV     R2,?XSP + 0
   \   000012   AB..         MOV     R3,?XSP + 1
   \   000014   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   3747            for( i = 1; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   3748            {
   3749              osal_nv_item_init( (ZCD_NV_TCLK_TABLE_START + i), 
   3750                                 sizeof(APSME_TCLinkKey_t), &tcLinkKey);
   3751            }
   3752            
   3753            // Initialize the default tclk
   3754            if( zgUseDefaultTCLK == TRUE )
   \   000017   90....       MOV     DPTR,#zgUseDefaultTCLK
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   6401         XRL     A,#0x1
   \   00001D   7030         JNZ     ??APSME_TCLinkKeyInit_0
   3755            {
   3756              osal_memset( tcLinkKey.extAddr, 0xFF, Z_EXTADDR_LEN );
   \   00001F                ; Setup parameters for call to function osal_memset
   \   00001F   7C08         MOV     R4,#0x8
   \   000021   7D00         MOV     R5,#0x0
   \   000023   79FF         MOV     R1,#-0x1
   \   000025   AA..         MOV     R2,?XSP + 0
   \   000027   AB..         MOV     R3,?XSP + 1
   \   000029   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   3757              osal_memcpy( tcLinkKey.key, defaultTCLinkKey, SEC_KEY_LEN);
   \   00002C                ; Setup parameters for call to function osal_memcpy
   \   00002C   75....       MOV     ?V0,#defaultTCLinkKey & 0xff
   \   00002F   75....       MOV     ?V1,#(defaultTCLinkKey >> 8) & 0xff
   \   000032   75..80       MOV     ?V2,#-0x80
   \   000035   78..         MOV     R0,#?V0
   \   000037   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00003A   7C10         MOV     R4,#0x10
   \   00003C   7D00         MOV     R5,#0x0
   \   00003E   740B         MOV     A,#0xb
   \   000040   12....       LCALL   ?XSTACK_DISP0_8
   \   000043   AA82         MOV     R2,DPL
   \   000045   AB83         MOV     R3,DPH
   \   000047   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   00004A   7403         MOV     A,#0x3
   \   00004C   12....       LCALL   ?DEALLOC_XSTACK8
   3758              
   3759              // If the item doesn't exist in NV memory, create and initialize
   3760              // it with the default value passed in.
   3761              osal_nv_item_init( ZCD_NV_TCLK_TABLE_START, sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   00004F                ; Setup parameters for call to function osal_nv_item_init
   3762            }
   3763            else
   3764            {
   3765              osal_nv_item_init( ZCD_NV_TCLK_TABLE_START, sizeof(APSME_TCLinkKey_t), &tcLinkKey);
   \                     ??APSME_TCLinkKeyInit_0:
   \   00004F                ; Setup parameters for call to function osal_nv_item_init
   \   00004F   A8..         MOV     R0,?XSP + 0
   \   000051   A9..         MOV     R1,?XSP + 1
   \   000053   88..         MOV     ?V0,R0
   \   000055   89..         MOV     ?V1,R1
   \   000057   78..         MOV     R0,#?V0
   \   000059   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005C   7C20         MOV     R4,#0x20
   \   00005E   7D00         MOV     R5,#0x0
   \   000060   7A01         MOV     R2,#0x1
   \   000062   7B01         MOV     R3,#0x1
   \   000064   12....       LCALL   `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   000067   7402         MOV     A,#0x2
   \   000069   12....       LCALL   ?DEALLOC_XSTACK8
   3766            }
   3767          }
   \   00006C   7420         MOV     A,#0x20
   \   00006E   02....       LJMP    ?Subroutine6 & 0xFFFF
   3768          
   3769          /******************************************************************************
   3770           * @fn          APSME_TCLinkKeySync
   3771           *
   3772           * @brief       Sync Trust Center LINK key data.
   3773           *
   3774           * @param       srcAddr - [in] srcAddr
   3775           * @param       si      - [in, out] SSP_Info_t
   3776           *
   3777           * @return      ZStatus_t
   3778           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3779          ZStatus_t APSME_TCLinkKeySync( uint16 srcAddr, SSP_Info_t* si )
   \                     APSME_TCLinkKeySync:
   3780          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 32
   \   000005   74E0         MOV     A,#-0x20
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V2,R2
   \   00000C   8B..         MOV     ?V3,R3
   \   00000E   8C..         MOV     ?V0,R4
   \   000010   8D..         MOV     ?V1,R5
   3781            ZStatus_t          status = ZSecNoKey;
   3782            uint8              i;
   3783            APSME_TCLinkKey_t  tcLinkKey;       
   3784            
   3785            // Look up the IEEE address of the trust center if it's available
   3786            if ( AddrMgrExtAddrValid( si->extAddr ) == false )
   \   000012   EC           MOV     A,R4
   \   000013   2406         ADD     A,#0x6
   \   000015   FE           MOV     R6,A
   \   000016   E4           CLR     A
   \   000017   35..         ADDC    A,?V1
   \   000019   FF           MOV     R7,A
   \   00001A                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   00001A   EE           MOV     A,R6
   \   00001B   FA           MOV     R2,A
   \   00001C   EF           MOV     A,R7
   \   00001D   FB           MOV     R3,A
   \   00001E   12....       LCALL   `??AddrMgrExtAddrValid::?relay`; Banked call to: AddrMgrExtAddrValid
   \   000021   E9           MOV     A,R1
   \   000022   700B         JNZ     ??APSME_TCLinkKeySync_0
   3787            {
   3788              APSME_LookupExtAddr( srcAddr, si->extAddr );
   \   000024                ; Setup parameters for call to function APSME_LookupExtAddr
   \   000024   EE           MOV     A,R6
   \   000025   FC           MOV     R4,A
   \   000026   EF           MOV     A,R7
   \   000027   FD           MOV     R5,A
   \   000028   AA..         MOV     R2,?V2
   \   00002A   AB..         MOV     R3,?V3
   \   00002C   12....       LCALL   `??APSME_LookupExtAddr::?relay`; Banked call to: APSME_LookupExtAddr
   3789            }
   3790            
   3791            // Look up the TC link key associated with the device
   3792            // or the default TC link key (extAddr is all FFs), whichever is found
   3793            for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   3794            {
   3795              // Read entry i of the TC link key table from NV
   3796              osal_nv_read( (ZCD_NV_TCLK_TABLE_START + i), 0, 
   3797                           sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \                     ??APSME_TCLinkKeySync_0:
   \   00002F                ; Setup parameters for call to function osal_nv_read
   \   00002F   A8..         MOV     R0,?XSP + 0
   \   000031   A9..         MOV     R1,?XSP + 1
   \   000033   88..         MOV     ?V2,R0
   \   000035   89..         MOV     ?V3,R1
   \   000037   78..         MOV     R0,#?V2
   \   000039   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003C   75..20       MOV     ?V2,#0x20
   \   00003F   75..00       MOV     ?V3,#0x0
   \   000042   78..         MOV     R0,#?V2
   \   000044   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000047   7C00         MOV     R4,#0x0
   \   000049   7D00         MOV     R5,#0x0
   \   00004B   7A01         MOV     R2,#0x1
   \   00004D   7B01         MOV     R3,#0x1
   \   00004F   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000052   7404         MOV     A,#0x4
   \   000054   12....       LCALL   ?DEALLOC_XSTACK8
   3798              
   3799              if( AddrMgrExtAddrEqual(si->extAddr, tcLinkKey.extAddr) || 
   3800                  APSME_IsDefaultTCLK(tcLinkKey.extAddr))
   \   000057                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   000057   AC..         MOV     R4,?XSP + 0
   \   000059   AD..         MOV     R5,?XSP + 1
   \   00005B   EE           MOV     A,R6
   \   00005C   FA           MOV     R2,A
   \   00005D   EF           MOV     A,R7
   \   00005E   FB           MOV     R3,A
   \   00005F   12....       LCALL   `??AddrMgrExtAddrEqual::?relay`; Banked call to: AddrMgrExtAddrEqual
   \   000062   E9           MOV     A,R1
   \   000063   700D         JNZ     ??APSME_TCLinkKeySync_1
   \   000065                ; Setup parameters for call to function APSME_IsDefaultTCLK
   \   000065   AA..         MOV     R2,?XSP + 0
   \   000067   AB..         MOV     R3,?XSP + 1
   \   000069   12....       LCALL   `??APSME_IsDefaultTCLK::?relay`; Banked call to: APSME_IsDefaultTCLK
   \   00006C   E9           MOV     A,R1
   \   00006D   7003         JNZ     $+5
   \   00006F   02....       LJMP    ??APSME_TCLinkKeySync_2 & 0xFFFF
   3801              {
   3802                // verify that the incoming frame counter is valid
   3803                if ( si->frmCntr >= tcLinkKey.rxFrmCntr )
   \                     ??APSME_TCLinkKeySync_1:
   \   000072   E5..         MOV     A,?V0
   \   000074   2412         ADD     A,#0x12
   \   000076   FE           MOV     R6,A
   \   000077   E4           CLR     A
   \   000078   35..         ADDC    A,?V1
   \   00007A   FF           MOV     R7,A
   \   00007B   741C         MOV     A,#0x1c
   \   00007D   12....       LCALL   ?XSTACK_DISP0_8
   \   000080   78..         MOV     R0,#?V4
   \   000082   12....       LCALL   ?L_MOV_X
   \   000085   8E82         MOV     DPL,R6
   \   000087   8F83         MOV     DPH,R7
   \   000089   78..         MOV     R0,#?V4
   \   00008B   12....       LCALL   ?UL_GT_X
   \   00008E   4076         JC      ??APSME_TCLinkKeySync_3
   3804                {
   3805                  // set the key to use
   3806                  osal_memcpy( si->key, tcLinkKey.key, SEC_KEY_LEN );
   \   000090                ; Setup parameters for call to function osal_memcpy
   \   000090   7408         MOV     A,#0x8
   \   000092   12....       LCALL   ?XSTACK_DISP0_8
   \   000095   A982         MOV     R1,DPL
   \   000097   AA83         MOV     R2,DPH
   \   000099   89..         MOV     ?V4,R1
   \   00009B   8A..         MOV     ?V5,R2
   \   00009D   75..00       MOV     ?V6,#0x0
   \   0000A0   78..         MOV     R0,#?V4
   \   0000A2   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000A5   7C10         MOV     R4,#0x10
   \   0000A7   7D00         MOV     R5,#0x0
   \   0000A9   E5..         MOV     A,?V0
   \   0000AB   240F         ADD     A,#0xf
   \   0000AD   F582         MOV     DPL,A
   \   0000AF   E4           CLR     A
   \   0000B0   35..         ADDC    A,?V1
   \   0000B2   F583         MOV     DPH,A
   \   0000B4   12....       LCALL   ??Subroutine75_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_112:
   \   0000B7   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   0000BA   7403         MOV     A,#0x3
   \   0000BC   12....       LCALL   ?DEALLOC_XSTACK8
   3807                  
   3808                  // update the rx frame counter
   3809                  tcLinkKey.rxFrmCntr = si->frmCntr + 1;
   \   0000BF   8E82         MOV     DPL,R6
   \   0000C1   8F83         MOV     DPH,R7
   \   0000C3   78..         MOV     R0,#?V0
   \   0000C5   12....       LCALL   ?L_MOV_X
   \   0000C8   90....       MOV     DPTR,#__Constant_1
   \   0000CB   78..         MOV     R0,#?V0
   \   0000CD   12....       LCALL   ?L_ADD_X
   \   0000D0   741C         MOV     A,#0x1c
   \   0000D2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D5   78..         MOV     R0,#?V0
   \   0000D7   12....       LCALL   ?L_MOV_TO_X
   3810                  
   3811                  // Write the tc link key back to the NV
   3812                  osal_nv_write( (ZCD_NV_TCLK_TABLE_START + i), 0, 
   3813                                sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   0000DA                ; Setup parameters for call to function osal_nv_write
   \   0000DA   A8..         MOV     R0,?XSP + 0
   \   0000DC   A9..         MOV     R1,?XSP + 1
   \   0000DE   88..         MOV     ?V0,R0
   \   0000E0   89..         MOV     ?V1,R1
   \   0000E2   78..         MOV     R0,#?V0
   \   0000E4   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000E7   75..20       MOV     ?V0,#0x20
   \   0000EA   75..00       MOV     ?V1,#0x0
   \   0000ED   78..         MOV     R0,#?V0
   \   0000EF   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000F2   7C00         MOV     R4,#0x0
   \   0000F4   7D00         MOV     R5,#0x0
   \   0000F6   7A01         MOV     R2,#0x1
   \   0000F8   7B01         MOV     R3,#0x1
   \   0000FA   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   0000FD   7404         MOV     A,#0x4
   \   0000FF   12....       LCALL   ?DEALLOC_XSTACK8
   3814                  
   3815                  status = ZSuccess;
   \   000102   7900         MOV     R1,#0x0
   \   000104   8006         SJMP    ??APSME_TCLinkKeySync_4
   3816                  
   3817                }
   3818                else
   3819                {
   3820                  status = ZSecOldFrmCount;
   \                     ??APSME_TCLinkKeySync_3:
   \   000106   79A2         MOV     R1,#-0x5e
   3821                }
   3822                
   3823                return status;
   \   000108   8002         SJMP    ??APSME_TCLinkKeySync_4
   3824              }
   3825            }
   3826            
   3827            
   3828            return status;
   \                     ??APSME_TCLinkKeySync_2:
   \   00010A   79A1         MOV     R1,#-0x5f
   \                     ??APSME_TCLinkKeySync_4:
   \   00010C   7420         MOV     A,#0x20
   \   00010E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000111   7F08         MOV     R7,#0x8
   \   000113   02....       LJMP    ?BANKED_LEAVE_XDATA
   3829          }
   3830          
   3831          /******************************************************************************
   3832           * @fn          APSME_TCLinkKeyLoad
   3833           *
   3834           * @brief       Load Trust Center LINK key data.
   3835           *
   3836           * @param       dstAddr - [in] dstAddr
   3837           * @param       si      - [in, out] SSP_Info_t
   3838           *
   3839           * @return      ZStatus_t
   3840           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3841          ZStatus_t APSME_TCLinkKeyLoad( uint16 dstAddr, SSP_Info_t* si )
   \                     APSME_TCLinkKeyLoad:
   3842          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 45
   \   000005   74D3         MOV     A,#-0x2d
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   3843            uint8              i;
   3844            APSME_TCLinkKey_t  tcLinkKey;
   3845            AddrMgrEntry_t     addrEntry;  
   3846            
   3847            // Look up the ami of the srcAddr if available
   3848            addrEntry.user    = ADDRMGR_USER_DEFAULT;
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   E4           CLR     A
   \   000015   F0           MOVX    @DPTR,A
   3849            addrEntry.nwkAddr = dstAddr;
   \   000016   04           INC     A
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   12....       LCALL   ??Subroutine78_0 & 0xFFFF
   3850          
   3851            APSME_LookupExtAddr( dstAddr, si->extAddr );
   \                     ??CrossCallReturnLabel_128:
   \   00001D   EE           MOV     A,R6
   \   00001E   2406         ADD     A,#0x6
   \   000020   F5..         MOV     ?V0,A
   \   000022   E4           CLR     A
   \   000023   3F           ADDC    A,R7
   \   000024   F5..         MOV     ?V1,A
   \   000026                ; Setup parameters for call to function APSME_LookupExtAddr
   \   000026   AC..         MOV     R4,?V0
   \   000028   FD           MOV     R5,A
   \   000029   12....       LCALL   `??APSME_LookupExtAddr::?relay`; Banked call to: APSME_LookupExtAddr
   3852          
   3853            if ( AddrMgrExtAddrValid( si->extAddr ) == TRUE )
   \   00002C                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   00002C   AA..         MOV     R2,?V0
   \   00002E   AB..         MOV     R3,?V1
   \   000030   12....       LCALL   `??AddrMgrExtAddrValid::?relay`; Banked call to: AddrMgrExtAddrValid
   \   000033   E9           MOV     A,R1
   \   000034   6401         XRL     A,#0x1
   \   000036   6003         JZ      $+5
   \   000038   02....       LJMP    ??APSME_TCLinkKeyLoad_0 & 0xFFFF
   3854            {
   3855              // Look up the TC link key associated with the device
   3856              // or the master TC link key (ami = 0xFFFF), whichever is found
   3857              for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   3858              {
   3859                // Read entry i of the TC link key table from NV
   3860                osal_nv_read( (ZCD_NV_TCLK_TABLE_START + i), 0, 
   3861                             sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   00003B                ; Setup parameters for call to function osal_nv_read
   \   00003B   740D         MOV     A,#0xd
   \   00003D   12....       LCALL   ?XSTACK_DISP100_8
   \   000040   88..         MOV     ?V2,R0
   \   000042   89..         MOV     ?V3,R1
   \   000044   78..         MOV     R0,#?V2
   \   000046   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000049   75..20       MOV     ?V2,#0x20
   \   00004C   75..00       MOV     ?V3,#0x0
   \   00004F   78..         MOV     R0,#?V2
   \   000051   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000054   7C00         MOV     R4,#0x0
   \   000056   7D00         MOV     R5,#0x0
   \   000058   7A01         MOV     R2,#0x1
   \   00005A   7B01         MOV     R3,#0x1
   \   00005C   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   00005F   7404         MOV     A,#0x4
   \   000061   12....       LCALL   ?DEALLOC_XSTACK8
   3862                
   3863                if( AddrMgrExtAddrEqual(si->extAddr, tcLinkKey.extAddr) || 
   3864                   APSME_IsDefaultTCLK(tcLinkKey.extAddr))
   \   000064                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   000064   740D         MOV     A,#0xd
   \   000066   12....       LCALL   ?XSTACK_DISP102_8
   \   000069   AA..         MOV     R2,?V0
   \   00006B   AB..         MOV     R3,?V1
   \   00006D   12....       LCALL   `??AddrMgrExtAddrEqual::?relay`; Banked call to: AddrMgrExtAddrEqual
   \   000070   E9           MOV     A,R1
   \   000071   700E         JNZ     ??APSME_TCLinkKeyLoad_1
   \   000073                ; Setup parameters for call to function APSME_IsDefaultTCLK
   \   000073   740D         MOV     A,#0xd
   \   000075   12....       LCALL   ?XSTACK_DISP101_8
   \   000078   12....       LCALL   `??APSME_IsDefaultTCLK::?relay`; Banked call to: APSME_IsDefaultTCLK
   \   00007B   E9           MOV     A,R1
   \   00007C   7003         JNZ     $+5
   \   00007E   02....       LJMP    ??APSME_TCLinkKeyLoad_0 & 0xFFFF
   3865                {
   3866                  // set the key to use
   3867                  osal_memcpy( si->key, tcLinkKey.key, SEC_KEY_LEN);  
   \                     ??APSME_TCLinkKeyLoad_1:
   \   000081                ; Setup parameters for call to function osal_memcpy
   \   000081   7415         MOV     A,#0x15
   \   000083   12....       LCALL   ?XSTACK_DISP0_8
   \   000086   A982         MOV     R1,DPL
   \   000088   AA83         MOV     R2,DPH
   \   00008A   89..         MOV     ?V0,R1
   \   00008C   8A..         MOV     ?V1,R2
   \   00008E   75..00       MOV     ?V2,#0x0
   \   000091   78..         MOV     R0,#?V0
   \   000093   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000096   7C10         MOV     R4,#0x10
   \   000098   7D00         MOV     R5,#0x0
   \   00009A   EE           MOV     A,R6
   \   00009B   240F         ADD     A,#0xf
   \   00009D   F582         MOV     DPL,A
   \   00009F   E4           CLR     A
   \   0000A0   3F           ADDC    A,R7
   \   0000A1   F583         MOV     DPH,A
   \   0000A3   12....       LCALL   ??Subroutine75_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_113:
   \   0000A6   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   0000A9   7403         MOV     A,#0x3
   \   0000AB   12....       LCALL   ?DEALLOC_XSTACK8
   3868                  
   3869                  // update link key related fields
   3870                  si->keyID   = SEC_KEYID_LINK;
   \   0000AE   EE           MOV     A,R6
   \   0000AF   240E         ADD     A,#0xe
   \   0000B1   F582         MOV     DPL,A
   \   0000B3   E4           CLR     A
   \   0000B4   3F           ADDC    A,R7
   \   0000B5   F583         MOV     DPH,A
   \   0000B7   E4           CLR     A
   \   0000B8   F0           MOVX    @DPTR,A
   3871                  si->frmCntr = tcLinkKey.txFrmCntr;
   \   0000B9   7425         MOV     A,#0x25
   \   0000BB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BE   12....       LCALL   ?XLOAD_R0123
   \   0000C1   EE           MOV     A,R6
   \   0000C2   2412         ADD     A,#0x12
   \   0000C4   F582         MOV     DPL,A
   \   0000C6   E4           CLR     A
   \   0000C7   3F           ADDC    A,R7
   \   0000C8   F583         MOV     DPH,A
   \   0000CA   12....       LCALL   ?XSTORE_R0123
   3872                
   3873                  // update outgoing frame counter
   3874                  tcLinkKey.txFrmCntr++;
   \   0000CD   90....       MOV     DPTR,#__Constant_1
   \   0000D0   78..         MOV     R0,#?V0
   \   0000D2   12....       LCALL   ?L_MOV_X
   \   0000D5   7425         MOV     A,#0x25
   \   0000D7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DA   78..         MOV     R0,#?V0
   \   0000DC   12....       LCALL   ?L_ADD_TO_X
   3875                  
   3876                  // Write the tc link key back to the NV
   3877                  osal_nv_write( (ZCD_NV_TCLK_TABLE_START + i), 0, 
   3878                                sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   0000DF                ; Setup parameters for call to function osal_nv_write
   \   0000DF   740D         MOV     A,#0xd
   \   0000E1   12....       LCALL   ?XSTACK_DISP100_8
   \   0000E4   88..         MOV     ?V0,R0
   \   0000E6   89..         MOV     ?V1,R1
   \   0000E8   78..         MOV     R0,#?V0
   \   0000EA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000ED   75..20       MOV     ?V0,#0x20
   \   0000F0   75..00       MOV     ?V1,#0x0
   \   0000F3   78..         MOV     R0,#?V0
   \   0000F5   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000F8   7C00         MOV     R4,#0x0
   \   0000FA   7D00         MOV     R5,#0x0
   \   0000FC   7A01         MOV     R2,#0x1
   \   0000FE   7B01         MOV     R3,#0x1
   \   000100   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000103   7404         MOV     A,#0x4
   \   000105   12....       LCALL   ?DEALLOC_XSTACK8
   3879                  
   3880                  return ZSuccess;
   \   000108   7900         MOV     R1,#0x0
   \   00010A   8015         SJMP    ??APSME_TCLinkKeyLoad_2
   3881                }
   3882              }
   3883            }
   3884              
   3885            // If no TC link key found, remove the device from the address manager
   3886            if ( AddrMgrEntryLookupNwk( &addrEntry ) == TRUE )
   \                     ??APSME_TCLinkKeyLoad_0:
   \   00010C                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   00010C   AA..         MOV     R2,?XSP + 0
   \   00010E   AB..         MOV     R3,?XSP + 1
   \   000110   12....       LCALL   `??AddrMgrEntryLookupNwk::?relay`; Banked call to: AddrMgrEntryLookupNwk
   \   000113   E9           MOV     A,R1
   \   000114   6401         XRL     A,#0x1
   \   000116   7007         JNZ     ??APSME_TCLinkKeyLoad_3
   3887            {
   3888              AddrMgrEntryRelease( &addrEntry );
   \   000118                ; Setup parameters for call to function AddrMgrEntryRelease
   \   000118   AA..         MOV     R2,?XSP + 0
   \   00011A   AB..         MOV     R3,?XSP + 1
   \   00011C   12....       LCALL   `??AddrMgrEntryRelease::?relay`; Banked call to: AddrMgrEntryRelease
   3889            }
   3890          
   3891            return ZSecNoKey;
   \                     ??APSME_TCLinkKeyLoad_3:
   \   00011F   79A1         MOV     R1,#-0x5f
   \                     ??APSME_TCLinkKeyLoad_2:
   \   000121   742D         MOV     A,#0x2d
   \   000123   02....       LJMP    ??Subroutine81_0 & 0xFFFF
   3892          }
   3893          
   3894          /******************************************************************************
   3895           * @fn          APSME_IsDefaultTCLK
   3896           *
   3897           * @brief       Return true or false based on the extended address.  If the 
   3898           *              input ext address is all FFs, it means the trust center link
   3899           *              assoiciated with the address is the default trust center link key
   3900           *
   3901           * @param       extAddr - [in] extended address
   3902           *
   3903           * @return      uint8 TRUE/FALSE
   3904           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3905          uint8 APSME_IsDefaultTCLK( uint8 *extAddr )
   \                     APSME_IsDefaultTCLK:
   3906          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   3907            uint8 i = 0;
   \   000005   7C00         MOV     R4,#0x0
   3908            
   3909            if( extAddr == NULL )
   \   000007   EA           MOV     A,R2
   \   000008   4B           ORL     A,R3
   \   000009   6021         JZ      ??APSME_IsDefaultTCLK_0
   3910            {
   3911              return FALSE;
   3912            }
   3913            
   3914            while( i++ < Z_EXTADDR_LEN )
   \                     ??APSME_IsDefaultTCLK_1:
   \   00000B   EC           MOV     A,R4
   \   00000C   FD           MOV     R5,A
   \   00000D   7401         MOV     A,#0x1
   \   00000F   2D           ADD     A,R5
   \   000010   FC           MOV     R4,A
   \   000011   ED           MOV     A,R5
   \   000012   C3           CLR     C
   \   000013   9408         SUBB    A,#0x8
   \   000015   5019         JNC     ??APSME_IsDefaultTCLK_2
   3915            {
   3916              if( *extAddr++ != 0xFF )
   \   000017   EA           MOV     A,R2
   \   000018   F8           MOV     R0,A
   \   000019   EB           MOV     A,R3
   \   00001A   F9           MOV     R1,A
   \   00001B   8882         MOV     DPL,R0
   \   00001D   8983         MOV     DPH,R1
   \   00001F   A3           INC     DPTR
   \   000020   AA82         MOV     R2,DPL
   \   000022   AB83         MOV     R3,DPH
   \   000024   8882         MOV     DPL,R0
   \   000026   8983         MOV     DPH,R1
   \   000028   E0           MOVX    A,@DPTR
   \   000029   F4           CPL     A
   \   00002A   60DF         JZ      ??APSME_IsDefaultTCLK_1
   3917              {
   3918                return FALSE;
   \                     ??APSME_IsDefaultTCLK_0:
   \   00002C   7900         MOV     R1,#0x0
   \   00002E   8002         SJMP    ??APSME_IsDefaultTCLK_3
   3919              }
   3920            }
   3921            
   3922            return TRUE;
   \                     ??APSME_IsDefaultTCLK_2:
   \   000030   7901         MOV     R1,#0x1
   \                     ??APSME_IsDefaultTCLK_3:
   \   000032   02....       LJMP    ??Subroutine72_0 & 0xFFFF
   3923          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine45:
   \   000000   A3           INC     DPTR
   \   000001   E0           MOVX    A,@DPTR
   \   000002   F583         MOV     DPH,A
   \   000004   8882         MOV     DPL,R0
   \   000006   74FE         MOV     A,#-0x2
   \   000008   F0           MOVX    @DPTR,A
   \   000009   A3           INC     DPTR
   \   00000A   04           INC     A
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   22           RET

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for ZDSecMgrTCMasterKey>`:
   \   000000   00           DB 0
   \   000001   00           DB 0
   \   000002   00           DB 0
   \   000003   00           DB 0
   \   000004   00           DB 0
   \   000005   00           DB 0
   \   000006   00           DB 0
   \   000007   00           DB 0
   \   000008   89           DB 137
   \   000009   67           DB 103
   \   00000A   45           DB 69
   \   00000B   23           DB 35
   \   00000C   01           DB 1
   \   00000D   EF           DB 239
   \   00000E   CD           DB 205
   \   00000F   AB           DB 171

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for ZDSecMgrAppKeyType>`:
   \   000000   03           DB 3

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_1:
   \   000000   01000000     DD 1

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrMasterKeyInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAddrStore::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddrStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrExtAddrStore::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrExtAddrStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrExtAddrLookup::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrExtAddrLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrMasterKeyLookup::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrMasterKeyStore::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryLookup::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryLookupAMI::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupAMI

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryLookupExt::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupExt

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryFree::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryFree

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryNew::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrCtrlInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrCtrlRelease::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlRelease

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrCtrlLookup::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrCtrlSet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlSet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrCtrlAdd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlAdd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrCtrlTerm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlTerm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrCtrlReset::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlReset

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrMasterKeyLoad::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAppKeyGet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAppKeyReq::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyReq

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEstablishKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSendMasterKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSendMasterKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSendNwkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSendNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceEntryRemove::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceEntryRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceRemoveByExtAddr::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceRemoveByExtAddr

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAddrMgrUpdate::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddrMgrUpdate

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceEntryAdd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceEntryAdd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceCtrlHandler::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlHandler

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceCtrlSetup::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlSetup

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceCtrlUpdate::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlUpdate

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_SKA_TimerExpired::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_SKA_TimerExpired

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceRemove::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceValidateSKKE::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateSKKE

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceValidateRM::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateRM

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceValidateCM::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateCM

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceValidate::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidate

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceJoin::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoin

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceJoinDirect::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoinDirect

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceJoinFwd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoinFwd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceNew::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAssocDeviceAuth::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAssocDeviceAuth

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAuthInitiate::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthInitiate

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAuthNwkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrConfig::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrConfig

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrPermitJoining::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrPermitJoining

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrPermitJoiningTimeout::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrPermitJoiningTimeout

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrNewDeviceEvent::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrNewDeviceEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEvent::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEstablishKeyCfm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKeyCfm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrTCExtAddrCheck::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTCExtAddrCheck

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrTCDataLoad::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTCDataLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEstablishKeyInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrTransportKeyInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTransportKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrUpdateDeviceInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrUpdateDeviceInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrRemoveDeviceInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRemoveDeviceInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrRequestKeyInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRequestKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSwitchKeyInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSwitchKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAuthenticateInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticateInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAuthenticateCfm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticateCfm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrRequestAppKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRequestAppKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSetupPartner::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSetupPartner

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_MasterKeyGet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_MasterKeyGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_LinkKeySet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_LinkKeySet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAuthenticationSet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticationSet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAuthenticationCheck::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticationCheck

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_LinkKeyDataGet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_LinkKeyDataGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_KeyFwdToChild::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_KeyFwdToChild

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAddLinkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddLinkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAPSRemove::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAPSRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_TCLinkKeyInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_TCLinkKeySync::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeySync

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_TCLinkKeyLoad::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeyLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_IsDefaultTCLK::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_IsDefaultTCLK
   3924          
   3925          
   3926          /******************************************************************************
   3927          ******************************************************************************/
   3928          

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      0     66   APSME_IsDefaultTCLK
      0     10   APSME_KeyFwdToChild
        0     10   -> AssocGetWithExt
        0     10   -> ZDSecMgrAssocDeviceAuth
      0     11   APSME_LinkKeyDataGet
        0     11   -> ZDSecMgrEntryLookupExt
      0     34   APSME_LinkKeySet
        0     17   -> ZDSecMgrEntryLookupExt
        0     20   -> osal_memcpy
      0     11   APSME_MasterKeyGet
        0     11   -> ZDSecMgrExtAddrLookup
        0     11   -> ZDSecMgrMasterKeyLookup
      0      0   APSME_SKA_TimerExpired
      0     46   APSME_TCLinkKeyInit
        0     46   -> osal_memcpy
        0     43   -> osal_memset
        0     45   -> osal_nv_item_init
      0     61   APSME_TCLinkKeyLoad
        0     57   -> APSME_IsDefaultTCLK
        0     57   -> APSME_LookupExtAddr
        0     57   -> AddrMgrEntryLookupNwk
        0     57   -> AddrMgrEntryRelease
        0     57   -> AddrMgrExtAddrEqual
        0     57   -> AddrMgrExtAddrValid
        0     60   -> osal_memcpy
        0     61   -> osal_nv_read
        0     61   -> osal_nv_write
      0     52   APSME_TCLinkKeySync
        0     48   -> APSME_IsDefaultTCLK
        0     48   -> APSME_LookupExtAddr
        0     48   -> AddrMgrExtAddrEqual
        0     48   -> AddrMgrExtAddrValid
        0     51   -> osal_memcpy
        0     52   -> osal_nv_read
        0     52   -> osal_nv_write
      2     12   ZDSecMgrAPSRemove
        2     10   -> ZDSecMgrDeviceRemove
      0     18   ZDSecMgrAddLinkKey
        0     14   -> APSME_LinkKeySet
        0     16   -> ZDSecMgrAddrStore
        0     14   -> ZDSecMgrEntryLookupAMI
        0     14   -> ZDSecMgrEntryNew
      0     36   ZDSecMgrAddrMgrUpdate
        0     22   -> AddrMgrEntryGet
        0     22   -> AddrMgrEntryUpdate
      0     38   ZDSecMgrAddrStore
        0     22   -> AddrMgrEntryUpdate
        0     22   -> AddrMgrExtAddrSet
      3     59   ZDSecMgrAppKeyGet
        2      0   -> SSP_GetTrueRand
      0     59   ZDSecMgrAppKeyReq
        0     51   -> APSME_LookupExtAddr
        0     51   -> APSME_LookupNwkAddr
        0     51   -> APSME_TransportKeyReq
        0     59   -> ZDSecMgrAppKeyGet
      2     35   ZDSecMgrAssocDeviceAuth
      0     16   ZDSecMgrAuthInitiate
        0     16   -> APSME_AuthenticateReq
        0     16   -> APSME_LookupNwkAddr
      2     10   ZDSecMgrAuthNwkKey
        2      0   -> osal_set_event
      2      0   ZDSecMgrAuthenticateCfm
        2      0   -> osal_set_event
      0     32   ZDSecMgrAuthenticateInd
        0     32   -> APSME_AuthenticateReq
        0     32   -> AddrMgrEntryUpdate
        0     32   -> AddrMgrExtAddrSet
      0      0   ZDSecMgrAuthenticationCheck
      1     11   ZDSecMgrAuthenticationSet
        0     11   -> ZDSecMgrEntryLookupExt
      2      0   ZDSecMgrConfig
        2      0   -> APSME_SecurityNM
      0     26   ZDSecMgrCtrlAdd
        0     14   -> ZDSecMgrCtrlSet
      2      0   ZDSecMgrCtrlInit
        2      0   -> osal_mem_alloc
      0     23   ZDSecMgrCtrlLookup
      2      0   ZDSecMgrCtrlRelease
      0     14   ZDSecMgrCtrlReset
        0     12   -> ZDSecMgrCtrlAdd
        0     12   -> ZDSecMgrCtrlLookup
        0     14   -> ZDSecMgrCtrlSet
      1     23   ZDSecMgrCtrlSet
      2      2   ZDSecMgrCtrlTerm
        2      2   -> ZDSecMgrCtrlLookup
      1     42   ZDSecMgrDeviceCtrlHandler
        0      9   -> ZDSecMgrEstablishKey
        0      9   -> ZDSecMgrSendMasterKey
        0      9   -> ZDSecMgrSendNwkKey
        0      9   -> osal_start_timerEx
      2      0   ZDSecMgrDeviceCtrlSetup
        2      0   -> ZDSecMgrDeviceCtrlHandler
      0     13   ZDSecMgrDeviceCtrlUpdate
        0     13   -> ZDSecMgrCtrlLookup
        0     13   -> ZDSecMgrEntryLookupExt
      0     28   ZDSecMgrDeviceEntryAdd
        0     14   -> ZDSecMgrAddrMgrUpdate
        0     14   -> ZDSecMgrEntryLookup
        0     14   -> ZDSecMgrEntryLookupAMI
        0     14   -> ZDSecMgrEntryNew
      2      0   ZDSecMgrDeviceEntryRemove
      0     24   ZDSecMgrDeviceJoin
        0     14   -> ZDSecMgrAddrStore
        0     12   -> ZDSecMgrDeviceRemove
        0     12   -> ZDSecMgrDeviceValidate
        0     12   -> ZDSecMgrSendNwkKey
      0      9   ZDSecMgrDeviceJoinDirect
        0      9   -> AssocGetWithShort
        0      9   -> ZDSecMgrAssocDeviceAuth
        0      9   -> ZDSecMgrDeviceJoin
      2      8   ZDSecMgrDeviceJoinFwd
        2      8   -> APSME_UpdateDeviceReq
      2     35   ZDSecMgrDeviceNew
        2      0   -> ZDSecMgrDeviceJoinFwd
      0     38   ZDSecMgrDeviceRemove
        0     19   -> APSME_RemoveDeviceReq
        0     19   -> AssocGetWithExt
        0     19   -> NLME_GetShortAddr
        0     19   -> NLME_LeaveReq
      2      2   ZDSecMgrDeviceRemoveByExtAddr
        2      2   -> ZDSecMgrEntryLookupExt
      2     12   ZDSecMgrDeviceValidate
        2      0   -> ZDSecMgrDeviceValidateRM
      0     16   ZDSecMgrDeviceValidateCM
        0     16   -> ZDSecMgrAddrStore
        0     14   -> ZDSecMgrDeviceEntryAdd
        0     14   -> ZDSecMgrMasterKeyLoad
      2      0   ZDSecMgrDeviceValidateRM
      0     44   ZDSecMgrDeviceValidateSKKE
        0     13   -> ZDSecMgrDeviceEntryAdd
        0     13   -> ZDSecMgrExtAddrLookup
        0     13   -> ZDSecMgrMasterKeyLookup
      2      0   ZDSecMgrEntryFree
      2      0   ZDSecMgrEntryInit
        2      0   -> osal_mem_alloc
      0     37   ZDSecMgrEntryLookup
        0     23   -> AddrMgrEntryLookupNwk
      0     24   ZDSecMgrEntryLookupAMI
      0     28   ZDSecMgrEntryLookupExt
        0     11   -> ZDSecMgrEntryLookupAMI
        0     11   -> ZDSecMgrExtAddrLookup
      0     24   ZDSecMgrEntryNew
      0     26   ZDSecMgrEstablishKey
        0     17   -> APSME_EstablishKeyReq
        0     17   -> NLME_GetShortAddr
      0      0   ZDSecMgrEstablishKeyCfm
      1     31   ZDSecMgrEstablishKeyInd
        0     31   -> APSME_EstablishKeyRsp
        0     31   -> ZDSecMgrDeviceValidateSKKE
        0     31   -> ZDSecMgrTCDataLoad
        0     31   -> ZDSecMgrTCExtAddrCheck
      1     33   ZDSecMgrEvent
        0     33   -> AddrMgrEntryGet
        0     33   -> ZDSecMgrDeviceCtrlHandler
        0     33   -> osal_start_timerEx
      0     41   ZDSecMgrExtAddrLookup
        0     22   -> AddrMgrEntryLookupExt
        0     22   -> AddrMgrExtAddrSet
      0     24   ZDSecMgrExtAddrStore
        0     22   -> AddrMgrEntryUpdate
        0     22   -> AddrMgrExtAddrSet
      2      0   ZDSecMgrInit
        2      0   -> APSME_SecurityNM
      2      0   ZDSecMgrMasterKeyInit
        2      0   -> osal_mem_alloc
      0     36   ZDSecMgrMasterKeyLoad
        0     19   -> ZDSecMgrExtAddrLookup
        0     19   -> ZDSecMgrMasterKeyLookup
        0     19   -> ZDSecMgrMasterKeyStore
        0     22   -> osal_memcpy
      0     33   ZDSecMgrMasterKeyLookup
      0     36   ZDSecMgrMasterKeyStore
        0     17   -> osal_memcpy
        0     14   -> osal_memset
      1     35   ZDSecMgrNewDeviceEvent
        0     35   -> AddrMgrEntryGet
        0     35   -> AssocMatchDeviceStatus
        0     35   -> AssocRemove
        0     35   -> NLME_GetShortAddr
        0     35   -> ZDSecMgrAssocDeviceAuth
        0     35   -> ZDSecMgrDeviceNew
      2      0   ZDSecMgrPermitJoining
      2      0   ZDSecMgrPermitJoiningTimeout
      0     19   ZDSecMgrRemoveDeviceInd
        0     19   -> APSME_LookupNwkAddr
        0     19   -> NLME_GetShortAddr
        0     19   -> ZDSecMgrDeviceRemove
      2     12   ZDSecMgrRequestAppKey
        2     12   -> APSME_RequestKeyReq
        2     12   -> AddrMgrExtAddrLookup
      2      0   ZDSecMgrRequestKeyInd
        2      0   -> ZDSecMgrAppKeyReq
      0     32   ZDSecMgrSendMasterKey
        0     23   -> APSME_TransportKeyReq
        0     23   -> NLME_GetShortAddr
        0     23   -> ZDSecMgrMasterKeyLookup
      1     37   ZDSecMgrSendNwkKey
        0     25   -> APSME_TransportKeyReq
        0     25   -> NLME_GetShortAddr
      0     24   ZDSecMgrSetupPartner
        0     24   -> AddrMgrEntryUpdate
        0     24   -> AddrMgrExtAddrSet
        0     24   -> AddrMgrExtAddrValid
        0     24   -> ZDP_IEEEAddrReq
        0     24   -> ZDP_NwkAddrReq
      2      0   ZDSecMgrSwitchKeyInd
        2      0   -> SSP_SwitchNwkKey
        2      0   -> ZDApp_NVUpdate
      0     47   ZDSecMgrTCDataLoad
        0     16   -> ZDSecMgrAddrStore
        0     14   -> ZDSecMgrMasterKeyLookup
        0     14   -> ZDSecMgrMasterKeyStore
      0     48   ZDSecMgrTCExtAddrCheck
        0     17   -> AddrMgrExtAddrEqual
        0     17   -> AddrMgrExtAddrLookup
      0     10   ZDSecMgrTransportKeyInd
        0     10   -> SSP_SwitchNwkKey
        0     10   -> SSP_UpdateNwkKey
        0     10   -> ZDSecMgrAuthNwkKey
        0     10   -> ZDSecMgrTCDataLoad
      2     10   ZDSecMgrUpdateDeviceInd
        2     10   -> ZDSecMgrDeviceJoin


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for ZDSecMgrAppKeyType>
      16  ?<Initializer for ZDSecMgrTCMasterKey>
       8  ??Subroutine64_0
      11  ??Subroutine65_0
      10  ??Subroutine66_0
       6  ??Subroutine67_0
       2  ??Subroutine68_0
       7  ??Subroutine69_0
       2  ??Subroutine70_0
       3  ??Subroutine71_0
       5  ??Subroutine72_0
       8  ??Subroutine73_0
       6  ??Subroutine74_0
       6  ??Subroutine75_0
       1  ??Subroutine76_0
       7  ??Subroutine77_0
       6  ??Subroutine78_0
       4  ??Subroutine79_0
       6  ??Subroutine80_0
       3  ??Subroutine81_0
       5  ??Subroutine82_0
       4  ??Subroutine83_0
       6  ??Subroutine84_0
       3  ??Subroutine85_0
       5  ??Subroutine86_0
       2  ??Subroutine87_0
       4  ??Subroutine88_0
       6  ??Subroutine89_0
       6  ??Subroutine90_0
       4  ??Subroutine91_0
       6  ??Subroutine92_0
       5  ??Subroutine93_0
      10  ??Subroutine94_0
      13  ?Subroutine0
       2  ?Subroutine1
       4  ?Subroutine10
       5  ?Subroutine11
       5  ?Subroutine12
       4  ?Subroutine13
       4  ?Subroutine14
       4  ?Subroutine15
       5  ?Subroutine16
       5  ?Subroutine17
       6  ?Subroutine18
      13  ?Subroutine19
       2  ?Subroutine2
      11  ?Subroutine20
      11  ?Subroutine21
       6  ?Subroutine22
       8  ?Subroutine23
      12  ?Subroutine24
       9  ?Subroutine25
       6  ?Subroutine26
       6  ?Subroutine27
       6  ?Subroutine28
       6  ?Subroutine29
       5  ?Subroutine3
       6  ?Subroutine30
       3  ?Subroutine31
       7  ?Subroutine32
       5  ?Subroutine33
       9  ?Subroutine34
       6  ?Subroutine35
       4  ?Subroutine36
       6  ?Subroutine37
      17  ?Subroutine38
      12  ?Subroutine39
       2  ?Subroutine4
      14  ?Subroutine40
       5  ?Subroutine41
       6  ?Subroutine42
       4  ?Subroutine43
       6  ?Subroutine44
      13  ?Subroutine45
       6  ?Subroutine46
      10  ?Subroutine47
      10  ?Subroutine48
       7  ?Subroutine49
       8  ?Subroutine5
      12  ?Subroutine50
      10  ?Subroutine51
      10  ?Subroutine52
      14  ?Subroutine53
       7  ?Subroutine54
       8  ?Subroutine55
       6  ?Subroutine56
      12  ?Subroutine57
       6  ?Subroutine58
      10  ?Subroutine59
       8  ?Subroutine6
       2  ?Subroutine60
      11  ?Subroutine61
       6  ?Subroutine62
       6  ?Subroutine63
       9  ?Subroutine7
       2  ?Subroutine8
       5  ?Subroutine9
      53  APSME_IsDefaultTCLK
       6  APSME_IsDefaultTCLK::?relay
      64  APSME_KeyFwdToChild
       6  APSME_KeyFwdToChild::?relay
      78  APSME_LinkKeyDataGet
       6  APSME_LinkKeyDataGet::?relay
      89  APSME_LinkKeySet
       6  APSME_LinkKeySet::?relay
      45  APSME_MasterKeyGet
       6  APSME_MasterKeyGet::?relay
       3  APSME_SKA_TimerExpired
       6  APSME_SKA_TimerExpired::?relay
     113  APSME_TCLinkKeyInit
       6  APSME_TCLinkKeyInit::?relay
     294  APSME_TCLinkKeyLoad
       6  APSME_TCLinkKeyLoad::?relay
     278  APSME_TCLinkKeySync
       6  APSME_TCLinkKeySync::?relay
      32  TrustCenterLinkKey
      72  ZDSecMgrAPSRemove
       6  ZDSecMgrAPSRemove::?relay
     112  ZDSecMgrAddLinkKey
       6  ZDSecMgrAddLinkKey::?relay
      70  ZDSecMgrAddrMgrUpdate
       6  ZDSecMgrAddrMgrUpdate::?relay
      75  ZDSecMgrAddrStore
       6  ZDSecMgrAddrStore::?relay
      42  ZDSecMgrAppKeyGet
       6  ZDSecMgrAppKeyGet::?relay
     255  ZDSecMgrAppKeyReq
       6  ZDSecMgrAppKeyReq::?relay
       1  ZDSecMgrAppKeyType
      23  ZDSecMgrAssocDeviceAuth
       6  ZDSecMgrAssocDeviceAuth::?relay
      60  ZDSecMgrAuthInitiate
       6  ZDSecMgrAuthInitiate::?relay
      26  ZDSecMgrAuthNwkKey
       6  ZDSecMgrAuthNwkKey::?relay
      50  ZDSecMgrAuthenticateCfm
       6  ZDSecMgrAuthenticateCfm::?relay
     131  ZDSecMgrAuthenticateInd
       6  ZDSecMgrAuthenticateInd::?relay
       5  ZDSecMgrAuthenticationCheck
       6  ZDSecMgrAuthenticationCheck::?relay
      40  ZDSecMgrAuthenticationSet
       6  ZDSecMgrAuthenticationSet::?relay
       2  ZDSecMgrConfig
       6  ZDSecMgrConfig::?relay
      96  ZDSecMgrCtrlAdd
       6  ZDSecMgrCtrlAdd::?relay
       2  ZDSecMgrCtrlData
      72  ZDSecMgrCtrlInit
       6  ZDSecMgrCtrlInit::?relay
      99  ZDSecMgrCtrlLookup
       6  ZDSecMgrCtrlLookup::?relay
      17  ZDSecMgrCtrlRelease
       6  ZDSecMgrCtrlRelease::?relay
      76  ZDSecMgrCtrlReset
       6  ZDSecMgrCtrlReset::?relay
      76  ZDSecMgrCtrlSet
       6  ZDSecMgrCtrlSet::?relay
      40  ZDSecMgrCtrlTerm
       6  ZDSecMgrCtrlTerm::?relay
      99  ZDSecMgrDeviceCtrlHandler
       6  ZDSecMgrDeviceCtrlHandler::?relay
      58  ZDSecMgrDeviceCtrlSetup
       6  ZDSecMgrDeviceCtrlSetup::?relay
      96  ZDSecMgrDeviceCtrlUpdate
       6  ZDSecMgrDeviceCtrlUpdate::?relay
     148  ZDSecMgrDeviceEntryAdd
       6  ZDSecMgrDeviceEntryAdd::?relay
       3  ZDSecMgrDeviceEntryRemove
       6  ZDSecMgrDeviceEntryRemove::?relay
      79  ZDSecMgrDeviceJoin
       6  ZDSecMgrDeviceJoin::?relay
      35  ZDSecMgrDeviceJoinDirect
       6  ZDSecMgrDeviceJoinDirect::?relay
     159  ZDSecMgrDeviceJoinFwd
       6  ZDSecMgrDeviceJoinFwd::?relay
       9  ZDSecMgrDeviceNew
       6  ZDSecMgrDeviceNew::?relay
     174  ZDSecMgrDeviceRemove
       6  ZDSecMgrDeviceRemove::?relay
      34  ZDSecMgrDeviceRemoveByExtAddr
       6  ZDSecMgrDeviceRemoveByExtAddr::?relay
      49  ZDSecMgrDeviceValidate
       6  ZDSecMgrDeviceValidate::?relay
      99  ZDSecMgrDeviceValidateCM
       6  ZDSecMgrDeviceValidateCM::?relay
      17  ZDSecMgrDeviceValidateRM
       6  ZDSecMgrDeviceValidateRM::?relay
      66  ZDSecMgrDeviceValidateSKKE
       6  ZDSecMgrDeviceValidateSKKE::?relay
       2  ZDSecMgrEntries
       3  ZDSecMgrEntryFree
       6  ZDSecMgrEntryFree::?relay
      73  ZDSecMgrEntryInit
       6  ZDSecMgrEntryInit::?relay
     123  ZDSecMgrEntryLookup
       6  ZDSecMgrEntryLookup::?relay
      81  ZDSecMgrEntryLookupAMI
       6  ZDSecMgrEntryLookupAMI::?relay
      35  ZDSecMgrEntryLookupExt
       6  ZDSecMgrEntryLookupExt::?relay
     109  ZDSecMgrEntryNew
       6  ZDSecMgrEntryNew::?relay
     100  ZDSecMgrEstablishKey
       6  ZDSecMgrEstablishKey::?relay
       3  ZDSecMgrEstablishKeyCfm
       6  ZDSecMgrEstablishKeyCfm::?relay
     229  ZDSecMgrEstablishKeyInd
       6  ZDSecMgrEstablishKeyInd::?relay
     273  ZDSecMgrEvent
       6  ZDSecMgrEvent::?relay
      69  ZDSecMgrExtAddrLookup
       6  ZDSecMgrExtAddrLookup::?relay
      74  ZDSecMgrExtAddrStore
       6  ZDSecMgrExtAddrStore::?relay
       0  ZDSecMgrInit
       6  ZDSecMgrInit::?relay
       2  ZDSecMgrMasterKeyData
      65  ZDSecMgrMasterKeyInit
       6  ZDSecMgrMasterKeyInit::?relay
      87  ZDSecMgrMasterKeyLoad
       6  ZDSecMgrMasterKeyLoad::?relay
      83  ZDSecMgrMasterKeyLookup
       6  ZDSecMgrMasterKeyLookup::?relay
     136  ZDSecMgrMasterKeyStore
       6  ZDSecMgrMasterKeyStore::?relay
     181  ZDSecMgrNewDeviceEvent
       6  ZDSecMgrNewDeviceEvent::?relay
      39  ZDSecMgrPermitJoining
       6  ZDSecMgrPermitJoining::?relay
       1  ZDSecMgrPermitJoiningEnabled
       1  ZDSecMgrPermitJoiningTimed
      24  ZDSecMgrPermitJoiningTimeout
       6  ZDSecMgrPermitJoiningTimeout::?relay
      73  ZDSecMgrRemoveDeviceInd
       6  ZDSecMgrRemoveDeviceInd::?relay
      62  ZDSecMgrRequestAppKey
       6  ZDSecMgrRequestAppKey::?relay
      30  ZDSecMgrRequestKeyInd
       6  ZDSecMgrRequestKeyInd::?relay
     133  ZDSecMgrSendMasterKey
       6  ZDSecMgrSendMasterKey::?relay
     200  ZDSecMgrSendNwkKey
       6  ZDSecMgrSendNwkKey::?relay
     121  ZDSecMgrSetupPartner
       6  ZDSecMgrSetupPartner::?relay
      23  ZDSecMgrSwitchKeyInd
       6  ZDSecMgrSwitchKeyInd::?relay
       1  ZDSecMgrTCAuthenticated
      86  ZDSecMgrTCDataLoad
       6  ZDSecMgrTCDataLoad::?relay
       1  ZDSecMgrTCDataLoaded
       8  ZDSecMgrTCExtAddr
      52  ZDSecMgrTCExtAddrCheck
       6  ZDSecMgrTCExtAddrCheck::?relay
      16  ZDSecMgrTCMasterKey
     141  ZDSecMgrTransportKeyInd
       6  ZDSecMgrTransportKeyInd::?relay
      45  ZDSecMgrUpdateDeviceInd
       6  ZDSecMgrUpdateDeviceInd::?relay
       4  __Constant_1

 
 6 969 bytes in segment BANKED_CODE
   456 bytes in segment BANK_RELAYS
    17 bytes in segment XDATA_I
    17 bytes in segment XDATA_ID
     4 bytes in segment XDATA_ROM_C
    50 bytes in segment XDATA_Z
 
 7 442 bytes of CODE  memory
     0 bytes of CONST memory (+ 4 bytes shared)
    67 bytes of XDATA memory

Errors: none
Warnings: none
